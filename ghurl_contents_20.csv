postid|data
14872829|"from nose.tools import assert_raises&#xa;from sqlalchemy.exc import IntegrityError&#xa;from flask.ext.testing import TestCase&#xa;&#xa;from flask_truss.factory import create_app&#xa;from flask_truss.conf.app import Config&#xa;from flask_truss.models.base import db&#xa;&#xa;&#xa;class LocalhostProxyHack(object):&#xa;    """"""Ensures that a remote_addr is available for testing.&#xa;    From http://stackoverflow.com/questions/14872829/get-ip-address-when-testing-flask-application-through-nosetests&#xa;    """"""&#xa;    def __init__(self, app):&#xa;        self.app = app&#xa;&#xa;    def __call__(self, environ, start_response):&#xa;        environ['REMOTE_ADDR'] = environ.get('REMOTE_ADDR', '127.0.0.1')&#xa;        return self.app(environ, start_response)&#xa;&#xa;&#xa;class BaseTestCase(TestCase):&#xa;    def create_app(self):&#xa;        config = Config()&#xa;        app = create_app(config)&#xa;        app.config['TESTING'] = True&#xa;        app.config['WTF_CSRF_ENABLED'] = False&#xa;        app.wsgi_app = LocalhostProxyHack(app.wsgi_app)&#xa;        test_client = app.test_client()&#xa;        app.post = test_client.post&#xa;        app.get = test_client.get&#xa;        return app&#xa;&#xa;    def setUp(self):&#xa;        """"""Create the testing database, then swap commit for flush""""""&#xa;        db.create_all()&#xa;        self.orig_commit = db.session.commit&#xa;        db.session.commit = db.session.flush&#xa;&#xa;    def tearDown(self):&#xa;        """"""Clean up session, sway flush for commit, drop the testing database""""""&#xa;        db.session.remove()&#xa;        db.session.commit = self.orig_commit&#xa;        db.drop_all()&#xa;&#xa;    def add_to_session_and_flush_expecting_exception(self, obj):&#xa;        db.session.add(obj)&#xa;        assert_raises(IntegrityError, db.session.flush)&#xa;        db.session.rollback()&#xa;&#xa;    def add_to_session_and_flush(self, obj):&#xa;        db.session.add(obj)&#xa;        db.session.flush()&#xa;"
651794|"'''&#xa;Created on Sep 15, 2012&#xa;&#xa;@author: gaprice@lbl.gov&#xa;'''&#xa;&#xa;from collections import defaultdict as _defaultdict&#xa;&#xa;&#xa;class AutoVivifingDict(dict):&#xa;    """"""Implementation of perl's autovivification feature.""""""&#xa;# see http://stackoverflow.com/questions/651794/whats-the-best-way-to-&#xa;# initialize-a-dict-of-dicts-in-python&#xa;&#xa;    def __getitem__(self, item):&#xa;        try:&#xa;            return dict.__getitem__(self, item)&#xa;        except KeyError:&#xa;            value = self[item] = type(self)()&#xa;            return value&#xa;&#xa;&#xa;class DictListWithSortedIterator(object):&#xa;    ''' Implements a dict-like object, the values of which are lists of&#xa;  objects. The iterator returned from the __iter__ method traverses the lists&#xa;  in order of 1) the sorted list of keys and 2) the order the items were added&#xa;  to the list. Once iteration is started, the DLWSI cannot be modified until&#xa;  the iterator is exhausted or the discard() method is called on the&#xa;  iterator.'''&#xa;&#xa;    def __init__(self):&#xa;        self._store = _defaultdict(list)&#xa;        self._itercount = 0&#xa;        self._len = 0&#xa;&#xa;    def __setitem__(self, key, value):&#xa;        '''Add value to the end of the list stored at key'''&#xa;        self._check_iter_ok()&#xa;        self._store[key].append(value)&#xa;        self._len += 1&#xa;&#xa;    def __delitem__(self, key):&#xa;        '''Delete the list stored at key.'''&#xa;        self._check_iter_ok()&#xa;        if key in self._store:&#xa;            l = len(self._store[key])&#xa;            del self._store[key]&#xa;            self._len -= l&#xa;&#xa;    def __getitem__(self, key):&#xa;        '''Returns the list stored at key as a tuple.'''&#xa;        if self._store[key]:&#xa;            return tuple(self._store[key])&#xa;        else:&#xa;            raise KeyError(str(key))&#xa;&#xa;    def get(self, key, default=None):&#xa;        '''Returns the list stored at key as a tuple. The default argument&#xa;    specifies the object to return if key does not exist (default None).'''&#xa;        if self._store[key]:&#xa;            return tuple(self._store[key])&#xa;        return default&#xa;&#xa;    def keys(self):&#xa;        '''Returns an unsorted list of keys.'''&#xa;        return self._store.keys()&#xa;&#xa;    def __len__(self):&#xa;        return self._len&#xa;&#xa;    def clear(self):&#xa;        '''Removes all keys and values from the DLWSI.'''&#xa;        self._check_iter_ok()&#xa;        self._store = _defaultdict(list)&#xa;        self._len = 0&#xa;&#xa;    def merge(self, dictlist):&#xa;        '''Adds all key value pairs of the passed in DLWSI to this DLWSI. Any&#xa;    keys in this DLWSI that have matching names to keys in the passed in DLWSI&#xa;    will be overwritten.'''&#xa;        self._check_iter_ok()&#xa;        for k, v in dictlist:&#xa;            self.__setitem__(k, v)&#xa;&#xa;    def _check_iter_ok(self):&#xa;        if self._itercount:&#xa;            raise RuntimeError('Attempt to modify while iterating')&#xa;&#xa;    def __iter__(self):&#xa;        '''Returns an iterator over this DLWSI. The iterator proceeds through&#xa;    each list in the order of the sorted keys and returns a key / list item&#xa;    pair for each next call. Thus if a particular key has 3 list items that&#xa;    key will be returned 3 times in succession, once with each list item.&#xa;    The DLWSI cannot be modified while iterating. To allow modification without&#xa;    exhausting the iterator call the discard() method on the iterator.'''&#xa;        if not self._itercount:&#xa;            self._sortedKeys = sorted(self._store.keys())&#xa;        self._itercount += 1&#xa;        return self._ObjIter(self)&#xa;&#xa;    class _ObjIter(object):&#xa;&#xa;        def __init__(self, objStore):&#xa;            self._ostore = objStore&#xa;            self._dictindex = 0&#xa;            self._listindex = -1&#xa;            self._notexhausted = True&#xa;&#xa;        def next(self):&#xa;            if self._notexhausted and self._has_next():&#xa;                self._advance_index()&#xa;                return self._get_current_key_val_tuple()&#xa;            else:&#xa;                self._dec_iter_count()&#xa;                raise StopIteration&#xa;&#xa;        def discard(self):&#xa;            self._dec_iter_count()&#xa;&#xa;        def _dec_iter_count(self):&#xa;            if self._notexhausted:&#xa;                self._ostore._itercount -= 1&#xa;            self._notexhausted = False&#xa;&#xa;        def _has_next(self):&#xa;            if len(self._ostore._store) == 0:&#xa;                return False&#xa;            dictI = self._dictindex&#xa;            if self._listindex + 1 >= len(self._get_list(&#xa;                                          self._get_sorted_key(dictI))):&#xa;                dictI += 1&#xa;            return dictI < len(self._ostore._sortedKeys)&#xa;&#xa;        def _advance_index(self):&#xa;            if self._listindex + 1 >= len(self._get_list(self._get_sorted_key(&#xa;                                                         self._dictindex))):&#xa;                self._dictindex += 1&#xa;                self._listindex = 0&#xa;            else:&#xa;                self._listindex += 1&#xa;&#xa;        def _get_current_key_val_tuple(self):&#xa;            key = self._get_sorted_key(self._dictindex)&#xa;            return key, self._get_list(key)[self._listindex]&#xa;&#xa;        def _get_sorted_key(self, index):&#xa;            return self._ostore._sortedKeys[index]&#xa;&#xa;        def _get_list(self, key):&#xa;            return self._ostore._store[key]&#xa;&#xa;        def __next__(self):&#xa;            return self.next()&#xa;"
952302|"# Copyright 2010 Benjamin Dumke&#xa;# &#xa;# This file is part of Unicornify&#xa;# &#xa;# Unicornify is free software: you can redistribute it and/or modify&#xa;# it under the terms of the GNU Affero General Public License as published by&#xa;# the Free Software Foundation, either version 3 of the License, or&#xa;# (at your option) any later version.&#xa;# &#xa;# Unicornify is distributed in the hope that it will be useful,&#xa;# but WITHOUT ANY WARRANTY; without even the implied warranty of&#xa;# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&#xa;# GNU General Public License for more details.&#xa;# &#xa;# You should have received a copy of the NU Affero General Public License&#xa;# along with Unicornify; see the file COPYING. If not, see&#xa;# <http://www.gnu.org/licenses/>.&#xa;    &#xa;from math import sin, cos, pi, sqrt&#xa;import functools&#xa;from graphics import hls_to_rgb&#xa;&#xa;class Data(object):&#xa;    def __getattribute__(self, attr):&#xa;        try:&#xa;            return super(Data, self).__getattribute__(attr)&#xa;        except AttributeError:&#xa;            if attr in self._data:&#xa;                return self._data[attr]&#xa;            elif attr.endswith(""_col""):&#xa;                part = attr[:-4]&#xa;                func = lambda lightness: hls_to_rgb(self._data[part + ""_hue""], lightness, self._data[part + ""_sat""])&#xa;                self._data[attr] = func&#xa;                return func&#xa;            else:&#xa;                raise KeyError(""Unknown parameter %s"" % attr)&#xa;        &#xa;    def __setattr__(self, attr, value):&#xa;        if attr == ""_data"":&#xa;            super(Data, self).__setattr__(attr, value)&#xa;        elif attr in self._data:&#xa;            self._data[attr] = value&#xa;        else:&#xa;            raise KeyError(""Unknown parameter %s"" % attr)&#xa;&#xa;&#xa;class Rect(object):&#xa;    def __init__(self, left, top, right, bottom):&#xa;        self.coords = left, top, right, bottom&#xa;        self.left = left&#xa;        self.right = right&#xa;        self.top = top&#xa;        self.bottom = bottom&#xa;        &#xa;    def __add__(self, other):&#xa;        if other is None:&#xa;            return self&#xa;        zipped = zip(self.coords, other.coords)&#xa;        lt = map(min, zipped[:2])&#xa;        rb = map(max, zipped[2:])&#xa;        return Rect(*(lt + rb))&#xa;&#xa;    def __radd__(self, other):&#xa;        return self + other&#xa;        &#xa;    def intersects(self, other):&#xa;        hori = other.left <= self.left <= other.right or other.left <= self.right <= other.right or (self.left <= other.left and self.right >= other.right)&#xa;        vert = other.top <= self.top <= other.bottom or other.top <= self.bottom <= other.bottom or (self.top <= other.top and self.bottom >= other.bottom)&#xa;        return hori and vert&#xa;&#xa;class WorldView(object):&#xa;    """"""Note that projecting does not depend on shift, hence unlike&#xa;       the other parameters, shift may be changed without re-projecting.""""""&#xa;    def __init__(self, angle_y, angle_x, rotation_center, shift):&#xa;        self.angle_y = angle_y&#xa;        self.angle_x = angle_x&#xa;        self.rotation_center = rotation_center&#xa;        self.shift = shift&#xa;&#xa;class Ball(object):&#xa;    def __init__(self, center, radius, color):&#xa;        self.center = tuple(map(float, center))&#xa;        self.radius = float(radius)&#xa;        self.color = color&#xa;        &#xa;        self.projection = None&#xa;&#xa;    def project(self, worldview):&#xa;        rad_y = worldview.angle_y * pi / 180&#xa;        rad_x = worldview.angle_x * pi / 180&#xa;        x1, y1, z1 = (self.center[i] - worldview.rotation_center[i] for i in xrange(3))&#xa;        x2 = x1 * cos(rad_y) - z1 * sin(rad_y)&#xa;        y2 = y1&#xa;        z2 = x1 * sin(rad_y) + z1 * cos(rad_y)&#xa;        x3 = x2&#xa;        y3 = y2 * cos(rad_x) - z2 * sin(rad_x)&#xa;        z3 = y2 * sin(rad_x) + z2 * cos(rad_x)&#xa;        self.projection = tuple(c[0] + c[1] for c in zip((x3, y3, z3), worldview.rotation_center))&#xa;&#xa;    def rotate(self, angle, other, axis = 2):&#xa;        """"""Rotate this ball around the ball ""other"", leaving the ""axis"" coordinate&#xa;           as is. (default z, i.e. rotation is in the x-y-plane)""""""&#xa;        rad = angle * pi / 180&#xa;        swap = [(1, 2, 0), (0, 2, 1), (0, 1, 2)][axis]&#xa;        reverse = [(2, 0, 1), (0, 2, 1), (0, 1, 2)][axis]&#xa;        # the letters are the correct ones for the default case axis = 2&#xa;        x1, y1, z1 = (self.center[i] - other.center[i] for i in swap)&#xa;        x2 = x1 * cos(rad) - y1 * sin(rad)&#xa;        y2 = x1 * sin(rad) + y1 * cos(rad)&#xa;        z2 = z1&#xa;        self.center = tuple((x2, y2, z2)[reverse[i]] + other.center[i] for i in xrange(3))&#xa;           &#xa;    def set_distance(self, distance, other):&#xa;        """"""Move this ball to have the given distance to ""other"" while not changing the&#xa;           direction. This is the distance of the ball centers.""""""&#xa;        span = tuple(c[0] - c[1] for c in zip(self.center, other.center))&#xa;        stretch = distance / sqrt(sum(c * c for c in span))&#xa;        self.center = tuple(c[0] + stretch * c[1] for c in zip(other.center, span))&#xa;        &#xa;    def set_gap(self, gap, other):&#xa;        self.set_distance(gap + self.radius + other.radius, other)&#xa;        &#xa;    def move_to_sphere(self, other):&#xa;        self.set_distance(other.radius, other)&#xa;            &#xa;    def twoD(self):&#xa;        return self.projection[:2]            &#xa;            &#xa;    def draw(self, image, worldview):&#xa;        x, y = map(sum, zip(worldview.shift, self.twoD()))&#xa;        r = self.radius&#xa;        image.circle((x, y), r, self.color)&#xa;        &#xa;    def __sub__(self, other):&#xa;        tup1 = self.center&#xa;        if isinstance(other, Ball):&#xa;            tup2 = other.center&#xa;        else:&#xa;            tup2 = other&#xa;        return tuple(c[0] - c[1] for c in zip(tup1, tup2))&#xa;        &#xa;    def bounding(self):&#xa;        x, y, r = self.twoD() + (self.radius, )&#xa;        return Rect(x - r, y - r, x + r, y + r)&#xa;        &#xa;    def balls(self):&#xa;        yield self&#xa;        &#xa;    def sort(self, worldview):&#xa;        return&#xa;        &#xa;def identity(x):&#xa;    return x&#xa;&#xa;class Bone(object):&#xa;    def __init__(self, ball1, ball2):&#xa;        self._balls = [ball1, ball2]&#xa;        &#xa;    def draw(self, image, worldview, xfunc = identity, yfunc = identity):&#xa;        """"""xfunc and / or yfunc should map [0,1] -> [0,1] if the parameter ""step""&#xa;           should not be applied linearly to the coordinates. Note that these x and&#xa;           y are screen, i.e. 2D, coordinates. This is currently used to make the hair&#xa;           wavy.""""""&#xa;&#xa;        calc = lambda c1, c2, factor: c1 + (c2 - c1) * factor&#xa;        x1, y1 = map(sum, zip(self[0].twoD(), worldview.shift))&#xa;        x2, y2 = map(sum, zip(self[1].twoD(), worldview.shift))&#xa;        steps = max(*map(abs, (x2-x1, y2-y1)))&#xa;        # The centers might be very close, but the radii my be more apart,&#xa;        # hence the following step. without it, the eye/iris gradient sometimes&#xa;        # only has two or three steps&#xa;        steps = max(steps, abs(self[0].radius - self[1].radius))&#xa;        colors = zip(self[0].color, self[1].color)&#xa;&#xa;        # the old way is faster for smaller images, the new one for larger ones.&#xa;        # This table shows test measurings. Note that the size is the final size,&#xa;        # i.e. half the drawing size. O means the old one is faster, N the new one.&#xa;        #&#xa;        # zoom    test hash         32  64  128 256 512&#xa;        # ----------------------------------------------&#xa;        # close   21b96dcc68138     O   N   N   N!  N!&#xa;        # medium  18011847b11145af  O!  O   =   N   N&#xa;        # far     1895854ba5a70     O!  O!  O   =   N&#xa;&#xa;        if xfunc is identity and yfunc is identity:&#xa;            if steps > 80: # based on tests, this number seems roughly to be the break-even point&#xa;                image.connect_circles((x1, y1), self[0].radius, self[0].color, (x2, y2), self[1].radius, self[1].color)&#xa;                return &#xa;&#xa;        for step in xrange(int(steps + 1)):&#xa;            factor = float(step) / steps&#xa;            color = tuple(map(int, (calc(c[0], c[1], factor) for c in colors)))&#xa;            x, y, r = calc(x1, x2, xfunc(factor)), calc(y1, y2, yfunc(factor)), calc(self[0].radius, self[1].radius, factor)&#xa;            image.circle((x, y), r, color)&#xa;&#xa;    def __getitem__(self, index):&#xa;        return self._balls[index]&#xa;        &#xa;    def balls(self):&#xa;        return iter(self._balls)&#xa;        &#xa;    def project(self, worldview):&#xa;        for ball in self._balls:&#xa;            ball.project(worldview)&#xa;            &#xa;    def sort(self, worldview):&#xa;        self._balls.sort(key = lambda ball: ball.projection[2], reverse = True)&#xa;        &#xa;    def span(self):&#xa;        return self[1] - self[0]&#xa;        &#xa;    def bounding(self):&#xa;        return self[0].bounding() + self[1].bounding()&#xa;&#xa;def reverse(func):&#xa;    def result(v):&#xa;        return 1 - func(1 - v)&#xa;    return result&#xa;&#xa;class NonLinBone(Bone):        &#xa;    def __init__(self, ball1, ball2, xfunc = identity, yfunc = identity):&#xa;        self._balls = [ball1, ball2]&#xa;        self._xfunc = xfunc&#xa;        self._yfunc = yfunc&#xa;        &#xa;    def draw(self, image, worldview):&#xa;        super(NonLinBone, self).draw(image, worldview, self._xfunc, self._yfunc)&#xa;&#xa;    def sort(self, worldview):&#xa;        previous = self._balls[:]&#xa;        super(NonLinBone, self).sort(worldview)&#xa;        if previous != self._balls:&#xa;            self._xfunc = reverse(self._xfunc)&#xa;            self._yfunc = reverse(self._yfunc)&#xa;&#xa;def compare(worldview, first, second):&#xa;    """"""Compares two objects (balls or bones) to determine which one is behind the other.&#xa;       Note that although the worldview must be given, the objects still must&#xa;       have already been projected.""""""&#xa;       &#xa;    # FIXME: currently, this should be okay most of the time, because the&#xa;    # only subfigure used so far is unicorn.hairs. &#xa;    if isinstance(first, Figure):&#xa;        return 1&#xa;    elif isinstance(second, Figure):&#xa;        return -1&#xa;    &#xa;       &#xa;    if isinstance(first, Ball) and isinstance(second, Ball):&#xa;        return cmp(first.projection[2], second.projection[2])&#xa;    elif isinstance(first, Bone) and isinstance(second, Ball):&#xa;        # see Definition 1.1 at http://en.wikibooks.org/wiki/Linear_Algebra/Orthogonal_Projection_Into_a_Line&#xa;        span = first.span()&#xa;        lensquare = float(sum(c**2 for c in span))&#xa;        factor = sum(c[0] * c[1] for c in zip(second - first[0], span)) / lensquare&#xa;        if factor < 0:&#xa;            return compare(worldview, first[0], second)&#xa;        elif factor > 1:&#xa;            return compare(worldview, first[1], second)&#xa;        else: # the projection is within the bone&#xa;            proj = tuple(c[0] * factor + c[1] for c in zip(span, first[0].center))&#xa;            proj_ball = Ball(proj, 1, None)&#xa;            proj_ball.project(worldview)&#xa;            return compare(worldview, proj_ball, second)&#xa;    elif isinstance(first, Ball) and isinstance(second, Bone):&#xa;        return -compare(worldview, second, first)&#xa;    elif isinstance(first, Bone) and isinstance(second, Bone):&#xa;        set1 = set(first.balls())&#xa;        set2 = set(second.balls())&#xa;        if set1 & set2: # they share a ball&#xa;            # which bone is longer?&#xa;            l1, l2 = (sum((b[1].projection[i] - b[0].projection[i])**2 for i in (0, 1, 2)) for b in (first, second))&#xa;            if l1 > l2:&#xa;                return compare(worldview, first, (set2 - set1).pop())&#xa;            else:&#xa;                return compare(worldview, (set1 - set2).pop(), second)&#xa;        else:&#xa;            # check for the simple case: is there a pair of balls (one from&#xa;            # first, one from second that we can compare instead?&#xa;            for ball1 in first.balls():&#xa;                for ball2 in second.balls():&#xa;                    if ball1.bounding().intersects(ball2.bounding()):&#xa;                        result = compare(worldview, ball1, ball2)&#xa;                        if result != 0:&#xa;                            return result&#xa;        &#xa;            # find the point where the bones intersect *on the screen*. t1&#xa;            # and t2 are the parameters such that, say, ball1_x + t1 * (ball2_x-ball1_x)&#xa;            # is the x-coordinate refereced by t1. t_ < 0 or t_ > 1 means&#xa;            # that the ""intersection"" isn't on the line itself.&#xa;            &#xa;            s1x, s1y, s1z = first[0].projection&#xa;            d1x, d1y, d1z = (first[1].projection[i] - first[0].projection[i] for i in (0, 1, 2))&#xa;            s2x, s2y, s2z = second[0].projection&#xa;            d2x, d2y, d2z = (second[1].projection[i] - second[0].projection[i] for i in (0, 1, 2))&#xa;            &#xa;            # this number is zero if and only if the lines are parallel&#xa;            # (again, their screen projections -- not neccessarily&#xa;            # parallel in 3d space)&#xa;            denom = d1x * d2y - d2x * d1y&#xa;            &#xa;            if abs(denom) < 1e-4:&#xa;                return 0 #FIXME later?&#xa;                &#xa;            t2 = (d1y * (s2x - s1x) - d1x * (s2y - s1y)) / denom&#xa;            if abs(d1x) > 1e-4:&#xa;                t1 = (s2x + t2 * d2x - s1x) / d1x&#xa;            elif abs(d1y) > 1e-4:&#xa;                t1 = (s2y + t2 * d2y - s1y) / d1y&#xa;            else:&#xa;                return 0 #FIXME later?&#xa;            &#xa;                &#xa;            if t1 < -.5 or t1 > 1.5 or t2 < -1 or t2 > 2:&#xa;                return 0&#xa;                &#xa;                &#xa;            return cmp(s1z + t1 * d1z, s2z + t2 * d2z) #FIXME: zero case?&#xa;    else:&#xa;        raise ValueError(""Can't compare %s and %s"" % (first, second))&#xa;&#xa;def two_combinations(l):&#xa;    """"""itertools.combinations was introduced in Python 2.6; the app engine&#xa;       runs 2.5.""""""&#xa;    for i, first in enumerate(l):&#xa;        for second in l[i+1:]:&#xa;            yield (first, second)&#xa;&#xa;# used in Figure.sort() to determine which thing should be drawn next if&#xa;# it's not possible to fullfill all draw_after constraints&#xa;def evilness(thing):&#xa;    z = thing.projection[2] if isinstance(thing, Ball) else max(b.projection[2] for b in thing.balls())&#xa;    return -z&#xa;&#xa;class Figure(object):&#xa;    def __init__(self):&#xa;        self._things = []&#xa;        &#xa;    def add(self, *things):&#xa;        self._things.extend(things)&#xa;        &#xa;    def project(self, worldview):&#xa;        for thing in self._things:&#xa;            thing.project(worldview)&#xa;            &#xa;    def sort(self, worldview):&#xa;        """"""this assumes that projection has already happened!""""""&#xa;        comp = functools.partial(compare, worldview)&#xa;        &#xa;        # values of this dict are lists of all things that have&#xa;        # to be drawn before the corresponding key&#xa;        draw_after = dict((thing, []) for thing in self._things) &#xa;&#xa;        for first, second in two_combinations(self._things):&#xa;            if second not in draw_after[first] and first not in draw_after[second]:&#xa;                if first.bounding().intersects(second.bounding()):&#xa;                    c = comp(first, second)&#xa;                    if c < 0:&#xa;                        # first is in front of second&#xa;                        draw_after[first].append(second)&#xa;                    elif c > 0:&#xa;                        draw_after[second].append(first)&#xa;        &#xa;        # this is pretty much the algorithm from http://stackoverflow.com/questions/952302/&#xa;        sorted_things = []&#xa;        queue = []&#xa;        for thing, deps in draw_after.items():&#xa;            if not deps:&#xa;                queue.append(thing)&#xa;                del draw_after[thing]&#xa;&#xa;        while draw_after:&#xa;            while queue:&#xa;                popped = queue.pop()&#xa;                sorted_things.append(popped)&#xa;                for thing, deps in draw_after.items():&#xa;                    if popped in deps:&#xa;                        deps.remove(popped)&#xa;                        if not deps:&#xa;                            queue.append(thing)&#xa;                            del draw_after[thing]&#xa;&#xa;            if draw_after:&#xa;                # if the sorting couldn't fullfill all ""draw after"" contraints,&#xa;                # we remove the ball / bone which lies farthest in the back&#xa;                # and try again&#xa;&#xa;                least_evil = min((thing for thing in draw_after.iterkeys()),&#xa;                                 key = evilness&#xa;                                )&#xa;                sorted_things.append(least_evil)&#xa;                del draw_after[least_evil]&#xa;                for thing, deps in draw_after.items():&#xa;                    if least_evil in deps:&#xa;                        deps.remove(least_evil)&#xa;                        if not deps:&#xa;                            queue.append(thing)&#xa;                            del draw_after[thing]&#xa;                &#xa;        self._things = sorted_things            &#xa;&#xa;        for thing in self._things:&#xa;            thing.sort(worldview)&#xa;            &#xa;    def draw(self, image, worldview):&#xa;        viewrect = Rect(*(tuple(-c for c in worldview.shift) + tuple(image.size - c for c in worldview.shift)))&#xa;        for thing in self._things:&#xa;            if thing.bounding().intersects(viewrect):&#xa;                thing.draw(image, worldview)&#xa;&#xa;    def balls(self):&#xa;        for thing in self._things:&#xa;            for ball in thing.balls():&#xa;                yield ball&#xa;&#xa;    def ball_set(self):&#xa;        """"""Returns all balls that are either directly in this figure or in&#xa;           on of its bones. It returns a set; i.e. each ball is returned&#xa;           exactly once.""""""&#xa;        return set(self.balls())&#xa;        &#xa;    def scale(self, factor):&#xa;        for ball in self.ball_set():&#xa;            ball.radius *= factor&#xa;            ball.center = tuple(c * factor for c in ball.center)&#xa;            &#xa;    def bounding(self):&#xa;        return sum((thing.bounding() for thing in self._things), None)&#xa;        &#xa;"
2475750|"# -*- coding: utf-8 -*-&#xa;""""""&#xa;GUI for CogStat.&#xa;""""""&#xa;&#xa;import sys&#xa;import os&#xa;import webbrowser&#xa;import gettext&#xa;import logging&#xa;import traceback&#xa;from urllib2 import urlopen&#xa;from distutils.version import LooseVersion&#xa;&#xa;import cogstat&#xa;import cogstat_dialogs&#xa;import cogstat_config as csc&#xa;csc.versions['cogstat'] = cogstat.__version__&#xa;import cogstat_util as cs_util&#xa;&#xa;from PyQt4 import QtGui&#xa;from PyQt4 import QtCore&#xa;&#xa;cs_util.get_versions()&#xa;&#xa;logging.root.setLevel(logging.INFO)&#xa;&#xa;reload(sys)&#xa;sys.setdefaultencoding(""utf-8"")  # TODO Not sure if this will work correctly for most systems.&#xa;&#xa;t = gettext.translation('cogstat', os.path.dirname(os.path.abspath(__file__))+'/locale/', [csc.language], fallback=True)&#xa;_ = t.ugettext&#xa;&#xa;rtl_lang = True if csc.language in ['he', 'fa', 'ar'] else False&#xa;&#xa;broken_analysis = '<default>'+_('%s Oops, something went wrong, CogStat could not run the analysis. You may want to report it.')&#xa;&#xa;class StatMainWindow(QtGui.QMainWindow):&#xa;    """"""&#xa;    CogStat GUI.&#xa;    """"""&#xa;    def __init__(self):&#xa;        super(StatMainWindow, self).__init__()  # TOD do we need super()?&#xa;        self._init_UI()&#xa;&#xa;        # Check if all required components are installed&#xa;        # TODO Maybe all these checking can be removed&#xa;        missing_required_components, missing_recommended_components = self._check_installed_components()&#xa;        if missing_required_components or missing_recommended_components:&#xa;            QtGui.QMessageBox.critical(self, 'Incomplete installation', u'Install missing component(s): ' + ''.join([x+u', ' for x in missing_required_components+missing_recommended_components])[:-2]+u'.<br><br>'+u'<a href = ""https://github.com/cogstat/cogstat/wiki/Installation"">Visit the installation help page</a> to see how to complete the installation.', QtGui.QMessageBox.Ok)&#xa;            if missing_required_components:&#xa;                sys.exit()&#xa;        &#xa;        self.analysis_results = []&#xa;        # analysis_result stores list of GuiResultPackages.&#xa;        # It will be useful when we can rerun all the previous analysis in the GUI output&#xa;        # At the moment no former results can be manipulated later&#xa;&#xa;        cogstat.output_type = 'gui'  # For some GUI specific formatting&#xa;&#xa;        self.check_for_update()&#xa;&#xa;        # Only for testing&#xa;#        self.open_file('sample_data/example2.csv'); #self.compare_groups()&#xa;#        self.open_file('test/data/test_data.csv')&#xa;#        self.open_clipboard()&#xa;#        self.print_data()&#xa;#        self.explore_variable('X')&#xa;#        self.explore_variable(u'a', freq=False)&#xa;#        self.explore_variable_pair(['G', 'H'])&#xa;#        self.pivot([u'X'], row_names=[], col_names=[], page_names=[u'CONDITION', u'TIME3'], function='N')&#xa;#        self.compare_variables(['X', 'Y'])&#xa;#        self.compare_variables(['A', 'B', 'C1'])&#xa;#        self.compare_variables(['D', 'E', 'F'])&#xa;#        self.compare_variables([u'CONDITION', u'CONDITION2', u'CONDITION3'])&#xa;#        self.compare_groups(['slope'], ['group'],  ['slope_SE'], 25)&#xa;#        self.compare_groups(['A'], ['G', 'H'])&#xa;#        self.compare_groups(['X'], ['W'])&#xa;#        self.save_result_as()&#xa;#        self.save_result_as(filename='pdf_test.pdf')&#xa;&#xa;    def check_for_update(self):&#xa;        """"""Check for update, and if update is available, display a message box with the download link.&#xa;&#xa;        The version number is available in a plain text file, at the appropriate web address.""""""&#xa;        try:&#xa;            latest_version = urlopen('http://kognitiv.elte.hu/cogstat/version').read()&#xa;            if LooseVersion(cogstat.__version__) < LooseVersion(latest_version):&#xa;                QtGui.QMessageBox.about(self, _('Update available'),&#xa;                                        _('New version is available.') + '<br><br>' +&#xa;                                        _('You can download the new version<br>from the <a href = ""%s"">CogStat download page</a>.')%'http://www.cogstat.org/download.html')&#xa;        except:&#xa;            print ""Couldn't check for update""&#xa;&#xa;    def _init_UI(self):&#xa;        self.resize(800, 600)&#xa;        self.setWindowTitle('CogStat')&#xa;        self.setWindowIcon(QtGui.QIcon(os.path.dirname(os.path.abspath(__file__)) + u'/resources/CogStat.ico'))&#xa;&#xa;        if rtl_lang:&#xa;            self.setLayoutDirection(QtCore.Qt.RightToLeft)&#xa;&#xa;        # Menus and commands&#xa;        menu_commands = [  # This list will be used to construct the menus&#xa;                            [_('&Data'),&#xa;                                ['', _('&Open data file')+'...', _('Ctrl+O'), _('Open data file (csv text file)'), 'self.open_file'],&#xa;                                ['', _('&Paste data'), _('Ctrl+V'), _('Paste data from clipboard'), 'self.open_clipboard'],&#xa;                                ['separator'],&#xa;                                # ['', _('&Filter outliers'), _('Ctrl+L'), _('Filter cases based on outliers'), 'self.xxx'],&#xa;                                # ['separator'],&#xa;                                ['', _('&Display data'), _('Ctrl+D'), _('Print data to the output'), 'self.print_data'],&#xa;                                ['', _('Display data &briefly'), _('Ctrl+B'), _('Print beginning of the data to the output'), 'self._print_data_brief'],&#xa;                            ],&#xa;                            [_('&Analysis'),&#xa;                                ['', _('&Explore variable')+'...', _('Ctrl+1'), _('Main properties of variables'), 'self.explore_variable'],&#xa;                                ['', _('Explore relation of variable &pair')+'...', _('Ctrl+2'), _('Properties of variable pairs'), 'self.explore_variable_pair'],&#xa;                                ['separator'],&#xa;                                ['', _('Pivot &table')+'...', 'Ctrl+T', _('Build a pivot table'), 'self.pivot'],&#xa;                                ['separator'],&#xa;                                ['', _('Compare repeated measures va&riables')+'...', 'Ctrl+R', _('Compare variables'), 'self.compare_variables'],&#xa;                                ['', _('Compare &groups')+'...', 'Ctrl+G', _('Compare groups'), 'self.compare_groups'],&#xa;                            ],&#xa;                            [_('&Results'),&#xa;                                ['', _('&Clear results'), _('Del'), _('Delete the output window'), 'self.delete_output'],&#xa;                                ['separator'],&#xa;                                ['', _('Save results'), _('Ctrl+P'), _('Save the output to .pdf format'), 'self.save_result'],&#xa;                                ['', _('Save results as')+'...', _('Shift+Ctrl+P'), _('Save the results'), 'self.save_result_as']&#xa;                            ],&#xa;                            [_('&CogStat'),&#xa;                                ['', _('&Help'), _('F1'), _('Read online documentation'), 'self._open_help_webpage'],&#xa;                                ['', _('&Preferences')+'...', '', _('Set the preferences'), 'self._show_preferences'],&#xa;                                ['', _('Request a &feature'), '', _(""Can't find a feature? Ask for it!""), 'self._open_reqfeat_webpage'],&#xa;                                ['separator'],&#xa;                                ['', _('&Report a problem'), '', _('Fill online form to report a problem'), 'self._open_reportbug_webpage'],&#xa;                                ['', _('&Diagnosis information'), '', _('List the version of the components on your system'), 'self.print_versions'],&#xa;                                ['separator'],&#xa;                                ['', _('&About'), '', _('About CogStat'), 'self._show_about'],&#xa;                                ['separator'],&#xa;                                ['', _('&Exit'), _('Ctrl+Q'), _('Exit CogStat'), 'self.closeEvent']&#xa;                            ]&#xa;                        ]&#xa;        # Enable these commands only when active_data is available&#xa;        self.analysis_commands = [_('&Save data'), _('Save data &as')+'...', _('&Display data'), _('Display data &briefly'),&#xa;                                  _('Pivot &table')+'...', _('&Explore variable')+'...',&#xa;                                  _('Explore relation of variable &pair')+'...', _('Compare repeated measures va&riables')+'...', _('Compare &groups')+'...',&#xa;                                  _('&Compare groups and variables')+'...']&#xa;&#xa;        # Create menus and commands&#xa;        self.menubar = self.menuBar()&#xa;        self.menus = []&#xa;        self.menu_commands = {}&#xa;        for menu in menu_commands:&#xa;            self.menus.append(self.menubar.addMenu(menu[0]))&#xa;            for i in range(1, len(menu)):&#xa;                if menu[i][0] == 'separator':&#xa;                    self.menus[-1].addSeparator()&#xa;                else:&#xa;                    self.menu_commands[menu[i][1]] = QtGui.QAction(QtGui.QIcon(menu[i][0]), menu[i][1], self)&#xa;                    self.menu_commands[menu[i][1]].setShortcut(menu[i][2])&#xa;                    self.menu_commands[menu[i][1]].setStatusTip(menu[i][3])&#xa;                    self.menu_commands[menu[i][1]].triggered.connect(eval(menu[i][4]))&#xa;                    self.menus[-1].addAction(self.menu_commands[menu[i][1]])&#xa;        for menu in self.analysis_commands:&#xa;            try:&#xa;                self.menu_commands[menu].setEnabled(False)&#xa;            except KeyError:&#xa;                pass&#xa;        &#xa;        # Prepare Output pane&#xa;        self.output_pane = QtGui.QTextBrowser()  # QTextBrowser can handle links, QTextEdit cannot&#xa;        self.output_pane.setLineWrapMode (QtGui.QTextEdit.NoWrap)&#xa;        self.output_pane.setText('<br><b>%s</b><br>%s<br>%s<br>%s<br>' %&#xa;                                 (_('Welcome to CogStat!'), _('CogStat makes statistical analysis more simple and efficient.'),&#xa;                                  _('To start working open a data file or paste your data from a spreadsheet.'),&#xa;                                  _('Find more information about CogStat on its <a href = ""https://www.cogstat.org"">webpage</a> or read the <a href=""https://github.com/cogstat/cogstat/wiki/Quick-Start-Tutorial"">quick start tutorial.</a>')))&#xa;        self.welcome_text_on = True  # Used for deleting the welcome text at the first analysis&#xa;        self.output_pane.setReadOnly(True)&#xa;        self.output_pane.setOpenExternalLinks(True)&#xa;        self.output_pane.setStyleSheet(""QTextBrowser { background-color: white; }"")&#xa;            # Some styles use non-white background (e.g. Linux Mint 17 Mate uses gray)&#xa;        # Set default font&#xa;        #print self.output_pane.currentFont().toString()&#xa;        # http://stackoverflow.com/questions/2475750/using-qt-css-to-set-own-q-propertyqfont&#xa;        font = QtGui.QFont()&#xa;        font.setFamily(csc.default_font)&#xa;        font.setPointSizeF(csc.default_font_size)&#xa;        self.output_pane.setFont(font)&#xa;        #print self.output_pane.currentFont().toString()&#xa;&#xa;        self.setCentralWidget(self.output_pane)&#xa;        self.setAcceptDrops(True)&#xa;        self.statusBar().showMessage(_('Ready'))&#xa;&#xa;        self.unsaved_output = False  # Do not want to save the output with the welcome message&#xa;        self.output_filename = ''&#xa;        &#xa;        self.show()&#xa;&#xa;    def _show_data_menus(self, on=True):&#xa;        """"""&#xa;        Enable or disable data handling menus depending on whether data is loaded.&#xa;        &#xa;        parameters:&#xa;        on: True to enable menus&#xa;            False to disable&#xa;            default is True&#xa;        """"""&#xa;        for menu in self.analysis_commands:&#xa;            try:&#xa;                self.menu_commands[menu].setEnabled(on)&#xa;            except:&#xa;                pass&#xa;        &#xa;    def dragEnterEvent(self, event):&#xa;        if event.mimeData().hasFormat(""text/uri-list""):&#xa;            event.accept()&#xa;        elif event.mimeData().hasFormat(""text/plain""):&#xa;            event.accept()&#xa;        else:&#xa;            event.ignore()&#xa;&#xa;    def dropEvent(self, event):&#xa;        if event.mimeData().hasFormat(""text/uri-list""):&#xa;            # print 'Dropped URL: ', event.mimeData().urls()[0].toString()[7:]&#xa;            self.open_file(filename=event.mimeData().urls()[0].toString()[7:])&#xa;        elif event.mimeData().hasFormat(""text/plain""):&#xa;            # print 'Dropped Text: ', event.mimeData().text()&#xa;            self._open_data(data=unicode(event.mimeData().text()))&#xa;        &#xa;    def _check_installed_components(self):&#xa;        """"""&#xa;        Check if all required and recommended components are installed.&#xa;        Return the list of missing components as strings.&#xa;        """"""&#xa;        missing_required_components = []&#xa;        missing_recommended_components = []&#xa;&#xa;        # Required components&#xa;        for module in ['pyqt', 'numpy', 'pandas', 'scipy', 'statsmodels']:&#xa;            if csc.versions[module] is None:&#xa;                missing_required_components.append(module)&#xa;&#xa;        # Recommended components&#xa;        for module in []:  # At the moment it's empty&#xa;            if csc.versions[module] is None:&#xa;                missing_recommended_components.append(module)&#xa;        # Check R only on Linux, since Win doesn't have a working rpy at the moment&#xa;        if sys.platform in ['linux2', 'linux']:&#xa;            for module in ['r', 'rpy2', 'car']:&#xa;                if csc.versions[module] is None:&#xa;                    missing_recommended_components.append(module)&#xa;        &#xa;        if missing_required_components:&#xa;            logging.error('Missing required components: %s' % missing_required_components)&#xa;        if missing_recommended_components:&#xa;            logging.error('Missing recommended components: %s' % missing_recommended_components)&#xa;        &#xa;        return missing_required_components, missing_recommended_components&#xa;&#xa;    def _busy_signal(self, on):&#xa;        """"""&#xa;        Changes the mouse, signalling that the system is busy&#xa;        """"""&#xa;        # http://qt-project.org/doc/qt-4.7/qt.html see CursorShape&#xa;        # http://qt-project.org/doc/qt-4.7/qapplication.html#id-19f00dae-ec43-493e-824c-ef07ce96d4c6&#xa;        if on:&#xa;            QtGui.QApplication.setOverrideCursor(QtGui.QCursor(QtCore.Qt.WaitCursor))&#xa;            #QtGui.QApplication.setOverrideCursor(QtGui.QCursor(QtCore.Qt.BusyCursor))&#xa;        else:&#xa;            while QtGui.QApplication.overrideCursor() is not None:&#xa;                # TODO if for some reason (unhandled exception) the cursor was not set back formerly,&#xa;                # then next time set it back&#xa;                # FIXME exception handling should solve this problem on the long term&#xa;                QtGui.QApplication.restoreOverrideCursor()&#xa;            #QtGui.QApplication.setOverrideCursor(QtGui.QCursor(QtCore.Qt.ArrowCursor))&#xa;        &#xa;    def _print_to_output_pane(self, index=-1):&#xa;        """"""Print a GuiResultPackage to GUI output pane&#xa;        :param index: index of the item in self.analysis_results to be printed&#xa;                      If no index is given, the last item is printed.&#xa;        """"""&#xa;        if self.welcome_text_on:&#xa;            self.output_pane.clear()&#xa;            self.welcome_text_on = False&#xa;        for output in self.analysis_results[index].output:&#xa;            if isinstance(output, basestring):&#xa;                self.output_pane.append(output)&#xa;            elif isinstance(output, QtGui.QImage):&#xa;                self.output_pane.moveCursor(11, 0)  # Moves cursor to the end&#xa;                self.output_pane.textCursor().insertImage(output)&#xa;            elif output is None:&#xa;                pass  # We simply don't do anything with None-s&#xa;            else:&#xa;                logging.error('Unknown output type: %s' % type(output))&#xa;        self.unsaved_output = True&#xa;                        &#xa;    ### Data menu methods ###&#xa;    def open_file(self, filename=''):&#xa;        """"""Open file.&#xa;        :param filename: filename with path&#xa;        """"""&#xa;        if filename in ['', False]:&#xa;            filename = cogstat_dialogs.open_data_file()&#xa;        if filename:&#xa;            self._open_data(unicode(filename))&#xa;&#xa;    def open_clipboard(self):&#xa;        """"""Open data copied to clipboard.""""""&#xa;        clipboard = QtGui.QApplication.clipboard()&#xa;        if clipboard.mimeData().hasFormat(""text/plain""):&#xa;            self._open_data(unicode(clipboard.text(""plain"", QtGui.QClipboard.Clipboard)))&#xa;    &#xa;    def _open_data(self, data):&#xa;        """""" Core of the import process.&#xa;        """"""&#xa;        self._busy_signal(True)&#xa;        try:&#xa;            self.active_data = cogstat.CogStatData(data=data)&#xa;            if self.active_data.import_source == _('Import failed'):&#xa;                QtGui.QMessageBox.warning(self, _('Import error'), _('Data could not be loaded.'), QtGui.QMessageBox.Ok)&#xa;                self._show_data_menus(False)&#xa;            else:&#xa;                self._show_data_menus()&#xa;                self.statusBar().showMessage((_('Data loaded from file: ') if self.active_data.import_source[:9] in ['text file', 'SPSS file'] else _('Data loaded from clipboard: '))&#xa;                                            + _('%s variables and %s cases.') % (len(self.active_data.data_frame.columns),&#xa;                                                                                 len(self.active_data.data_frame.index)))&#xa;                self.print_data(brief=True, display_import_message=True)&#xa;        except:&#xa;            self.analysis_results.append(GuiResultPackage())&#xa;            self.analysis_results[-1].add_command('self._open_data()')  # TODO&#xa;            self.analysis_results[-1].\&#xa;                add_output(cs_util.reformat_output('<default>' +&#xa;                                                   _('Open data. Oops, something went wrong, CogStat could not open the data. You may want to report the issue.')))&#xa;            traceback.print_exc()&#xa;            self._print_to_output_pane()&#xa;        self._busy_signal(False)&#xa;            &#xa;    def print_data(self, brief=False, display_import_message=False):&#xa;        """"""Print the current data to the output.&#xa;        &#xa;        :param brief (bool): print only the first 10 rows&#xa;        :param display_import_message (bool):&#xa;        """"""&#xa;        self.analysis_results.append(GuiResultPackage())&#xa;        self.analysis_results[-1].add_command('self.print_data')  # TODO commands will be used to rerun the analysis&#xa;        self.analysis_results[-1].add_output(self.active_data.print_data(brief=brief))&#xa;        if self.active_data.import_message and display_import_message:&#xa;            self.analysis_results[-1].add_output(cs_util.reformat_output(self.active_data.import_message))&#xa;        self._print_to_output_pane()&#xa;&#xa;    def _print_data_brief(self):&#xa;        self.print_data(brief=True)&#xa;&#xa;    ### Analysis menu methods ###&#xa;&#xa;    def explore_variable(self, var_names=None, freq=True, dist=True, descr=True, norm=True, loc_test=True,&#xa;                         loc_test_value=0):&#xa;        """"""Computes various properties of variables.&#xa;&#xa;        Arguments:&#xa;        var_names (list): variable names&#xa;        freq (bool): compute frequencies (default True)&#xa;        dist (bool): compute distribution (default True)&#xa;        descr (bool): compute descriptive statistics (default True)&#xa;        norm (bool): check normality (default True)&#xa;        loc_test (bool): test location (e.g. t-test) (default True)&#xa;        loc_test_value (numeric): test location against this value (default 0.0)&#xa;        """"""&#xa;        if not var_names:&#xa;            try:&#xa;                self.dial_var_prop&#xa;            except:&#xa;                self.dial_var_prop = cogstat_dialogs.explore_var_dialog(names=self.active_data.data_frame.columns)&#xa;            else:  # TODO is it not necessary anymore? For all dialogs&#xa;                self.dial_var_prop.init_vars(names=self.active_data.data_frame.columns)&#xa;            if self.dial_var_prop.exec_():&#xa;                var_names, freq, loc_test_value = self.dial_var_prop.read_parameters()&#xa;            else:&#xa;                return&#xa;        self._busy_signal(True)&#xa;        try:&#xa;            for var_name in var_names:&#xa;                self.analysis_results.append(GuiResultPackage())&#xa;                self.analysis_results[-1].add_command('self.explore_variable()')  # TODO&#xa;                result = self.active_data.explore_variable(var_name, frequencies=freq, central_value=loc_test_value)&#xa;                self.analysis_results[-1].add_output(result)&#xa;                self._print_to_output_pane()&#xa;        except:&#xa;            self.analysis_results[-1].add_output(cs_util.reformat_output(broken_analysis % _('Explore variable.')))&#xa;            traceback.print_exc()&#xa;            self._print_to_output_pane()&#xa;        self._busy_signal(False)&#xa;&#xa;    def explore_variable_pair(self, var_names=None):&#xa;        """"""Explore variable pairs.&#xa;        &#xa;        Arguments:&#xa;        var_names (list): variable names&#xa;        """"""&#xa;        if not var_names:&#xa;            try:&#xa;                self.dial_var_pair&#xa;            except:&#xa;                self.dial_var_pair = cogstat_dialogs.explore_var_pairs_dialog(names=self.active_data.data_frame.columns)&#xa;            else:&#xa;                self.dial_var_pair.init_vars(names=self.active_data.data_frame.columns)&#xa;            if self.dial_var_pair.exec_():&#xa;                var_names = self.dial_var_pair.read_parameters()&#xa;            else:&#xa;                return&#xa;        self._busy_signal(True)&#xa;        if len(var_names) < 2:  # TODO this check should go to the appropriate dialog&#xa;            self.analysis_results.append(GuiResultPackage())&#xa;            text_result = cs_util.reformat_output('<default> %s %s'%(_('Explore variable pair.'), _(u'At least two variables should be set.')))&#xa;            self.analysis_results[-1].add_output(text_result)&#xa;        else:&#xa;            try:&#xa;                for x in var_names:&#xa;                    pass_diag = False&#xa;                    for y in var_names:&#xa;                        if pass_diag:&#xa;                            self.analysis_results.append(GuiResultPackage())&#xa;                            self.analysis_results[-1].add_command('self.explore_variable_pair')  # TODO&#xa;                            result_list = self.active_data.explore_variable_pair(x, y)&#xa;                            self.analysis_results[-1].add_output(result_list)&#xa;                            self._print_to_output_pane()&#xa;                        if x == y:&#xa;                            pass_diag = True&#xa;            except:&#xa;                self.analysis_results[-1].add_output(cs_util.reformat_output(broken_analysis % _('Explore variable pair.')))&#xa;                traceback.print_exc()&#xa;                self._print_to_output_pane()&#xa;        self._busy_signal(False)&#xa;            &#xa;    def pivot(self, depend_names=None, row_names=[], col_names=[], page_names=[], function='Mean'):&#xa;        """"""Build a pivot table.&#xa;        &#xa;        Arguments:&#xa;        depend_names (str): name of the dependent variable&#xa;        row_names, col_names, page_names (lists of str): name of the independent variables&#xa;        function (str): available functions: N,Sum, Mean, Median, Standard Deviation, Variance (default Mean)&#xa;        """"""&#xa;        if not depend_names:&#xa;            try:&#xa;                self.dial_pivot&#xa;            except:&#xa;                self.dial_pivot = cogstat_dialogs.pivot_dialog(names=self.active_data.data_frame.columns)&#xa;            else:&#xa;                self.dial_pivot.init_vars(names=self.active_data.data_frame.columns)&#xa;            if self.dial_pivot.exec_():&#xa;                row_names, col_names, page_names, depend_names, function = self.dial_pivot.read_parameters()&#xa;            else:&#xa;                return&#xa;        self._busy_signal(True)&#xa;        self.analysis_results.append(GuiResultPackage())&#xa;        if not depend_names or not (row_names or col_names or page_names):  # TODO this check should go to the dialog&#xa;            text_result = cs_util.reformat_output('<default>%s %s'%(_('Pivot table.'), _('The dependent variable and at least one grouping variable should be given.')))&#xa;        else:&#xa;            try:&#xa;                text_result = self.active_data.pivot(depend_names, row_names, col_names, page_names, function)&#xa;            except:&#xa;                text_result = cs_util.reformat_output(broken_analysis % _('Pivot table.'))&#xa;                traceback.print_exc()&#xa;        self.analysis_results[-1].add_output(text_result)&#xa;        self._print_to_output_pane()&#xa;        self._busy_signal(False)&#xa;&#xa;    def compare_variables(self, var_names=None):&#xa;        """"""Compare variables.&#xa;        &#xa;        Arguments:&#xa;        var_names (list): variable names&#xa;        """"""&#xa;        if not var_names:&#xa;            try:&#xa;                self.dial_comp_var&#xa;            except:&#xa;                self.dial_comp_var = cogstat_dialogs.compare_vars_dialog(names=self.active_data.data_frame.columns)&#xa;            else:&#xa;                self.dial_comp_var.init_vars(names=self.active_data.data_frame.columns)&#xa;            if self.dial_comp_var.exec_():&#xa;                var_names = self.dial_comp_var.read_parameters()  # TODO check if settings are appropriate&#xa;            else:&#xa;                return&#xa;        self._busy_signal(True)&#xa;        self.analysis_results.append(GuiResultPackage())&#xa;        self.analysis_results[-1].add_command('self.compare_variables()')  # TODO&#xa;        if len(var_names) < 2:&#xa;            text_result = cs_util.reformat_output('<default>%s %s'%(_('Compare variables.'), _(u'At least two variables should be set.')))&#xa;            self.analysis_results[-1].add_output(text_result)&#xa;        else:&#xa;            try:&#xa;                result_list = self.active_data.compare_variables(var_names)&#xa;                for result in result_list:  # TODO is this a list of lists? Can we remove the loop?&#xa;                    self.analysis_results[-1].add_output(result)&#xa;            except:&#xa;                self.analysis_results[-1].add_output(cs_util.reformat_output(broken_analysis % _('Compare variables.')))&#xa;                traceback.print_exc()&#xa;        self._print_to_output_pane()&#xa;        self._busy_signal(False)&#xa;        &#xa;    def compare_groups(self, var_names=None, groups=None, single_case_slope_SEs=None, single_case_slope_trial_n=None):&#xa;        """"""Compare groups.&#xa;        &#xa;        Arguments:&#xa;        var_names (list): dependent variable names&#xa;        groups (list): grouping variable names&#xa;        """"""&#xa;        if not var_names:&#xa;            try:&#xa;                self.dial_comp_grp&#xa;            except:&#xa;                self.dial_comp_grp = cogstat_dialogs.compare_groups_dialog(names=self.active_data.data_frame.columns)&#xa;            else:&#xa;                self.dial_comp_grp.init_vars(names=self.active_data.data_frame.columns)&#xa;            if self.dial_comp_grp.exec_():&#xa;                var_names, groups, single_case_slope_SEs, single_case_slope_trial_n = self.dial_comp_grp.read_parameters()  # TODO check if settings are appropriate&#xa;            else:&#xa;                return&#xa;        self._busy_signal(True)&#xa;        if not var_names or not groups:&#xa;            self.analysis_results.append(GuiResultPackage())&#xa;            self.analysis_results[-1].add_command('self.compare_groups()')  # TODO&#xa;            text_result = cs_util.reformat_output('<default>%s %s' % (_('Compare groups.'), _(u'Both the dependent and the grouping variables should be set.')))&#xa;            self.analysis_results[-1].add_output(text_result)&#xa;        else:&#xa;            for var_name in var_names:&#xa;                try:&#xa;                    self.analysis_results.append(GuiResultPackage())&#xa;                    self.analysis_results[-1].add_command('self.compare_groups()')  # TODO&#xa;                    result_list = self.active_data.compare_groups(var_name, groups,  single_case_slope_SEs, single_case_slope_trial_n)&#xa;                    self.analysis_results[-1].add_output(result_list)&#xa;                    self._print_to_output_pane()&#xa;                except:&#xa;                    self.analysis_results[-1].add_output(cs_util.reformat_output(broken_analysis % _('Compare groups.')))&#xa;                    traceback.print_exc()&#xa;                    self._print_to_output_pane()&#xa;        self._busy_signal(False)&#xa;&#xa;    ### Result menu methods ###&#xa;    def delete_output(self):&#xa;        reply = QtGui.QMessageBox.question(self, _('Clear output'),&#xa;            _('Are you sure you want to delete the output?'), QtGui.QMessageBox.Yes | &#xa;            QtGui.QMessageBox.No, QtGui.QMessageBox.No)&#xa;        if reply == QtGui.QMessageBox.Yes:&#xa;            self.output_pane.clear()&#xa;            self.analysis_results = []&#xa;            self.unsaved_output = False  # Not necessary to save the empty output&#xa;&#xa;    def save_result(self):&#xa;        """"""Save the output pane to pdf file.""""""&#xa;        if self.output_filename == '':&#xa;            self.save_result_as()&#xa;        else:&#xa;            pdf_printer = QtGui.QPrinter()&#xa;            pdf_printer.setOutputFormat(QtGui.QPrinter.PdfFormat)&#xa;            pdf_printer.setColorMode(QtGui.QPrinter.Color)&#xa;            pdf_printer.setOutputFileName(self.output_filename)&#xa;            self.output_pane.print_(pdf_printer)&#xa;            self.unsaved_output = False&#xa;            &#xa;    def save_result_as(self, filename=None):&#xa;        """"""Save the output pane to pdf file.&#xa;        &#xa;        Arguments:&#xa;        filename (str): name of the file to save to&#xa;        """"""&#xa;        if not filename:&#xa;            filename = cogstat_dialogs.save_output()&#xa;        self.output_filename = filename&#xa;        if filename:&#xa;            # self.output_pane.setLineWrapMode (QtGui.QTextEdit.FixedPixelWidth)  # TODO&#xa;            pdf_printer = QtGui.QPrinter()&#xa;            pdf_printer.setOutputFormat(QtGui.QPrinter.PdfFormat)&#xa;            pdf_printer.setOutputFileName(self.output_filename)&#xa;            self.output_pane.print_(pdf_printer)&#xa;            # self.output_pane.setLineWrapMode (QtGui.QTextEdit.NoWrap)&#xa;            self.unsaved_output = False&#xa;&#xa;    ### Cogstat menu  methods ###&#xa;    def _open_help_webpage(self):&#xa;        webbrowser.open('https://github.com/cogstat/cogstat/wiki')&#xa;        &#xa;    def _show_preferences(self):&#xa;        try:&#xa;            self.dial_pref&#xa;        except:&#xa;            self.dial_pref = cogstat_dialogs.preferences_dialog()&#xa;        self.dial_pref.exec_()&#xa;    &#xa;    def _open_reqfeat_webpage(self):&#xa;        webbrowser.open('https://github.com/cogstat/cogstat/wiki/Suggest-a-new-feature')&#xa;        &#xa;    def _open_reportbug_webpage(self):&#xa;        webbrowser.open('https://github.com/cogstat/cogstat/wiki/Report-a-bug')&#xa;        &#xa;    def _show_about(self):&#xa;        QtGui.QMessageBox.about(self, _('About CogStat ')+csc.versions['cogstat'], u'CogStat '+csc.versions['cogstat']+(u'<br>%s<br><br>Copyright © %s-%s Attila Krajcsi<br><br><a href = ""http://www.cogstat.org"">%s</a>'%(_('Simple automatic data analysis software'), 2012, 2018, _('Visit CogStat website'))))&#xa;&#xa;    def print_versions(self):&#xa;        """"""Print the versions of the software components CogStat uses.""""""&#xa;        # Intentionally not localized.&#xa;        self._busy_signal(True)&#xa;        &#xa;        text_output = cs_util.reformat_output(cs_util.print_versions())&#xa;        &#xa;        self.analysis_results.append(GuiResultPackage())&#xa;        self.analysis_results[-1].add_output(csc.heading_style_begin + _('System components') + csc.heading_style_end)&#xa;        self.analysis_results[-1].add_output(text_output)&#xa;        self._print_to_output_pane()&#xa;        self._busy_signal(False)&#xa;&#xa;    def closeEvent(self, event):&#xa;        # Override the close behavior, otherwise alt+F4 quits unconditionally.&#xa;        # http://stackoverflow.com/questions/1414781/prompt-on-exit-in-pyqt-application&#xa;        &#xa;        # Check if everything is saved&#xa;        tosave = True&#xa;        while self.unsaved_output and tosave:&#xa;            reply = QtGui.QMessageBox.question(self, _('Save output'),&#xa;                _('Output has unsaved results. Do you want to save it?'), QtGui.QMessageBox.Yes | &#xa;                QtGui.QMessageBox.No, QtGui.QMessageBox.Yes)&#xa;            if reply == QtGui.QMessageBox.Yes:&#xa;                self.save_result()&#xa;            else:&#xa;                tosave=False&#xa;&#xa;        """"""&#xa;        reply = QtGui.QMessageBox.question(self, _('Confirm exit'), &#xa;            _('Are you sure you want to exit the program?'), QtGui.QMessageBox.Yes, QtGui.QMessageBox.No)&#xa;        if reply == QtGui.QMessageBox.Yes:&#xa;            QtGui.qApp.quit()&#xa;        else:&#xa;            event.ignore()&#xa;        """"""&#xa;&#xa;# -*- coding: utf-8 -*-&#xa;&#xa;class GuiResultPackage():&#xa;    """""" A class for storing a package of results.&#xa;&#xa;    Result object includes:&#xa;    - self.command: Command to run (python code) - not used yet&#xa;    - self.output:&#xa;        - list of strings (html) or figures (QImages)&#xa;        - the first item is recommended to be the title line&#xa;    """"""&#xa;&#xa;    def __init__(self):&#xa;        self.command = []&#xa;        self.output = []&#xa;&#xa;    def add_command(self, command):&#xa;        self.command.append(command)&#xa;&#xa;    def add_output(self, output):&#xa;        """"""Add output to the self.output&#xa;&#xa;        :param output: item or list of items to add&#xa;        """"""&#xa;        if isinstance(output, list):&#xa;            for outp in output:&#xa;                self.output.append(outp)&#xa;        else:&#xa;            self.output.append(output)&#xa;&#xa;def main():&#xa;    app = QtGui.QApplication(sys.argv)&#xa;    ex = StatMainWindow()&#xa;    sys.exit(app.exec_())"
2801882|"""""""&#xa;This file is part of VDISCOVER.&#xa;&#xa;VDISCOVER is free software: you can redistribute it and/or modify&#xa;it under the terms of the GNU General Public License as published by&#xa;the Free Software Foundation, either version 3 of the License, or&#xa;(at your option) any later version.&#xa;&#xa;VDISCOVER is distributed in the hope that it will be useful,&#xa;but WITHOUT ANY WARRANTY; without even the implied warranty of&#xa;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the&#xa;GNU General Public License for more details.&#xa;&#xa;You should have received a copy of the GNU General Public License&#xa;along with VDISCOVER. If not, see <http://www.gnu.org/licenses/>.&#xa;&#xa;Copyright 2014 by G.Grieco&#xa;""""""&#xa;&#xa;import random&#xa;import gzip&#xa;import sys&#xa;import csv&#xa;import subprocess&#xa;import pickle&#xa;import numpy as np&#xa;import matplotlib as mpl&#xa;&#xa;# hack from https://stackoverflow.com/questions/2801882/generating-a-png-with-matplotlib-when-display-is-undefined to avoid using X&#xa;# mpl.use('Agg')&#xa;import matplotlib.pyplot as plt&#xa;&#xa;from Utils import *&#xa;from Pipeline import *&#xa;&#xa;&#xa;# def Cluster(X, labels)&#xa;""""""&#xa;  assert(len(X_red) == len(labels))&#xa;&#xa;  from sklearn.cluster import MeanShift, estimate_bandwidth&#xa;&#xa;  bandwidth = estimate_bandwidth(X, quantile=0.2)&#xa;  print ""Clustering with bandwidth:"", bandwidth&#xa;&#xa;  af = MeanShift(bandwidth=bandwidth/1).fit(X_red)&#xa;&#xa;  cluster_centers = af.cluster_centers_&#xa;  cluster_labels = af.labels_&#xa;  n_clusters = len(cluster_centers)&#xa;&#xa;  plt.figure()&#xa;&#xa;  for ([x,y],label, cluster_label) in zip(X_red,labels, cluster_labels):&#xa;    x = gauss(0,0.1) + x&#xa;    y = gauss(0,0.1) + y&#xa;    plt.scatter(x, y, c = colors[cluster_label % ncolors])&#xa;    #plt.text(x-0.05, y+0.01, label.split(""/"")[-1])&#xa;&#xa;  for i,[x,y] in enumerate(cluster_centers):&#xa;    plt.plot(x, y, 'o', markerfacecolor=colors[i % ncolors],&#xa;             markeredgecolor='k', markersize=7)&#xa;&#xa;  plt.title('Estimated number of clusters: %d' % n_clusters)&#xa;""""""&#xa;# return zip(labels, cluster_labels)&#xa;&#xa;&#xa;batch_size = 25&#xa;window_size = 32&#xa;maxlen = window_size&#xa;&#xa;embedding_dims = 5&#xa;nb_filters = 50&#xa;filter_length = 3&#xa;hidden_dims = 50&#xa;nb_epoch = 3&#xa;&#xa;&#xa;def ClusterCnn(model_file, train_file, valid_file, ftype, nsamples, outdir):&#xa;&#xa;    f = open(model_file + "".pre"")&#xa;    preprocessor = pickle.load(f)&#xa;&#xa;    import h5py&#xa;    f = h5py.File(model_file + "".wei"")&#xa;&#xa;    layers = []&#xa;    for k in range(f.attrs['nb_layers']):&#xa;        g = f['layer_{}'.format(k)]&#xa;        layers.append([g['param_{}'.format(p)]&#xa;                       for p in range(g.attrs['nb_params'])])&#xa;&#xa;    max_features = len(preprocessor.tokenizer.word_counts)&#xa;&#xa;    print ""Reading and sampling data to train..""&#xa;    train_programs, train_features, train_classes = read_traces(&#xa;        train_file, nsamples, cut=None)&#xa;    train_size = len(train_features)&#xa;&#xa;    #y = train_programs&#xa;    X_train, y_train, labels = preprocessor.preprocess_traces(&#xa;        train_features, y_data=train_classes, labels=train_programs)&#xa;    new_model = make_cluster_cnn(&#xa;        ""test"",&#xa;        max_features,&#xa;        maxlen,&#xa;        embedding_dims,&#xa;        nb_filters,&#xa;        filter_length,&#xa;        hidden_dims,&#xa;        None,&#xa;        weights=layers)&#xa;&#xa;    train_dict = dict()&#xa;    train_dict[ftype] = new_model.predict(X_train)&#xa;&#xa;    model = make_cluster_pipeline_subtraces(ftype)&#xa;    X_red_comp = model.fit_transform(train_dict)&#xa;    explained_var = np.var(X_red_comp, axis=0)&#xa;    print explained_var&#xa;&#xa;    X_red = X_red_comp[:, 0:2]&#xa;    X_red_next = X_red_comp[:, 2:4]&#xa;&#xa;    colors = mpl.colors.cnames.keys()&#xa;    progs = list(set(labels))&#xa;    ncolors = len(colors)&#xa;    size = len(labels)&#xa;    print ""Plotting..""&#xa;&#xa;    for prog, [x, y] in zip(labels, X_red):&#xa;        # for prog,[x,y] in sample(zip(labels, X_red), min(size, 1000)):&#xa;        x = gauss(0, 0.05) + x&#xa;        y = gauss(0, 0.05) + y&#xa;        color = 'r'&#xa;        plt.scatter(x, y, c=color)&#xa;&#xa;    """"""&#xa;  if valid_file is not None:&#xa;    valid_programs, valid_features, valid_classes = read_traces(valid_file, None, cut=None, maxsize=window_size) #None)&#xa;    valid_dict = dict()&#xa;&#xa;    X_valid, _, valid_labels = preprocessor.preprocess_traces(valid_features, y_data=None, labels=valid_programs)&#xa;    valid_dict[ftype] = new_model.predict(X_valid)&#xa;    X_red_valid_comp = model.transform(valid_dict)&#xa;&#xa;    X_red_valid = X_red_valid_comp[:,0:2]&#xa;    X_red_valid_next = X_red_valid_comp[:,2:4]&#xa;&#xa;    for prog,[x,y] in zip(valid_labels, X_red_valid):&#xa;      x = gauss(0,0.05) + x&#xa;      y = gauss(0,0.05) + y&#xa;      plt.scatter(x, y, c='b')&#xa;      plt.text(x, y+0.02, prog.split(""/"")[-1])&#xa;&#xa;  plt.show()&#xa;  """"""&#xa;    plt.savefig(train_file.replace("".gz"", """") + "".png"")&#xa;    print ""Bandwidth estimation..""&#xa;    from sklearn.cluster import MeanShift, estimate_bandwidth&#xa;&#xa;    X_red_sample = X_red[:min(size, 1000)]&#xa;    bandwidth = estimate_bandwidth(X_red_sample, quantile=0.2)&#xa;    print ""Clustering with bandwidth:"", bandwidth&#xa;&#xa;    #X_red = np.vstack((X_red,X_red_valid))&#xa;    #X_red_next = np.vstack((X_red_next,X_red_valid_next))&#xa;    #labels = labels + valid_labels&#xa;&#xa;    print X_red.shape, len(X_red), len(labels)&#xa;    # print valid_labels&#xa;&#xa;    af = MeanShift(bandwidth=bandwidth / 1).fit(X_red)&#xa;&#xa;    cluster_centers = af.cluster_centers_&#xa;    cluster_labels = af.labels_&#xa;    n_clusters = len(cluster_centers)&#xa;&#xa;    plt.figure()&#xa;    for ([x, y], label, cluster_label) in zip(X_red, labels, cluster_labels):&#xa;        # for ([x,y],label, cluster_label) in sample(zip(X_red,labels,&#xa;        # cluster_labels), min(size, 1000)):&#xa;        x = gauss(0, 0.1) + x&#xa;        y = gauss(0, 0.1) + y&#xa;        plt.scatter(x, y, c=colors[cluster_label % ncolors])&#xa;        # print label&#xa;        # if label in valid_labels:&#xa;        #  plt.text(x-0.05, y+0.01, label.split(""/"")[-1])&#xa;&#xa;    for i, [x, y] in enumerate(cluster_centers):&#xa;        plt.plot(x, y, 'o', markerfacecolor=colors[i % ncolors],&#xa;                 markeredgecolor='k', markersize=7)&#xa;&#xa;    """"""&#xa;  #for prog,[x,y] in zip(valid_labels, X_red_valid):&#xa;    #x = gauss(0,0.1) + x&#xa;    #y = gauss(0,0.1) + y&#xa;    #plt.scatter(x, y, c='black')&#xa;    #plt.text(x, y+0.02, prog.split(""/"")[-1])&#xa;&#xa;&#xa;  plt.title('Estimated number of clusters: %d' % n_clusters)&#xa;&#xa;  #plt.savefig(""clusters.png"")&#xa;  plt.show()&#xa;  """"""&#xa;    plt.savefig(train_file.replace("".gz"", """") + "".clusters.png"")&#xa;&#xa;    clustered_traces = zip(labels, cluster_labels)&#xa;    writer = open_csv(train_file.replace("".gz"", """") + "".clusters"")&#xa;    for label, cluster in clustered_traces:&#xa;        writer.writerow([label, cluster])&#xa;&#xa;    """"""&#xa;&#xa;  clusters = dict()&#xa;  for label, cluster in clustered_traces:&#xa;    clusters[cluster] = clusters.get(cluster, []) + [label]&#xa;&#xa;  for cluster, traces in clusters.items():&#xa;    plt.figure()&#xa;    plt.title('Cluster %d' % cluster)&#xa;    #X_clus = []&#xa;&#xa;    #for prog in traces:&#xa;    #  i = labels.index(prog)&#xa;    #  X_clus.append(X_train[i])&#xa;&#xa;    #train_dict = dict()&#xa;    #train_dict[ftype] = X_clus&#xa;&#xa;    #model = make_cluster_pipeline_subtraces(ftype)&#xa;    #X_red = model.fit_transform(train_dict)&#xa;&#xa;    #for [x,y],prog in zip(X_red,traces):&#xa;    for prog in traces:&#xa;&#xa;      i = labels.index(prog)&#xa;      assert(i>=0)&#xa;      [x,y] = X_red_next[i]&#xa;      x = gauss(0,0.1) + x&#xa;      y = gauss(0,0.1) + y&#xa;      plt.scatter(x, y, c='r')&#xa;&#xa;      #if prog in valid_labels:&#xa;      plt.text(x-0.05, y+0.01, prog.split(""/"")[-1])&#xa;&#xa;      #plt.text(x, y+0.02, prog.split(""/"")[-1])&#xa;&#xa;    plt.show()&#xa;    #plt.savefig('cluster-%d.png' % cluster)&#xa;  """"""&#xa;&#xa;    # return clustered_traces&#xa;&#xa;&#xa;def TrainCnn(model_file, train_file, valid_file, ftype, nsamples):&#xa;&#xa;    csvreader = open_csv(train_file)&#xa;&#xa;    train_features = []&#xa;    train_programs = []&#xa;    train_classes = []&#xa;&#xa;    train_programs, train_features, train_classes = read_traces(&#xa;        train_file, nsamples, cut=None)&#xa;    train_size = len(train_features)&#xa;&#xa;    from keras.preprocessing.text import Tokenizer&#xa;&#xa;    tokenizer = Tokenizer(nb_words=None, filters="""", lower=False, split="" "")&#xa;    # print type(train_features[0])&#xa;    tokenizer.fit_on_texts(train_features)&#xa;    max_features = len(tokenizer.word_counts)&#xa;&#xa;    preprocessor = DeepReprPreprocessor(tokenizer, window_size, batch_size)&#xa;    X_train, y_train = preprocessor.preprocess(train_features, 10000)&#xa;    nb_classes = len(preprocessor.classes)&#xa;    print preprocessor.classes&#xa;&#xa;    model = make_cluster_cnn(&#xa;        ""train"",&#xa;        max_features,&#xa;        maxlen,&#xa;        embedding_dims,&#xa;        nb_filters,&#xa;        filter_length,&#xa;        hidden_dims,&#xa;        nb_classes)&#xa;    model.fit(X_train, y_train, validation_split=0.1,&#xa;              batch_size=batch_size, nb_epoch=nb_epoch, show_accuracy=True)&#xa;&#xa;    model.mypreprocessor = preprocessor&#xa;    #model_file = model_file + "".wei""&#xa;    #modelfile = open_model(model_file)&#xa;    print ""Saving model to"", model_file + "".wei""&#xa;    model.save_weights(model_file + "".wei"")&#xa;&#xa;    #model_file = model_file + "".pre""&#xa;    modelfile = open_model(model_file + "".pre"")&#xa;    print ""Saving preprocessor to"", model_file + "".pre""&#xa;    # model.save_weights(model_file)&#xa;    modelfile.write(pickle.dumps(preprocessor, protocol=2))&#xa;&#xa;""""""&#xa;def ClusterDoc2Vec(model_file, train_file, valid_file, ftype, nsamples, param):&#xa;&#xa;  train_programs, train_features, train_classes = read_traces(train_file, nsamples)&#xa;  train_size = len(train_programs)&#xa;&#xa;  print ""using"", train_size,""examples to train.""&#xa;&#xa;  from gensim.models.doc2vec import TaggedDocument&#xa;  from gensim.models import Doc2Vec&#xa;&#xa;  print ""Vectorizing traces..""&#xa;  sentences = []&#xa;&#xa;  for (prog,trace) in zip(train_programs,train_features):&#xa;     sentences.append(TaggedDocument(trace.split("" ""), [prog]))&#xa;&#xa;  model = Doc2Vec(dm=2, min_count=1, window=5, size=100, sample=1e-4, negative=5, workers=8, iter=1)&#xa;  model.build_vocab(sentences)&#xa;&#xa;  for epoch in range(20):&#xa;    #print model&#xa;    model.train(sentences)&#xa;    shuffle(sentences)&#xa;&#xa;  train_dict = dict()&#xa;&#xa;  vec_train_features = []&#xa;  for prog in train_programs:&#xa;    #print prog, model.docvecs[prog]&#xa;    vec_train_features.append(model.docvecs[prog])&#xa;&#xa;  train_dict[ftype] = vec_train_features&#xa;&#xa;  print ""Transforming data and fitting model..""&#xa;  model = make_cluster_pipeline_doc2vec(ftype)&#xa;  X_red = model.fit_transform(train_dict)&#xa;&#xa;  #mpl.rcParams.update({'font.size': 10})&#xa;  plt.figure()&#xa;  colors = 'brgcmykbgrcmykbgrcmykbgrcmyk'&#xa;  ncolors = len(colors)&#xa;&#xa;  for prog,[x,y],cl in zip(train_programs, X_red, train_classes):&#xa;    x = gauss(0,0.1) + x&#xa;    y = gauss(0,0.1) + y&#xa;    try:&#xa;        plt.scatter(x, y, c=colors[int(cl)])&#xa;        plt.text(x, y+0.02, prog.split(""/"")[-1])&#xa;    except ValueError:&#xa;        plt.text(x, y+0.02, cl)&#xa;&#xa;  #plt.show()&#xa;  plt.savefig(train_file.replace("".gz"","""")+"".png"")&#xa;&#xa;  from sklearn.cluster import MeanShift, estimate_bandwidth&#xa;&#xa;  bandwidth = estimate_bandwidth(X_red, quantile=0.2)&#xa;  print ""Clustering with bandwidth:"", bandwidth&#xa;&#xa;  af = MeanShift(bandwidth=bandwidth*param).fit(X_red)&#xa;&#xa;  cluster_centers = af.cluster_centers_&#xa;  labels = af.labels_&#xa;  n_clusters_ = len(cluster_centers)&#xa;&#xa;  plt.close('all')&#xa;  plt.figure(1)&#xa;  plt.clf()&#xa;&#xa;  for ([x,y],label, cluster_label) in zip(X_red,train_programs, labels):&#xa;    x = gauss(0,0.1) + x&#xa;    y = gauss(0,0.1) + y&#xa;    plt.scatter(x, y, c = colors[cluster_label % ncolors])&#xa;&#xa;  for i,[x,y] in enumerate(cluster_centers):&#xa;    plt.plot(x, y, 'o', markerfacecolor=colors[i % ncolors],&#xa;             markeredgecolor='k', markersize=7)&#xa;&#xa;  plt.title('Estimated number of clusters: %d' % n_clusters_)&#xa;  plt.savefig(train_file.replace("".gz"","""")+"".clusters.png"")&#xa;&#xa;  #plt.show()&#xa;&#xa;  clustered_traces = zip(train_programs, labels)&#xa;  writer = write_csv(train_file.replace("".gz"","""")+"".clusters"")&#xa;  for label, cluster in clustered_traces:&#xa;     writer.writerow([label.split(""/"")[-1], cluster])&#xa;&#xa;""""""&#xa;&#xa;&#xa;def ClusterScikit(&#xa;        model_file,&#xa;        train_file,&#xa;        valid_file,&#xa;        ftype,&#xa;        nsamples,&#xa;        vectorizer,&#xa;        reducer,&#xa;        param):&#xa;&#xa;    train_programs, train_features, train_classes = read_traces(&#xa;        train_file, nsamples)&#xa;    train_size = len(train_programs)&#xa;    print ""using"", train_size, ""examples to train.""&#xa;&#xa;    if vectorizer == ""bow"":&#xa;&#xa;        train_dict = dict()&#xa;        train_dict[ftype] = train_features&#xa;        #batch_size = 16&#xa;        #window_size = 20&#xa;&#xa;        print ""Transforming data and fitting model..""&#xa;        model = make_cluster_pipeline_bow(ftype, reducer)&#xa;        X_red = model.fit_transform(train_dict)&#xa;&#xa;    elif vectorizer == ""doc2vec"":&#xa;&#xa;        from gensim.models.doc2vec import TaggedDocument&#xa;        from gensim.models import Doc2Vec&#xa;&#xa;        print ""Vectorizing traces..""&#xa;        sentences = []&#xa;&#xa;        for (prog, trace) in zip(train_programs, train_features):&#xa;            sentences.append(TaggedDocument(trace.split("" ""), [prog]))&#xa;&#xa;        model = Doc2Vec(dm=2, min_count=1, window=5, size=100,&#xa;                        sample=1e-4, negative=5, workers=8, iter=1)&#xa;        model.build_vocab(sentences)&#xa;&#xa;        for epoch in range(20):&#xa;            # print model&#xa;            model.train(sentences)&#xa;            shuffle(sentences)&#xa;&#xa;        train_dict = dict()&#xa;&#xa;        vec_train_features = []&#xa;        for prog in train_programs:&#xa;            # print prog, model.docvecs[prog]&#xa;            vec_train_features.append(model.docvecs[prog])&#xa;&#xa;        train_dict[ftype] = vec_train_features&#xa;&#xa;        print ""Transforming data and fitting model..""&#xa;        model = make_cluster_pipeline_doc2vec(ftype, reducer)&#xa;        X_red = model.fit_transform(train_dict)&#xa;&#xa;    #pl.rcParams.update({'font.size': 10})&#xa;    if isinstance(X_red, list):&#xa;        X_red = np.vstack(X_red)&#xa;        print X_red.shape&#xa;&#xa;    if X_red.shape[1] == 2:&#xa;&#xa;        plt.figure()&#xa;        colors = 'brgcmykbgrcmykbgrcmykbgrcmyk'&#xa;        ncolors = len(colors)&#xa;&#xa;        for prog, [x, y], cl in zip(train_programs, X_red, train_classes):&#xa;            x = gauss(0, 0.1) + x&#xa;            y = gauss(0, 0.1) + y&#xa;            try:&#xa;                plt.scatter(x, y, c=colors[int(cl)])&#xa;                plt.text(x, y + 0.02, prog.split(""/"")[-1])&#xa;            except ValueError:&#xa;                plt.text(x, y + 0.02, cl)&#xa;&#xa;        if valid_file is not None:&#xa;            valid_programs, valid_features, valid_classes = read_traces(&#xa;                valid_file, None)&#xa;            valid_dict = dict()&#xa;            valid_dict[ftype] = valid_features&#xa;&#xa;            X_red = model.transform(valid_dict)&#xa;            for prog, [x, y], cl in zip(valid_programs, X_red, valid_classes):&#xa;                x = gauss(0, 0.1) + x&#xa;                y = gauss(0, 0.1) + y&#xa;                plt.scatter(x, y, c=colors[cl + 1])&#xa;                plt.text(x, y + 0.02, prog.split(""/"")[-1])&#xa;&#xa;        # plt.show()&#xa;        plt.savefig(train_file.replace("".gz"", """") + "".png"")&#xa;&#xa;    from sklearn.cluster import MeanShift, estimate_bandwidth&#xa;&#xa;    bandwidth = estimate_bandwidth(X_red, quantile=0.2)&#xa;    print ""Clustering with bandwidth:"", bandwidth&#xa;&#xa;    af = MeanShift(bandwidth=bandwidth * param).fit(X_red)&#xa;&#xa;    cluster_centers = af.cluster_centers_&#xa;    labels = af.labels_&#xa;    n_clusters_ = len(cluster_centers)&#xa;&#xa;    if X_red.shape[1] == 2:&#xa;&#xa;        plt.close('all')&#xa;        plt.figure(1)&#xa;        plt.clf()&#xa;&#xa;        for ([x, y], label, cluster_label) in zip(&#xa;                X_red, train_programs, labels):&#xa;            x = gauss(0, 0.1) + x&#xa;            y = gauss(0, 0.1) + y&#xa;            plt.scatter(x, y, c=colors[cluster_label % ncolors])&#xa;&#xa;        for i, [x, y] in enumerate(cluster_centers):&#xa;            plt.plot(x, y, 'o', markerfacecolor=colors[i % ncolors],&#xa;                     markeredgecolor='k', markersize=7)&#xa;&#xa;        plt.title('Estimated number of clusters: %d' % n_clusters_)&#xa;        plt.savefig(train_file.replace("".gz"", """") + "".clusters.png"")&#xa;&#xa;    # plt.show()&#xa;&#xa;    clustered_traces = zip(train_programs, labels)&#xa;    writer = write_csv(train_file.replace("".gz"", """") + "".clusters"")&#xa;    for label, cluster in clustered_traces:&#xa;        writer.writerow([label.split(""/"")[-1], cluster])&#xa;"
12322210|"import sys, getpass, os, psutil, time, requests, errno, threading, inspect&#xa;import h2o_args&#xa;import h2o_os_util, h2o_print as h2p&#xa;import h2o_nodes&#xa;from h2o_test import \&#xa;    tmp_dir, tmp_file, flatfile_pathname, spawn_cmd, find_file, verboseprint, \&#xa;    dump_json, log, log_rest, check_sandbox_for_errors&#xa;&#xa;# print ""h2o_objects""&#xa;&#xa;# used to drain stdout on the h2o objects below (before terminating a node)&#xa;def __drain(src, dst):&#xa;    for l in src:&#xa;        if type(dst) == type(0):&#xa;            # got this with random data to parse.. why? it shows up in our stdout?&#xa;            # UnicodeEncodeError: 'ascii' codec can't encode character u'\x86' in position 60:&#xa;            #  ordinal not in range(128)&#xa;            # could we be getting unicode object?&#xa;            try:&#xa;                os.write(dst, l)&#xa;            except:&#xa;                # os.write(dst,""kbn: non-ascii char in the next line?"")&#xa;                os.write(dst,l.encode('utf8'))&#xa;        else:&#xa;            # FIX! this case probably can have the same issue?&#xa;            dst.write(l)&#xa;            dst.flush()&#xa;    src.close()&#xa;    if type(dst) == type(0):&#xa;        os.close(dst)&#xa;&#xa;&#xa;def drain(src, dst):&#xa;    t = threading.Thread(target=__drain, args=(src, dst))&#xa;    t.daemon = True&#xa;    t.start()&#xa;&#xa;#*****************************************************************&#xa;class H2O(object):&#xa;    def __init__(self,&#xa;        use_this_ip_addr=None, port=54321, capture_output=True,&#xa;        force_ip=False, network=None,&#xa;        use_debugger=None, classpath=None,&#xa;        use_hdfs=False, use_maprfs=False,&#xa;        hdfs_version=None, hdfs_name_node=None, hdfs_config=None,&#xa;        aws_credentials=None,&#xa;        use_flatfile=False, java_heap_GB=None, java_heap_MB=None, java_extra_args=None,&#xa;        use_home_for_ice=False, node_id=None, username=None,&#xa;        random_udp_drop=False, force_tcp=False,&#xa;        redirect_import_folder_to_s3_path=None,&#xa;        redirect_import_folder_to_s3n_path=None,&#xa;        disable_h2o_log=False,&#xa;        enable_benchmark_log=False,&#xa;        h2o_remote_buckets_root=None,&#xa;        delete_keys_at_teardown=False,&#xa;        cloud_name=None,&#xa;        disable_assertions=None,&#xa;        sandbox_ignore_errors=False,&#xa;        ):&#xa;&#xa;        if use_hdfs:&#xa;            # see if we can touch a 0xdata machine&#xa;            try:&#xa;                # long timeout in ec2...bad&#xa;                a = requests.get('http://172.16.2.176:80', timeout=1)&#xa;                hdfs_0xdata_visible = True&#xa;            except:&#xa;                hdfs_0xdata_visible = False&#xa;&#xa;            # different defaults, depending on where we're running&#xa;            if hdfs_name_node is None:&#xa;                if hdfs_0xdata_visible:&#xa;                    hdfs_name_node = ""172.16.2.176""&#xa;                else: # ec2&#xa;                    hdfs_name_node = ""10.78.14.235:9000""&#xa;&#xa;            if hdfs_version is None:&#xa;                if hdfs_0xdata_visible:&#xa;                    hdfs_version = ""cdh4""&#xa;                else: # ec2&#xa;                    hdfs_version = ""0.20.2""&#xa;&#xa;        self.redirect_import_folder_to_s3_path = redirect_import_folder_to_s3_path&#xa;        self.redirect_import_folder_to_s3n_path = redirect_import_folder_to_s3n_path&#xa;&#xa;        self.aws_credentials = aws_credentials&#xa;        self.port = port&#xa;        # None is legal for self.h2o_addr.&#xa;        # means we won't give an ip to the jar when we start.&#xa;        # Or we can say use use_this_ip_addr=127.0.0.1, or the known address&#xa;        # if use_this_addr is None, use 127.0.0.1 for urls and json&#xa;        # Command line arg 'ip_from_cmd_line' dominates:&#xa;&#xa;        # ip_from_cmd_line and use_this_ip_addr shouldn't be used for mutli-node&#xa;        if h2o_args.ip_from_cmd_line:&#xa;            self.h2o_addr = h2o_args.ip_from_cmd_line&#xa;        else:&#xa;            self.h2o_addr = use_this_ip_addr&#xa;&#xa;        self.force_ip = force_ip or (self.h2o_addr!=None)&#xa;&#xa;        if self.h2o_addr:&#xa;            self.http_addr = self.h2o_addr&#xa;        else:&#xa;            self.http_addr = h2o_args.python_cmd_ip&#xa;&#xa;        if h2o_args.network_from_cmd_line:&#xa;            self.network = h2o_args.network_from_cmd_line&#xa;        else:&#xa;            self.network = network&#xa;        &#xa;        # command line should always dominate for enabling&#xa;        if h2o_args.debugger: use_debugger = True&#xa;        self.use_debugger = use_debugger&#xa;&#xa;        self.classpath = classpath&#xa;        self.capture_output = capture_output&#xa;&#xa;        self.use_hdfs = use_hdfs&#xa;        self.use_maprfs = use_maprfs&#xa;        self.hdfs_name_node = hdfs_name_node&#xa;        self.hdfs_version = hdfs_version&#xa;        self.hdfs_config = hdfs_config&#xa;&#xa;        self.use_flatfile = use_flatfile&#xa;        self.java_heap_GB = java_heap_GB&#xa;        self.java_heap_MB = java_heap_MB&#xa;        self.java_extra_args = java_extra_args&#xa;&#xa;        self.use_home_for_ice = use_home_for_ice&#xa;        self.node_id = node_id&#xa;&#xa;        if username:&#xa;            self.username = username&#xa;        else:&#xa;            self.username = getpass.getuser()&#xa;&#xa;        # don't want multiple reports from tearDown and tearDownClass&#xa;        # have nodes[0] remember (0 always exists)&#xa;        self.sandbox_error_was_reported = False&#xa;        self.sandbox_ignore_errors = sandbox_ignore_errors&#xa;&#xa;        self.random_udp_drop = random_udp_drop&#xa;        self.force_tcp = force_tcp&#xa;        self.disable_h2o_log = disable_h2o_log&#xa;&#xa;        # this dumps stats from tests, and perf stats while polling to benchmark.log&#xa;        self.enable_benchmark_log = enable_benchmark_log&#xa;        self.h2o_remote_buckets_root = h2o_remote_buckets_root&#xa;        self.delete_keys_at_teardown = delete_keys_at_teardown&#xa;        self.disable_assertions = disable_assertions&#xa;&#xa;        if cloud_name:&#xa;            self.cloud_name = cloud_name&#xa;        else:&#xa;            self.cloud_name = 'pytest-%s-%s' % (getpass.getuser(), os.getpid())&#xa;&#xa;    def __str__(self):&#xa;        return '%s - http://%s:%d/' % (type(self), self.http_addr, self.port)&#xa;&#xa;    def url(self, loc, port=None):&#xa;        # always use the new api port&#xa;        if port is None: port = self.port&#xa;        if loc.startswith('/'):&#xa;            delim = ''&#xa;        else:&#xa;            delim = '/'&#xa;        u = 'http://%s:%d%s%s' % (self.http_addr, port, delim, loc)&#xa;        return u&#xa;&#xa;&#xa;    def do_json_request(self, jsonRequest=None, fullUrl=None, timeout=10, params=None, returnFast=False,&#xa;        cmd='get', extraComment=None, ignoreH2oError=False, noExtraErrorCheck=False, **kwargs):&#xa;        # if url param is used, use it as full url. otherwise crate from the jsonRequest&#xa;        if fullUrl:&#xa;            url = fullUrl&#xa;        else:&#xa;            url = self.url(jsonRequest)&#xa;&#xa;        # remove any params that are 'None'&#xa;        # need to copy dictionary, since can't delete while iterating&#xa;        if params is not None:&#xa;            params2 = params.copy()&#xa;            for k in params2:&#xa;                if params2[k] is None:&#xa;                    del params[k]&#xa;            paramsStr = '?' + '&'.join(['%s=%s' % (k, v) for (k, v) in params.items()])&#xa;        else:&#xa;            paramsStr = ''&#xa;&#xa;        if extraComment:&#xa;            log('Start ' + url + paramsStr, comment=extraComment)&#xa;        else:&#xa;            log('Start ' + url + paramsStr)&#xa;&#xa;        log_rest("""")&#xa;        log_rest(""----------------------------------------------------------------------\n"")&#xa;        if extraComment:&#xa;            log_rest(""# Extra comment info about this request: "" + extraComment)&#xa;        if cmd == 'get':&#xa;            log_rest(""GET"")&#xa;        else:&#xa;            log_rest(""POST"")&#xa;        log_rest(url + paramsStr)&#xa;&#xa;        # file get passed thru kwargs here&#xa;        try:&#xa;            if cmd == 'post':&#xa;                r = requests.post(url, timeout=timeout, params=params, **kwargs)&#xa;            else:&#xa;                r = requests.get(url, timeout=timeout, params=params, **kwargs)&#xa;&#xa;        except Exception, e:&#xa;            # rethrow the exception after we've checked for stack trace from h2o&#xa;            # out of memory errors maybe don't show up right away? so we should wait for h2o&#xa;            # to get it out to h2o stdout. We don't want to rely on cloud teardown to check&#xa;            # because there's no delay, and we don't want to delay all cloud teardowns by waiting.&#xa;            exc_info = sys.exc_info()&#xa;            # use this to ignore the initial connection errors during build cloud when h2o is coming up&#xa;            if not noExtraErrorCheck: &#xa;                h2p.red_print(&#xa;                    ""ERROR: got exception on %s to h2o. \nGoing to check sandbox, then rethrow.."" % (url + paramsStr))&#xa;                time.sleep(2)&#xa;                check_sandbox_for_errors(python_test_name=h2o_args.python_test_name);&#xa;            log_rest("""")&#xa;            log_rest(""EXCEPTION CAUGHT DOING REQUEST: "" + str(e.message))&#xa;            raise exc_info[1], None, exc_info[2]&#xa;&#xa;        log_rest("""")&#xa;        try:&#xa;            if r is None:&#xa;                log_rest(""r is None"")&#xa;            else:&#xa;                log_rest(""HTTP status code: "" + str(r.status_code))&#xa;                if hasattr(r, 'text'):&#xa;                    if r.text is None:&#xa;                        log_rest(""r.text is None"")&#xa;                    else:&#xa;                        log_rest(r.text)&#xa;                else:&#xa;                    log_rest(""r does not have attr text"")&#xa;        except Exception, e:&#xa;            # Paranoid exception catch.  &#xa;            log('WARNING: ignoring unexpected exception on %s' + url + paramsStr)&#xa;            # Ignore logging exceptions in the case that the above error checking isn't sufficient.&#xa;            pass&#xa;&#xa;        # fatal if no response&#xa;        if not r:&#xa;            raise Exception(""Maybe bad url? no r in __do_json_request in %s:"" % inspect.stack()[1][3])&#xa;&#xa;        # this is used to open a browser on results, or to redo the operation in the browser&#xa;        # we don't' have that may urls flying around, so let's keep them all&#xa;        h2o_nodes.json_url_history.append(r.url)&#xa;        # if r.json():&#xa;        #     raise Exception(""Maybe bad url? no r.json in __do_json_request in %s:"" % inspect.stack()[1][3])&#xa;&#xa;        rjson = None&#xa;        if returnFast:&#xa;            return&#xa;        try:&#xa;            rjson = r.json()&#xa;        except:&#xa;            print dump_json(r.text)&#xa;            if not isinstance(r, (list, dict)):&#xa;                raise Exception(""h2o json responses should always be lists or dicts, see previous for text"")&#xa;&#xa;            raise Exception(""Could not decode any json from the request."")&#xa;&#xa;        # TODO: we should really only look in the response object.  This check&#xa;        # prevents us from having a field called ""error"" (e.g., for a scoring result).&#xa;        for e in ['error', 'Error', 'errors', 'Errors']:&#xa;            # error can be null (python None). This happens in exec2&#xa;            if e in rjson and rjson[e]:&#xa;                print ""rjson:"", dump_json(rjson)&#xa;                emsg = 'rjson %s in %s: %s' % (e, inspect.stack()[1][3], rjson[e])&#xa;                if ignoreH2oError:&#xa;                    # well, we print it..so not totally ignore. test can look at rjson returned&#xa;                    print emsg&#xa;                else:&#xa;                    print emsg&#xa;                    raise Exception(emsg)&#xa;&#xa;        for w in ['warning', 'Warning', 'warnings', 'Warnings']:&#xa;            # warning can be null (python None).&#xa;            if w in rjson and rjson[w]:&#xa;                verboseprint(dump_json(rjson))&#xa;                print 'rjson %s in %s: %s' % (w, inspect.stack()[1][3], rjson[w])&#xa;&#xa;        return rjson&#xa;&#xa;&#xa;&#xa;    def stabilize(self, test_func, error, timeoutSecs=10, retryDelaySecs=0.5):&#xa;        '''Repeatedly test a function waiting for it to return True.&#xa;&#xa;        Arguments:&#xa;        test_func      -- A function that will be run repeatedly&#xa;        error          -- A function that will be run to produce an error message&#xa;                          it will be called with (node, timeTakenSecs, numberOfRetries)&#xa;                    OR&#xa;                       -- A string that will be interpolated with a dictionary of&#xa;                          { 'timeTakenSecs', 'numberOfRetries' }&#xa;        timeoutSecs    -- How long in seconds to keep trying before declaring a failure&#xa;        retryDelaySecs -- How long to wait between retry attempts&#xa;        '''&#xa;        start = time.time()&#xa;        numberOfRetries = 0&#xa;        while time.time() - start < timeoutSecs:&#xa;            if test_func(self, tries=numberOfRetries, timeoutSecs=timeoutSecs):&#xa;                break&#xa;            time.sleep(retryDelaySecs)&#xa;            numberOfRetries += 1&#xa;            # hey, check the sandbox if we've been waiting a long time...rather than wait for timeout&#xa;            # to find the badness?. can check_sandbox_for_errors at any time&#xa;            if ((numberOfRetries % 50) == 0):&#xa;                check_sandbox_for_errors(python_test_name=h2o_args.python_test_name)&#xa;&#xa;        else:&#xa;            timeTakenSecs = time.time() - start&#xa;            if isinstance(error, type('')):&#xa;                raise Exception('%s failed after %.2f seconds having retried %d times' % (&#xa;                    error, timeTakenSecs, numberOfRetries))&#xa;            else:&#xa;                msg = error(self, timeTakenSecs, numberOfRetries)&#xa;                raise Exception(msg)&#xa;&#xa;    def wait_for_node_to_accept_connections(self, nodeList, timeoutSecs=15, noExtraErrorCheck=False):&#xa;        verboseprint(""wait_for_node_to_accept_connections"")&#xa;&#xa;        def test(n, tries=None, timeoutSecs=timeoutSecs):&#xa;            try:&#xa;                n.get_cloud(noExtraErrorCheck=noExtraErrorCheck, timeoutSecs=timeoutSecs)&#xa;                return True&#xa;            except requests.ConnectionError, e:&#xa;                # Now using: requests 1.1.0 (easy_install --upgrade requests) 2/5/13&#xa;                # Now: assume all requests.ConnectionErrors are H2O legal connection errors.&#xa;                # Have trouble finding where the errno is, fine to assume all are good ones.&#xa;                # Timeout check will kick in if continued H2O badness.&#xa;                return False&#xa;&#xa;        # get their http addr to represent the nodes&#xa;        expectedCloudStr = "","".join([str(n) for n in nodeList])&#xa;        self.stabilize(test, error=('waiting for initial connection: Expected cloud %s' % expectedCloudStr),&#xa;            timeoutSecs=timeoutSecs, # with cold cache's this can be quite slow&#xa;            retryDelaySecs=0.1) # but normally it is very fast&#xa;&#xa;    def sandbox_error_report(self, done=None):&#xa;        # not clearable..just or in new value&#xa;        if done:&#xa;            self.sandbox_error_was_reported = True&#xa;        return (self.sandbox_error_was_reported)&#xa;&#xa;    def get_args(self):&#xa;        args = ['java']&#xa;&#xa;        # I guess it doesn't matter if we use flatfile for both now&#xa;        # defaults to not specifying&#xa;        # FIX! we need to check that it's not outside the limits of the dram of the machine it's running on?&#xa;        if self.java_heap_GB is not None:&#xa;            if not (1 <= self.java_heap_GB <= 256):&#xa;                raise Exception('java_heap_GB <1 or >256  (GB): %s' % (self.java_heap_GB))&#xa;            args += ['-Xms%dG' % self.java_heap_GB]&#xa;            args += ['-Xmx%dG' % self.java_heap_GB]&#xa;&#xa;        if self.java_heap_MB is not None:&#xa;            if not (1 <= self.java_heap_MB <= 256000):&#xa;                raise Exception('java_heap_MB <1 or >256000  (MB): %s' % (self.java_heap_MB))&#xa;            args += ['-Xms%dm' % self.java_heap_MB]&#xa;            args += ['-Xmx%dm' % self.java_heap_MB]&#xa;&#xa;        if self.java_extra_args is not None:&#xa;            args += ['%s' % self.java_extra_args]&#xa;&#xa;        if self.use_debugger:&#xa;            # currently hardwire the base port for debugger to 8000&#xa;            # increment by one for every node we add&#xa;            # sence this order is different than h2o cluster order, print out the ip and port for the user&#xa;            # we could save debugger_port state per node, but not really necessary (but would be more consistent)&#xa;            debuggerBasePort = 8000&#xa;            if self.node_id is None:&#xa;                debuggerPort = debuggerBasePort&#xa;            else:&#xa;                debuggerPort = debuggerBasePort + self.node_id&#xa;&#xa;            if self.http_addr:&#xa;                a = self.http_addr&#xa;            else:&#xa;                a = ""localhost""&#xa;&#xa;            if self.port:&#xa;                b = str(self.port)&#xa;            else:&#xa;                b = ""h2o determined""&#xa;&#xa;            # I guess we always specify port?&#xa;            print ""You can attach debugger at port %s for jvm at %s:%s"" % (debuggerPort, a, b)&#xa;            args += ['-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=%s' % debuggerPort]&#xa;&#xa;        if self.disable_assertions:&#xa;            print ""WARNING: h2o is running with assertions disabled""&#xa;        else:&#xa;            args += [""-ea""]&#xa;            &#xa;&#xa;        if self.use_maprfs:&#xa;            args += [""-Djava.library.path=/opt/mapr/lib""]&#xa;&#xa;        if self.classpath:&#xa;            entries = [find_file('build/classes'), find_file('lib/javassist.jar')]&#xa;            entries += glob.glob(find_file('lib') + '/*/*.jar')&#xa;            entries += glob.glob(find_file('lib') + '/*/*/*.jar')&#xa;            args += ['-classpath', os.pathsep.join(entries), 'water.Boot']&#xa;        else:&#xa;            args += [""-jar"", self.get_h2o_jar()]&#xa;&#xa;        if 1==1:&#xa;            if self.hdfs_config:&#xa;                args += [&#xa;                    '-hdfs_config=' + self.hdfs_config&#xa;                ]&#xa;&#xa;        if h2o_args.beta_features:&#xa;            args += [""-beta""]&#xa;&#xa;        if self.network:&#xa;            args += [""-network="" + self.network]&#xa;&#xa;        # H2O should figure it out, if not specified&#xa;        # DON""T EVER USE on multi-machine...h2o should always get it right, to be able to run on hadoop &#xa;        # where it's not told&#xa;        # new 10/22/14. Allow forcing the ip when we do remote, for networks with bridges, where&#xa;        # h2o can't self identify (does -network work?)&#xa;        if self.force_ip and self.h2o_addr: # should always have an addr if force_ip...but..&#xa;            args += [&#xa;                '--ip=%s' % self.h2o_addr,&#xa;            ]&#xa;&#xa;        # Need to specify port, since there can be multiple ports for an ip in the flatfile&#xa;        if self.port is not None:&#xa;            args += [&#xa;                ""--port=%d"" % self.port,&#xa;            ]&#xa;&#xa;        if self.use_flatfile:&#xa;            args += [&#xa;                '--flatfile=' + self.flatfile,&#xa;            ]&#xa;&#xa;        args += [&#xa;            '--ice_root=%s' % self.get_ice_dir(),&#xa;            # if I have multiple jenkins projects doing different h2o clouds, I need&#xa;            # I need different ports and different cloud name.&#xa;            # does different cloud name prevent them from joining up&#xa;            # (even if same multicast ports?)&#xa;            # I suppose I can force a base address. or run on another machine?&#xa;        ]&#xa;        args += [&#xa;            '--name=' + self.cloud_name&#xa;        ]&#xa;&#xa;        # ignore the other -hdfs args if the config is used?&#xa;        if 1==0:&#xa;            if self.hdfs_config:&#xa;                args += [&#xa;                    '-hdfs_config=' + self.hdfs_config&#xa;                ]&#xa;&#xa;        if self.use_hdfs:&#xa;            args += [&#xa;                # it's fine if hdfs_name has a "":9000"" port or something too&#xa;                '-hdfs hdfs://' + self.hdfs_name_node,&#xa;                '-hdfs_version=' + self.hdfs_version,&#xa;            ]&#xa;&#xa;        if self.use_maprfs:&#xa;            args += [&#xa;                # 3 slashes?&#xa;                '-hdfs maprfs:///' + self.hdfs_name_node,&#xa;                '-hdfs_version=' + self.hdfs_version,&#xa;            ]&#xa;&#xa;        if self.aws_credentials:&#xa;            args += ['--aws_credentials=' + self.aws_credentials]&#xa;&#xa;        # passed thru build_cloud in test, or global from commandline arg&#xa;        if self.random_udp_drop or h2o_args.random_udp_drop:&#xa;            args += ['--random_udp_drop']&#xa;&#xa;        if self.force_tcp:&#xa;            args += ['--force_tcp']&#xa;&#xa;        if self.disable_h2o_log:&#xa;            args += ['--nolog']&#xa;&#xa;        # disable logging of requests, as some contain ""error"", which fails the test&#xa;        ## FIXED. better escape in check_sandbox_for_errors&#xa;        ## args += ['--no_requests_log']&#xa;        return args&#xa;&#xa;&#xa;#*****************************************************************&#xa;import h2o_methods&#xa;&#xa;class LocalH2O(H2O):&#xa;    '''An H2O instance launched by the python framework on the local host using psutil'''&#xa;&#xa;    def __init__(self, *args, **kwargs):&#xa;        super(LocalH2O, self).__init__(*args, **kwargs)&#xa;        self.rc = None&#xa;        # FIX! no option for local /home/username ..always the sandbox (LOG_DIR)&#xa;        self.ice = tmp_dir('ice.')&#xa;        self.flatfile = flatfile_pathname()&#xa;        # so we can tell if we're remote or local. Apparently used in h2o_import.py&#xa;        self.remoteH2O = False &#xa;&#xa;        h2o_os_util.check_port_group(self.port)&#xa;        h2o_os_util.show_h2o_processes()&#xa;&#xa;        if self.node_id is not None:&#xa;            logPrefix = 'local-h2o-' + str(self.node_id)&#xa;        else:&#xa;            logPrefix = 'local-h2o'&#xa;&#xa;        spawn = spawn_cmd(logPrefix, cmd=self.get_args(), capture_output=self.capture_output)&#xa;        self.ps = spawn[0]&#xa;&#xa;    def get_h2o_jar(self):&#xa;        return find_file('target/h2o.jar')&#xa;&#xa;    def get_flatfile(self):&#xa;        return self.flatfile&#xa;        # return find_file(flatfile_pathname())&#xa;&#xa;    def get_ice_dir(self):&#xa;        return self.ice&#xa;&#xa;    def is_alive(self):&#xa;        verboseprint(""Doing is_alive check for LocalH2O"", self.wait(0))&#xa;        return self.wait(0) is None&#xa;&#xa;    def terminate_self_only(self):&#xa;        def on_terminate(proc):&#xa;            print(""process {} terminated"".format(proc))&#xa;&#xa;        waitingForKill = False&#xa;        try:&#xa;            # we already sent h2o shutdown and waited a second. Don't bother checking if alive still.&#xa;            # send terminate...wait up to 3 secs, then send kill&#xa;            self.ps.terminate()&#xa;            gone, alive = wait_procs(procs=[self.ps], timeout=3, callback=on_terminate)&#xa;            if alive:&#xa;                self.ps.kill()&#xa;            # from http://code.google.com/p/psutil/wiki/Documentation: wait(timeout=None) Wait for process termination &#xa;            # If the process is already terminated does not raise NoSuchProcess exception but just return None immediately. &#xa;            # If timeout is specified and process is still alive raises TimeoutExpired exception. &#xa;            # hmm. maybe we're hitting the timeout&#xa;            waitingForKill = True&#xa;            return self.wait(timeout=3)&#xa;&#xa;        except psutil.NoSuchProcess:&#xa;            return -1&#xa;        except:&#xa;            if waitingForKill:&#xa;                # this means we must have got the exception on the self.wait()&#xa;                # just print a message&#xa;                print ""\nUsed psutil to kill h2o process...but""&#xa;                print ""It didn't die within 2 secs. Maybe will die soon. Maybe not! At: %s"" % self.http_addr&#xa;            else:&#xa;                print ""Unexpected exception in terminate_self_only: ignoring""&#xa;            # hack. &#xa;            # psutil 2.x needs function reference&#xa;            # psutil 1.x needs object reference&#xa;            if hasattr(self.ps.cmdline, '__call__'):&#xa;                pcmdline = self.ps.cmdline()&#xa;            else:&#xa;                pcmdline = self.ps.cmdline&#xa;            print ""process cmdline:"", pcmdline&#xa;            return -1&#xa;&#xa;    def terminate(self):&#xa;        # send a shutdown request first.&#xa;        # since local is used for a lot of buggy new code, also do the ps kill.&#xa;        # try/except inside shutdown_all now&#xa;        # new: moved this out..anyone using this should do h2o.nodes[0].shutdown_all first&#xa;        if 1==0:&#xa;            self.shutdown_all()&#xa;        if self.is_alive():&#xa;            print ""\nShutdown didn't work fast enough for local node? : %s. Will kill though"" % self&#xa;        self.terminate_self_only()&#xa;&#xa;    def wait(self, timeout=0):&#xa;        if self.rc is not None:&#xa;            return self.rc&#xa;        try:&#xa;            self.rc = self.ps.wait(timeout)&#xa;            return self.rc&#xa;        except psutil.TimeoutExpired:&#xa;            return None&#xa;&#xa;    def stack_dump(self):&#xa;        self.ps.send_signal(signal.SIGQUIT)&#xa;&#xa;    # to see all the methods&#xa;    # print dump_json(dir(LocalH2O))&#xa;&#xa;#*****************************************************************&#xa;class RemoteH2O(H2O):&#xa;    '''An H2O instance launched by the python framework on a specified host using openssh'''&#xa;&#xa;    def __init__(self, host, *args, **kwargs):&#xa;        super(RemoteH2O, self).__init__(*args, **kwargs)&#xa;&#xa;        # it gets set True if an address is specified for LocalH2o init. Override.&#xa;        if 'force_ip' in kwargs:&#xa;            self.force_ip = kwargs['force_ip']&#xa;&#xa;        self.remoteH2O = True # so we can tell if we're remote or local&#xa;        self.jar = host.upload_file('target/h2o.jar')&#xa;        # need to copy the flatfile. We don't always use it (depends on h2o args)&#xa;        self.flatfile = host.upload_file(flatfile_pathname())&#xa;        # distribute AWS credentials&#xa;        if self.aws_credentials:&#xa;            self.aws_credentials = host.upload_file(self.aws_credentials)&#xa;&#xa;        if self.hdfs_config:&#xa;            self.hdfs_config = host.upload_file(self.hdfs_config)&#xa;&#xa;        if self.use_home_for_ice:&#xa;            # this will be the username used to ssh to the host&#xa;            self.ice = ""/home/"" + host.username + '/ice.%d.%s' % (self.port, time.time())&#xa;        else:&#xa;            self.ice = '/tmp/ice.%d.%s' % (self.port, time.time())&#xa;&#xa;        self.channel = host.open_channel()&#xa;        ### FIX! TODO...we don't check on remote hosts yet&#xa;&#xa;        # this fires up h2o over there&#xa;        cmd = ' '.join(self.get_args())&#xa;        # UPDATE: somehow java -jar on cygwin target (xp) can't handle /tmp/h2o*jar&#xa;        # because it's a windows executable and expects windows style path names.&#xa;        # but if we cd into /tmp, it can do java -jar h2o*jar.&#xa;        # So just split out the /tmp (pretend we don't know) and the h2o jar file name&#xa;        # Newer windows may not have this problem? Do the ls (this goes into the local stdout&#xa;        # files) so we can see the file is really where we expect.&#xa;        # This hack only works when the dest is /tmp/h2o*jar. It's okay to execute&#xa;        # with pwd = /tmp. If /tmp/ isn't in the jar path, I guess things will be the same as&#xa;        # normal.&#xa;        if 1 == 0: # enable if you want windows remote machines&#xa;            cmdList = [""cd /tmp""] # separate by ;<space> when we join&#xa;            cmdList += [""ls -ltr "" + self.jar]&#xa;            cmdList += [re.sub(""/tmp/"", """", cmd)]&#xa;            self.channel.exec_command(""; "".join(cmdList))&#xa;        else:&#xa;            self.channel.exec_command(cmd)&#xa;&#xa;        if self.capture_output:&#xa;            if self.node_id is not None:&#xa;                logPrefix = 'remote-h2o-' + str(self.node_id)&#xa;            else:&#xa;                logPrefix = 'remote-h2o'&#xa;&#xa;            logPrefix += '-' + host.h2o_addr&#xa;&#xa;            outfd, outpath = tmp_file(logPrefix + '.stdout.', '.log')&#xa;            errfd, errpath = tmp_file(logPrefix + '.stderr.', '.log')&#xa;&#xa;            drain(self.channel.makefile(), outfd)&#xa;            drain(self.channel.makefile_stderr(), errfd)&#xa;            comment = 'Remote on %s, stdout %s, stderr %s' % (&#xa;                self.h2o_addr, os.path.basename(outpath), os.path.basename(errpath))&#xa;        else:&#xa;            drain(self.channel.makefile(), sys.stdout)&#xa;            drain(self.channel.makefile_stderr(), sys.stderr)&#xa;            comment = 'Remote on %s' % self.h2o_addr&#xa;&#xa;        log(cmd, comment=comment)&#xa;&#xa;    def get_h2o_jar(self):&#xa;        return self.jar&#xa;&#xa;    def get_flatfile(self):&#xa;        return self.flatfile&#xa;&#xa;    def get_ice_dir(self):&#xa;        return self.ice&#xa;&#xa;    def is_alive(self):&#xa;        verboseprint(""Doing is_alive check for RemoteH2O"")&#xa;        if self.channel.closed: return False&#xa;        if self.channel.exit_status_ready(): return False&#xa;        try:&#xa;            self.get_cloud(noExtraErrorCheck=True)&#xa;            return True&#xa;        except:&#xa;            return False&#xa;&#xa;    def terminate_self_only(self):&#xa;        self.channel.close()&#xa;&#xa;        # Don't check afterwards. api watchdog in h2o might complain&#xa;        if 1==0:&#xa;            time.sleep(1) # a little delay needed?&#xa;            # kbn: it should be dead now? want to make sure we don't have zombies&#xa;            # we should get a connection error. doing a is_alive subset.&#xa;            try:&#xa;                gc_output = self.get_cloud(noExtraErrorCheck=True)&#xa;                raise Exception(""get_cloud() should fail after we terminate a node. It isn't. %s %s"" % (self, gc_output))&#xa;            except:&#xa;                return True&#xa;&#xa;    def terminate(self):&#xa;        # new, moved this out. anyone using terminate should send h2o shutdown once before this&#xa;        if 1==0:&#xa;            self.shutdown_all()&#xa;        self.terminate_self_only()&#xa;&#xa;#*****************************************************************&#xa;class ExternalH2O(H2O):&#xa;    '''A cloned H2O instance assumed to be created by others, that we can interact with via json requests (urls)&#xa;       Gets initialized with state from json created by another build_cloud, so all methods should work 'as-if""&#xa;       the cloud was built by the test (normally).&#xa;       The normal build_cloud() parameters aren't passed here, the final node state is! (and used for init)&#xa;       The list should be complete, as long as created by build_cloud(create_json=True) or&#xa;       build_cloud_with_hosts(create_json=True)&#xa;       Obviously, no psutil or paramiko work done here.&#xa;    '''&#xa;&#xa;    def __init__(self, nodeState):&#xa;        for k, v in nodeState.iteritems():&#xa;            verboseprint(""init:"", k, v)&#xa;            # hack because it looks like the json is currently created with ""None"" for values of None&#xa;            # rather than worrying about that, just translate ""None"" to None here. ""None"" shouldn't exist&#xa;            # for any other reason.&#xa;            if v == ""None"":&#xa;                v = None&#xa;            elif v == ""false"":&#xa;                v = False&#xa;            elif v == ""true"":&#xa;                v = True&#xa;                # leave ""null"" as-is (string) for now?&#xa;&#xa;            setattr(self, k, v) # achieves self.k = v&#xa;            ## print ""Cloned"", len(nodeState), ""things for a h2o node""&#xa;&#xa;    def is_alive(self):&#xa;        verboseprint(""Doing is_alive check for ExternalH2O"")&#xa;        try:&#xa;            self.get_cloud()&#xa;            return True&#xa;        except:&#xa;            return False&#xa;&#xa;    # no terminate_self_only method&#xa;    def terminate_self_only(self):&#xa;        raise Exception(""terminate_self_only() not supported for ExternalH2O"")&#xa;&#xa;    def terminate(self):&#xa;        self.shutdown_all()&#xa;&#xa;&#xa;#*****************************************************************&#xa;class RemoteHost(object):&#xa;    def upload_file(self, f, progress=None):&#xa;        # FIX! we won't find it here if it's hdfs://172.16.2.151/ file&#xa;        f = find_file(f)&#xa;        if f not in self.uploaded:&#xa;            start = time.time()&#xa;            import md5&#xa;&#xa;            m = md5.new()&#xa;            m.update(open(f).read())&#xa;            m.update(getpass.getuser())&#xa;            dest = '/tmp/' + m.hexdigest() + ""-"" + os.path.basename(f)&#xa;&#xa;            # sigh. we rm/create sandbox in build_cloud now&#xa;            # (because nosetests doesn't exec h2o_main and we&#xa;            # don't want to code ""clean_sandbox()"" in all the tests.&#xa;            # So: we don't have a sandbox here, or if we do, we're going to delete it.&#xa;            # Just don't log anything until build_cloud()? that should be okay?&#xa;            # we were just logging this upload message..not needed.&#xa;            # log('Uploading to %s: %s -> %s' % (self.http_addr, f, dest))&#xa;            sftp = self.ssh.open_sftp()&#xa;            # check if file exists on remote side&#xa;            # does paramiko have issues with big files? (>1GB, or 650MB?). maybe we don't care.&#xa;            # This would arise (as mentioned in the source, line no 667, &#xa;            # http://www.lag.net/paramiko/docs/paramiko.sftp_client-pysrc.html) when there is &#xa;            # any error reading the packet or when there is EOFError&#xa;&#xa;            # but I'm getting sftp close here randomly at sm.&#xa;            # http://stackoverflow.com/questions/22708942/python-paramiko-module-error-with-callback&#xa;            # http://stackoverflow.com/questions/15010540/paramiko-sftp-server-connection-dropped&#xa;            # http://stackoverflow.com/questions/12322210/handling-paramiko-sshexception-server-connection-dropped&#xa;            try:&#xa;                # note we don't do a md5 compare. so if a corrupted file was uploaded we won't re-upload &#xa;                # until we do another build.&#xa;                sftp.stat(dest)&#xa;                print ""{0} Skipping upload of file {1}. File {2} exists on remote side!"".format(self, f, dest)&#xa;            except IOError, e:&#xa;                # if self.channel.closed or self.channel.exit_status_ready():&#xa;                #     raise Exception(""something bad happened to our %s being used for sftp. keepalive? %s %s"" % \&#xa;                #         (self, self.channel.closed, self.channel.exit_status_ready()))&#xa;&#xa;                if e.errno == errno.ENOENT: # no such file or directory&#xa;                    verboseprint(""{0} uploading file {1}"".format(self, f))&#xa;                    sftp.put(f, dest, callback=progress)&#xa;                    # if you want to track upload times&#xa;                    ### print ""\n{0:.3f} seconds"".format(time.time() - start)&#xa;                elif e.errno == errno.EEXIST: # File Exists&#xa;                    pass&#xa;                else:&#xa;                    print ""Got unexpected errno: %s on paramiko sftp."" % e.errno&#xa;                    print ""Lookup here: https://docs.python.org/2/library/errno.html""&#xa;                    # throw the exception again, if not what we expected&#xa;                    exc_info = sys.exc_info()&#xa;                    raise exc_info[1], None, exc_info[2]&#xa;            finally:&#xa;                sftp.close()&#xa;            self.uploaded[f] = dest&#xa;        sys.stdout.flush()&#xa;        return self.uploaded[f]&#xa;&#xa;    def record_file(self, f, dest):&#xa;        '''Record a file as having been uploaded by external means'''&#xa;        self.uploaded[f] = dest&#xa;&#xa;    def run_cmd(self, cmd):&#xa;        log('Running `%s` on %s' % (cmd, self))&#xa;        (stdin, stdout, stderr) = self.ssh.exec_command(cmd)&#xa;        stdin.close()&#xa;&#xa;        sys.stdout.write(stdout.read())&#xa;        sys.stdout.flush()&#xa;        stdout.close()&#xa;&#xa;        sys.stderr.write(stderr.read())&#xa;        sys.stderr.flush()&#xa;        stderr.close()&#xa;&#xa;    def push_file_to_remotes(self, f, hosts):&#xa;        dest = self.uploaded[f]&#xa;        for h in hosts:&#xa;            if h == self: continue&#xa;            self.run_cmd('scp %s %s@%s:%s' % (dest, h.username, h.h2o_addr, dest))&#xa;            h.record_file(f, dest)&#xa;&#xa;    def __init__(self, addr, username=None, password=None, **kwargs):&#xa;&#xa;        import paramiko&#xa;        # To debug paramiko you can use the following code:&#xa;        #paramiko.util.log_to_file('/tmp/paramiko.log')&#xa;        #paramiko.common.logging.basicConfig(level=paramiko.common.DEBUG)&#xa;&#xa;        # kbn. trying 9/23/13. Never specify -ip on java command line for multi-node&#xa;        # but self.h2o_addr is used elsewhere. so look at self.remoteH2O to disable in get_args()&#xa;&#xa;        # by definition, this must be the publicly visible addrs, otherwise we can't ssh or browse!&#xa;        self.h2o_addr = addr&#xa;        self.http_addr = addr&#xa;&#xa;        self.username = username # this works, but it's host state&#xa;        self.ssh = paramiko.SSHClient()&#xa;&#xa;        # don't require keys. If no password, assume passwordless setup was done&#xa;        policy = paramiko.AutoAddPolicy()&#xa;        self.ssh.set_missing_host_key_policy(policy)&#xa;        self.ssh.load_system_host_keys()&#xa;        if password is None:&#xa;            self.ssh.connect(self.h2o_addr, username=username, **kwargs)&#xa;        else:&#xa;            self.ssh.connect(self.h2o_addr, username=username, password=password, **kwargs)&#xa;&#xa;        # keep connection - send keepalive packet evety 5minutes&#xa;        self.ssh.get_transport().set_keepalive(300)&#xa;        self.uploaded = {}&#xa;&#xa;    def remote_h2o(self, *args, **kwargs):&#xa;        return RemoteH2O(self, self.h2o_addr, *args, **kwargs)&#xa;&#xa;    def open_channel(self):&#xa;        ch = self.ssh.get_transport().open_session()&#xa;        ch.get_pty() # force the process to die without the connection&#xa;        return ch&#xa;&#xa;    def __str__(self):&#xa;        return 'ssh://%s@%s' % (self.username, self.h2o_addr)&#xa;&#xa;&#xa;"
963965|"# http://stackoverflow.com/questions/963965/how-is-this-strategy-pattern&#xa;# -written-in-python-the-sample-in-wikipedia&#xa;""""""&#xa;In most of other languages Strategy pattern is implemented via creating some&#xa;base strategy interface/abstract class and subclassing it with a number of&#xa;concrete strategies (as we can see at&#xa;http://en.wikipedia.org/wiki/Strategy_pattern), however Python supports&#xa;higher-order functions and allows us to have only one class and inject&#xa;functions into it's instances, as shown in this example.&#xa;""""""&#xa;import types&#xa;&#xa;&#xa;class StrategyExample:&#xa;    def __init__(self, func=None):&#xa;        self.name = 'Strategy Example 0'&#xa;        if func is not None:&#xa;            self.execute = types.MethodType(func, self)&#xa;&#xa;    def execute(self):&#xa;        print(self.name)&#xa;&#xa;&#xa;def execute_replacement1(self):&#xa;    print(self.name + ' from execute 1')&#xa;&#xa;&#xa;def execute_replacement2(self):&#xa;    print(self.name + ' from execute 2')&#xa;&#xa;&#xa;if __name__ == '__main__':&#xa;    strat0 = StrategyExample()&#xa;&#xa;    strat1 = StrategyExample(execute_replacement1)&#xa;    strat1.name = 'Strategy Example 1'&#xa;&#xa;    strat2 = StrategyExample(execute_replacement2)&#xa;    strat2.name = 'Strategy Example 2'&#xa;&#xa;    strat0.execute()&#xa;    strat1.execute()&#xa;    strat2.execute()&#xa;"
24717027|"""""""&#xa;pytest local configuration plug-in&#xa;""""""&#xa;&#xa;import gc&#xa;import warnings&#xa;&#xa;import pytest&#xa;&#xa;@pytest.yield_fixture(scope='function', autouse=True)&#xa;def error_on_ResourceWarning():&#xa;    """"""This fixture captures ResourceWarning's and reports an ""error""&#xa;    describing the file handles left open.&#xa;    &#xa;    This is shown regardless of how successful the test was, if a test fails&#xa;    and leaves files open then those files will be reported.  Ideally, even&#xa;    those files should be closed properly after a test failure or exception.&#xa;&#xa;    Since only Python 3 and PyPy3 have ResourceWarning's, this context will&#xa;    have no effect when running tests on Python 2 or PyPy.&#xa;&#xa;    Because of autouse=True, this function will be automatically enabled for&#xa;    all test_* functions in this module.&#xa;&#xa;    This code is primarily based on the examples found here:&#xa;    https://stackoverflow.com/questions/24717027/convert-python-3-resourcewarnings-into-exception&#xa;    """"""&#xa;    try:&#xa;        ResourceWarning&#xa;    except NameError:&#xa;        # Python 2, PyPy&#xa;        yield&#xa;        return&#xa;    # Python 3, PyPy3&#xa;    with warnings.catch_warnings(record=True) as caught:&#xa;        warnings.resetwarnings() # clear all filters&#xa;        warnings.simplefilter('ignore') # ignore all&#xa;        warnings.simplefilter('always', ResourceWarning) # add filter&#xa;        yield # run tests in this context&#xa;        gc.collect() # run garbage collection (for pypy3)&#xa;        if not caught:&#xa;            return&#xa;        pytest.fail('The following file descriptors were not closed properly:\n' +&#xa;                    '\n'.join((str(warning.message) for warning in caught)),&#xa;                    pytrace=False)&#xa;"
21083571|# vim:fileencoding=utf-8:noet&#xa;from __future__ import (unicode_literals, division, absolute_import, print_function)&#xa;&#xa;import os&#xa;import sys&#xa;import re&#xa;&#xa;from powerline.lib.shell import run_cmd&#xa;&#xa;&#xa;def _fetch_battery_info(pl):&#xa;	try:&#xa;		import dbus&#xa;	except ImportError:&#xa;		pl.debug('Not using DBUS+UPower as dbus is not available')&#xa;	else:&#xa;		try:&#xa;			bus = dbus.SystemBus()&#xa;		except Exception as e:&#xa;			pl.exception('Failed to connect to system bus: {0}', str(e))&#xa;		else:&#xa;			interface = 'org.freedesktop.UPower'&#xa;			try:&#xa;				up = bus.get_object(interface, '/org/freedesktop/UPower')&#xa;			except dbus.exceptions.DBusException as e:&#xa;				if getattr(e, '_dbus_error_name', '').endswith('ServiceUnknown'):&#xa;					pl.debug('Not using DBUS+UPower as UPower is not available via dbus')&#xa;				else:&#xa;					pl.exception('Failed to get UPower service with dbus: {0}', str(e))&#xa;			else:&#xa;				devinterface = 'org.freedesktop.DBus.Properties'&#xa;				devtype_name = interface + '.Device'&#xa;				for devpath in up.EnumerateDevices(dbus_interface=interface):&#xa;					dev = bus.get_object(interface, devpath)&#xa;					devget = lambda what: dev.Get(&#xa;						devtype_name,&#xa;						what,&#xa;						dbus_interface=devinterface&#xa;					)&#xa;					if int(devget('Type')) != 2:&#xa;						pl.debug('Not using DBUS+UPower with {0}: invalid type', devpath)&#xa;						continue&#xa;					if not bool(devget('IsPresent')):&#xa;						pl.debug('Not using DBUS+UPower with {0}: not present', devpath)&#xa;						continue&#xa;					if not bool(devget('PowerSupply')):&#xa;						pl.debug('Not using DBUS+UPower with {0}: not a power supply', devpath)&#xa;						continue&#xa;					pl.debug('Using DBUS+UPower with {0}', devpath)&#xa;					return lambda pl: (&#xa;						float(&#xa;							dbus.Interface(dev, dbus_interface=devinterface).Get(&#xa;								devtype_name,&#xa;								'Percentage'&#xa;							),&#xa;						),&#xa;						dbus.Interface(dev, dbus_interface=devinterface).Get(&#xa;							devtype_name,&#xa;							'State'&#xa;						) == 1&#xa;					)&#xa;				pl.debug('Not using DBUS+UPower as no batteries were found')&#xa;&#xa;	if os.path.isdir('/sys/class/power_supply'):&#xa;		linux_bat_fmt = '/sys/class/power_supply/{0}/capacity'&#xa;		linux_ac_fmt = '/sys/class/power_supply/{0}/online'&#xa;		for linux_bat in os.listdir('/sys/class/power_supply'):&#xa;			cap_path = linux_bat_fmt.format(linux_bat)&#xa;			online_path = linux_ac_fmt.format(linux_bat)&#xa;			if linux_bat.startswith('BAT') and os.path.exists(cap_path):&#xa;				pl.debug('Using /sys/class/power_supply with battery {0}', linux_bat)&#xa;&#xa;				def _get_battery_status(pl):&#xa;					with open(cap_path, 'r') as f:&#xa;						_capacity = int(float(f.readline().split()[0]))&#xa;					with open(online_path, 'r') as f:&#xa;						_ac_powered = f.readline() == 1&#xa;					return _capacity, _ac_powered&#xa;				return _get_battery_status&#xa;			pl.debug('Not using /sys/class/power_supply as no batteries were found')&#xa;	else:&#xa;		pl.debug('Not using /sys/class/power_supply: no directory')&#xa;&#xa;	try:&#xa;		from shutil import which  # Python-3.3 and later&#xa;	except ImportError:&#xa;		pl.info('Using dumb “which” which only checks for file in /usr/bin')&#xa;		which = lambda f: (lambda fp: os.path.exists(fp) and fp)(os.path.join('/usr/bin', f))&#xa;&#xa;	if which('pmset'):&#xa;		pl.debug('Using pmset')&#xa;&#xa;		BATTERY_PERCENT_RE = re.compile(r'(\d+)%')&#xa;&#xa;		def _get_battery_status(pl):&#xa;			battery_summary = run_cmd(pl, ['pmset', '-g', 'batt'])&#xa;			battery_percent = BATTERY_PERCENT_RE.search(battery_summary).group(1)&#xa;			ac_charging = 'AC' in battery_summary&#xa;			return int(battery_percent), ac_charging&#xa;		return _get_battery_status&#xa;	else:&#xa;		pl.debug('Not using pmset: executable not found')&#xa;&#xa;	if sys.platform.startswith('win') or sys.platform == 'cygwin':&#xa;		# From http://stackoverflow.com/a/21083571/273566, reworked&#xa;		try:&#xa;			from win32com.client import GetObject&#xa;		except ImportError:&#xa;			pl.debug('Not using win32com.client as it is not available')&#xa;		else:&#xa;			try:&#xa;				wmi = GetObject('winmgmts:')&#xa;			except Exception as e:&#xa;				pl.exception('Failed to run GetObject from win32com.client: {0}', str(e))&#xa;			else:&#xa;				for battery in wmi.InstancesOf('Win32_Battery'):&#xa;					pl.debug('Using win32com.client with Win32_Battery')&#xa;&#xa;					def _get_battery_status(pl):&#xa;						# http://msdn.microsoft.com/en-us/library/aa394074(v=vs.85).aspx&#xa;						return battery.EstimatedChargeRemaining, battery.BatteryStatus == 6&#xa;&#xa;					return _get_battery_status&#xa;				pl.debug('Not using win32com.client as no batteries were found')&#xa;		from ctypes import Structure, c_byte, c_ulong, byref&#xa;		if sys.platform == 'cygwin':&#xa;			pl.debug('Using cdll to communicate with kernel32 (Cygwin)')&#xa;			from ctypes import cdll&#xa;			library_loader = cdll&#xa;		else:&#xa;			pl.debug('Using windll to communicate with kernel32 (Windows)')&#xa;			from ctypes import windll&#xa;			library_loader = windll&#xa;&#xa;		class PowerClass(Structure):&#xa;			_fields_ = [&#xa;				('ACLineStatus', c_byte),&#xa;				('BatteryFlag', c_byte),&#xa;				('BatteryLifePercent', c_byte),&#xa;				('Reserved1', c_byte),&#xa;				('BatteryLifeTime', c_ulong),&#xa;				('BatteryFullLifeTime', c_ulong)&#xa;			]&#xa;&#xa;		def _get_battery_status(pl):&#xa;			powerclass = PowerClass()&#xa;			result = library_loader.kernel32.GetSystemPowerStatus(byref(powerclass))&#xa;			# http://msdn.microsoft.com/en-us/library/windows/desktop/aa372693(v=vs.85).aspx&#xa;			if result:&#xa;				return None&#xa;			return powerclass.BatteryLifePercent, powerclass.ACLineStatus == 1&#xa;&#xa;		if _get_battery_status() is None:&#xa;			pl.debug('Not using GetSystemPowerStatus because it failed')&#xa;		else:&#xa;			pl.debug('Using GetSystemPowerStatus')&#xa;&#xa;		return _get_battery_status&#xa;&#xa;	raise NotImplementedError&#xa;&#xa;&#xa;def _get_battery_status(pl):&#xa;	global _get_battery_status&#xa;&#xa;	def _failing_get_status(pl):&#xa;		raise NotImplementedError&#xa;&#xa;	try:&#xa;		_get_battery_status = _fetch_battery_info(pl)&#xa;	except NotImplementedError:&#xa;		_get_battery_status = _failing_get_status&#xa;	except Exception as e:&#xa;		pl.exception('Exception while obtaining battery status: {0}', str(e))&#xa;		_get_battery_status = _failing_get_status&#xa;	return _get_battery_status(pl)&#xa;&#xa;&#xa;def battery(pl, format='{ac_state} {capacity:3.0%}', steps=5, gamify=False, full_heart='O', empty_heart='O', online='C', offline=' '):&#xa;	'''Return battery charge status.&#xa;&#xa;	:param str format:&#xa;		Percent format in case gamify is False. Format arguments: ``ac_state`` &#xa;		which is equal to either ``online`` or ``offline`` string arguments and &#xa;		``capacity`` which is equal to current battery capacity in interval [0, &#xa;		100].&#xa;	:param int steps:&#xa;		Number of discrete steps to show between 0% and 100% capacity if gamify&#xa;		is True.&#xa;	:param bool gamify:&#xa;		Measure in hearts (♥) instead of percentages. For full hearts &#xa;		``battery_full`` highlighting group is preferred, for empty hearts there &#xa;		is ``battery_empty``. ``battery_online`` or ``battery_offline`` group &#xa;		will be used for leading segment containing ``online`` or ``offline`` &#xa;		argument contents.&#xa;	:param str full_heart:&#xa;		Heart displayed for “full” part of battery.&#xa;	:param str empty_heart:&#xa;		Heart displayed for “used” part of battery. It is also displayed using&#xa;		another gradient level and highlighting group, so it is OK for it to be &#xa;		the same as full_heart as long as necessary highlighting groups are &#xa;		defined.&#xa;	:param str online:&#xa;		Symbol used if computer is connected to a power supply.&#xa;	:param str offline:&#xa;		Symbol used if computer is not connected to a power supply.&#xa;&#xa;	``battery_gradient`` and ``battery`` groups are used in any case, first is &#xa;	preferred.&#xa;&#xa;	Highlight groups used: ``battery_full`` or ``battery_gradient`` (gradient) or ``battery``, ``battery_empty`` or ``battery_gradient`` (gradient) or ``battery``, ``battery_online`` or ``battery_ac_state`` or ``battery_gradient`` (gradient) or ``battery``, ``battery_offline`` or ``battery_ac_state`` or ``battery_gradient`` (gradient) or ``battery``.&#xa;	'''&#xa;	try:&#xa;		capacity, ac_powered = _get_battery_status(pl)&#xa;	except NotImplementedError:&#xa;		pl.info('Unable to get battery status.')&#xa;		return None&#xa;&#xa;	ret = []&#xa;	if gamify:&#xa;		denom = int(steps)&#xa;		numer = int(denom * capacity / 100)&#xa;		ret.append({&#xa;			'contents': online if ac_powered else offline,&#xa;			'draw_inner_divider': False,&#xa;			'highlight_groups': ['battery_online' if ac_powered else 'battery_offline', 'battery_ac_state', 'battery_gradient', 'battery'],&#xa;			'gradient_level': 0,&#xa;		})&#xa;		ret.append({&#xa;			'contents': full_heart * numer,&#xa;			'draw_inner_divider': False,&#xa;			'highlight_groups': ['battery_full', 'battery_gradient', 'battery'],&#xa;			# Using zero as “nothing to worry about”: it is least alert color.&#xa;			'gradient_level': 0,&#xa;		})&#xa;		ret.append({&#xa;			'contents': empty_heart * (denom - numer),&#xa;			'draw_inner_divider': False,&#xa;			'highlight_groups': ['battery_empty', 'battery_gradient', 'battery'],&#xa;			# Using a hundred as it is most alert color.&#xa;			'gradient_level': 100,&#xa;		})&#xa;	else:&#xa;		ret.append({&#xa;			'contents': format.format(ac_state=(online if ac_powered else offline), capacity=(capacity / 100.0)),&#xa;			'highlight_groups': ['battery_gradient', 'battery'],&#xa;			# Gradients are “least alert – most alert” by default, capacity has &#xa;			# the opposite semantics.&#xa;			'gradient_level': 100 - capacity,&#xa;		})&#xa;	return ret&#xa;
1838699|"""""""Miscellaneous utility functions.""""""&#xa;&#xa;from __future__ import absolute_import, division, with_statement&#xa;&#xa;import zlib&#xa;&#xa;&#xa;class ObjectDict(dict):&#xa;    """"""Makes a dictionary behave like an object.""""""&#xa;    def __getattr__(self, name):&#xa;        try:&#xa;            return self[name]&#xa;        except KeyError:&#xa;            raise AttributeError(name)&#xa;&#xa;    def __setattr__(self, name, value):&#xa;        self[name] = value&#xa;&#xa;&#xa;class GzipDecompressor(object):&#xa;    """"""Streaming gzip decompressor.&#xa;&#xa;    The interface is like that of `zlib.decompressobj` (without the&#xa;    optional arguments, but it understands gzip headers and checksums.&#xa;    """"""&#xa;    def __init__(self):&#xa;        # Magic parameter makes zlib module understand gzip header&#xa;        # http://stackoverflow.com/questions/1838699/how-can-i-decompress-a-gzip-stream-with-zlib&#xa;        # This works on cpython and pypy, but not jython.&#xa;        self.decompressobj = zlib.decompressobj(16 + zlib.MAX_WBITS)&#xa;&#xa;    def decompress(self, value):&#xa;        """"""Decompress a chunk, returning newly-available data.&#xa;&#xa;        Some data may be buffered for later processing; `flush` must&#xa;        be called when there is no more input data to ensure that&#xa;        all data was processed.&#xa;        """"""&#xa;        return self.decompressobj.decompress(value)&#xa;&#xa;    def flush(self):&#xa;        """"""Return any remaining buffered data not yet returned by decompress.&#xa;&#xa;        Also checks for errors such as truncated input.&#xa;        No other methods may be called on this object after `flush`.&#xa;        """"""&#xa;        return self.decompressobj.flush()&#xa;&#xa;&#xa;def import_object(name):&#xa;    """"""Imports an object by name.&#xa;&#xa;    import_object('x.y.z') is equivalent to 'from x.y import z'.&#xa;&#xa;    >>> import tornado.escape&#xa;    >>> import_object('tornado.escape') is tornado.escape&#xa;    True&#xa;    >>> import_object('tornado.escape.utf8') is tornado.escape.utf8&#xa;    True&#xa;    """"""&#xa;    parts = name.split('.')&#xa;    obj = __import__('.'.join(parts[:-1]), None, None, [parts[-1]], 0)&#xa;    return getattr(obj, parts[-1])&#xa;&#xa;# Fake byte literal support:  In python 2.6+, you can say b""foo"" to get&#xa;# a byte literal (str in 2.x, bytes in 3.x).  There's no way to do this&#xa;# in a way that supports 2.5, though, so we need a function wrapper&#xa;# to convert our string literals.  b() should only be applied to literal&#xa;# latin1 strings.  Once we drop support for 2.5, we can remove this function&#xa;# and just use byte literals.&#xa;if str is unicode:&#xa;    def b(s):&#xa;        return s.encode('latin1')&#xa;    bytes_type = bytes&#xa;else:&#xa;    def b(s):&#xa;        return s&#xa;    bytes_type = str&#xa;&#xa;&#xa;def raise_exc_info(exc_info):&#xa;    """"""Re-raise an exception (with original traceback) from an exc_info tuple.&#xa;&#xa;    The argument is a ``(type, value, traceback)`` tuple as returned by&#xa;    `sys.exc_info`.&#xa;    """"""&#xa;    # 2to3 isn't smart enough to convert three-argument raise&#xa;    # statements correctly in some cases.&#xa;    if isinstance(exc_info[1], exc_info[0]):&#xa;        raise exc_info[1], None, exc_info[2]&#xa;        # After 2to3: raise exc_info[1].with_traceback(exc_info[2])&#xa;    else:&#xa;        # I think this branch is only taken for string exceptions,&#xa;        # which were removed in Python 2.6.&#xa;        raise exc_info[0], exc_info[1], exc_info[2]&#xa;        # After 2to3: raise exc_info[0](exc_info[1]).with_traceback(exc_info[2])&#xa;&#xa;&#xa;def doctests():&#xa;    import doctest&#xa;    return doctest.DocTestSuite()&#xa;"
16327037|"#&#xa;# Author:  Travis Oliphant, 2002&#xa;#&#xa;&#xa;from __future__ import division, print_function, absolute_import&#xa;&#xa;import warnings&#xa;&#xa;import numpy as np&#xa;import math&#xa;from scipy._lib.six import xrange&#xa;from numpy import (pi, asarray, floor, isscalar, iscomplex, real, imag, sqrt,&#xa;                   where, mgrid, sin, place, issubdtype, extract,&#xa;                   less, inexact, nan, zeros, atleast_1d, sinc)&#xa;from ._ufuncs import (ellipkm1, mathieu_a, mathieu_b, iv, jv, gamma,&#xa;                      psi, _zeta, hankel1, hankel2, yv, kv, _gammaln,&#xa;                      ndtri, errprint, poch, binom, hyp0f1)&#xa;from . import specfun&#xa;from . import orthogonal&#xa;from ._comb import _comb_int&#xa;&#xa;__all__ = ['agm', 'ai_zeros', 'assoc_laguerre', 'bei_zeros', 'beip_zeros',&#xa;           'ber_zeros', 'bernoulli', 'berp_zeros', 'bessel_diff_formula',&#xa;           'bi_zeros', 'clpmn', 'comb', 'digamma', 'diric', 'ellipk',&#xa;           'erf_zeros', 'erfcinv', 'erfinv', 'errprint', 'euler', 'factorial',&#xa;           'factorialk', 'factorial2', 'fresnel_zeros',&#xa;           'fresnelc_zeros', 'fresnels_zeros', 'gamma', 'gammaln', 'h1vp',&#xa;           'h2vp', 'hankel1', 'hankel2', 'hyp0f1', 'iv', 'ivp', 'jn_zeros',&#xa;           'jnjnp_zeros', 'jnp_zeros', 'jnyn_zeros', 'jv', 'jvp', 'kei_zeros',&#xa;           'keip_zeros', 'kelvin_zeros', 'ker_zeros', 'kerp_zeros', 'kv',&#xa;           'kvp', 'lmbda', 'lpmn', 'lpn', 'lqmn', 'lqn', 'mathieu_a',&#xa;           'mathieu_b', 'mathieu_even_coef', 'mathieu_odd_coef', 'ndtri',&#xa;           'obl_cv_seq', 'pbdn_seq', 'pbdv_seq', 'pbvv_seq', 'perm',&#xa;           'polygamma', 'pro_cv_seq', 'psi', 'riccati_jn', 'riccati_yn',&#xa;           'sinc', 'sph_in', 'sph_inkn',&#xa;           'sph_jn', 'sph_jnyn', 'sph_kn', 'sph_yn', 'y0_zeros', 'y1_zeros',&#xa;           'y1p_zeros', 'yn_zeros', 'ynp_zeros', 'yv', 'yvp', 'zeta',&#xa;           'SpecialFunctionWarning']&#xa;&#xa;&#xa;class SpecialFunctionWarning(Warning):&#xa;    """"""Warning that can be issued with ``errprint(True)``""""""&#xa;    pass&#xa;warnings.simplefilter(""always"", category=SpecialFunctionWarning)&#xa;&#xa;&#xa;def diric(x, n):&#xa;    """"""Periodic sinc function, also called the Dirichlet function.&#xa;&#xa;    The Dirichlet function is defined as::&#xa;&#xa;        diric(x) = sin(x * n/2) / (n * sin(x / 2)),&#xa;&#xa;    where `n` is a positive integer.&#xa;&#xa;    Parameters&#xa;    ----------&#xa;    x : array_like&#xa;        Input data&#xa;    n : int&#xa;        Integer defining the periodicity.&#xa;&#xa;    Returns&#xa;    -------&#xa;    diric : ndarray&#xa;&#xa;    Examples&#xa;    --------&#xa;    >>> from scipy import special&#xa;    >>> import matplotlib.pyplot as plt&#xa;&#xa;    >>> x = np.linspace(-8*np.pi, 8*np.pi, num=201)&#xa;    >>> plt.figure(figsize=(8, 8));&#xa;    >>> for idx, n in enumerate([2, 3, 4, 9]):&#xa;    ...     plt.subplot(2, 2, idx+1)&#xa;    ...     plt.plot(x, special.diric(x, n))&#xa;    ...     plt.title('diric, n={}'.format(n))&#xa;    >>> plt.show()&#xa;&#xa;    The following example demonstrates that `diric` gives the magnitudes&#xa;    (modulo the sign and scaling) of the Fourier coefficients of a&#xa;    rectangular pulse.&#xa;&#xa;    Suppress output of values that are effectively 0:&#xa;&#xa;    >>> np.set_printoptions(suppress=True)&#xa;&#xa;    Create a signal `x` of length `m` with `k` ones:&#xa;&#xa;    >>> m = 8&#xa;    >>> k = 3&#xa;    >>> x = np.zeros(m)&#xa;    >>> x[:k] = 1&#xa;&#xa;    Use the FFT to compute the Fourier transform of `x`, and&#xa;    inspect the magnitudes of the coefficients:&#xa;&#xa;    >>> np.abs(np.fft.fft(x))&#xa;    array([ 3.        ,  2.41421356,  1.        ,  0.41421356,  1.        ,&#xa;            0.41421356,  1.        ,  2.41421356])&#xa;&#xa;    Now find the same values (up to sign) using `diric`.  We multiply&#xa;    by `k` to account for the different scaling conventions of&#xa;    `numpy.fft.fft` and `diric`:&#xa;&#xa;    >>> theta = np.linspace(0, 2*np.pi, m, endpoint=False)&#xa;    >>> k * special.diric(theta, k)&#xa;    array([ 3.        ,  2.41421356,  1.        , -0.41421356, -1.        ,&#xa;           -0.41421356,  1.        ,  2.41421356])&#xa;    """"""&#xa;    x, n = asarray(x), asarray(n)&#xa;    n = asarray(n + (x-x))&#xa;    x = asarray(x + (n-n))&#xa;    if issubdtype(x.dtype, inexact):&#xa;        ytype = x.dtype&#xa;    else:&#xa;        ytype = float&#xa;    y = zeros(x.shape, ytype)&#xa;&#xa;    # empirical minval for 32, 64 or 128 bit float computations&#xa;    # where sin(x/2) < minval, result is fixed at +1 or -1&#xa;    if np.finfo(ytype).eps < 1e-18:&#xa;        minval = 1e-11&#xa;    elif np.finfo(ytype).eps < 1e-15:&#xa;        minval = 1e-7&#xa;    else:&#xa;        minval = 1e-3&#xa;&#xa;    mask1 = (n <= 0) | (n != floor(n))&#xa;    place(y, mask1, nan)&#xa;&#xa;    x = x / 2&#xa;    denom = sin(x)&#xa;    mask2 = (1-mask1) & (abs(denom) < minval)&#xa;    xsub = extract(mask2, x)&#xa;    nsub = extract(mask2, n)&#xa;    zsub = xsub / pi&#xa;    place(y, mask2, pow(-1, np.round(zsub)*(nsub-1)))&#xa;&#xa;    mask = (1-mask1) & (1-mask2)&#xa;    xsub = extract(mask, x)&#xa;    nsub = extract(mask, n)&#xa;    dsub = extract(mask, denom)&#xa;    place(y, mask, sin(nsub*xsub)/(nsub*dsub))&#xa;    return y&#xa;&#xa;&#xa;def gammaln(x):&#xa;    """"""&#xa;    Logarithm of the absolute value of the Gamma function for real inputs.&#xa;&#xa;    Parameters&#xa;    ----------&#xa;    x : array-like&#xa;        Values on the real line at which to compute ``gammaln``&#xa;&#xa;    Returns&#xa;    -------&#xa;    gammaln : ndarray&#xa;        Values of ``gammaln`` at x.&#xa;&#xa;    See Also&#xa;    --------&#xa;    gammasgn : sign of the gamma function&#xa;    loggamma : principal branch of the logarithm of the gamma function&#xa;&#xa;    Notes&#xa;    -----&#xa;    When used in conjunction with `gammasgn`, this function is useful&#xa;    for working in logspace on the real axis without having to deal with&#xa;    complex numbers, via the relation ``exp(gammaln(x)) = gammasgn(x)*gamma(x)``.&#xa;&#xa;    Note that `gammaln` currently accepts complex-valued inputs, but it is not&#xa;    the same function as for real-valued inputs, and the branch is not&#xa;    well-defined --- using `gammaln` with complex is deprecated and will be&#xa;    disallowed in future Scipy versions.&#xa;&#xa;    For complex-valued log-gamma, use `loggamma` instead of `gammaln`.&#xa;&#xa;    """"""&#xa;    if np.iscomplexobj(x):&#xa;        warnings.warn((""Use of gammaln for complex arguments is ""&#xa;                       ""deprecated as of scipy 0.18.0. Use ""&#xa;                       ""scipy.special.loggamma instead.""),&#xa;                      DeprecationWarning)&#xa;    return _gammaln(x)&#xa;&#xa;&#xa;def jnjnp_zeros(nt):&#xa;    """"""Compute zeros of integer-order Bessel functions Jn and Jn'.&#xa;&#xa;    Results are arranged in order of the magnitudes of the zeros.&#xa;&#xa;    Parameters&#xa;    ----------&#xa;    nt : int&#xa;        Number (<=1200) of zeros to compute&#xa;&#xa;    Returns&#xa;    -------&#xa;    zo[l-1] : ndarray&#xa;        Value of the lth zero of Jn(x) and Jn'(x). Of length `nt`.&#xa;    n[l-1] : ndarray&#xa;        Order of the Jn(x) or Jn'(x) associated with lth zero. Of length `nt`.&#xa;    m[l-1] : ndarray&#xa;        Serial number of the zeros of Jn(x) or Jn'(x) associated&#xa;        with lth zero. Of length `nt`.&#xa;    t[l-1] : ndarray&#xa;        0 if lth zero in zo is zero of Jn(x), 1 if it is a zero of Jn'(x). Of&#xa;        length `nt`.&#xa;&#xa;    See Also&#xa;    --------&#xa;    jn_zeros, jnp_zeros : to get separated arrays of zeros.&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996, chapter 5.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;&#xa;    """"""&#xa;    if not isscalar(nt) or (floor(nt) != nt) or (nt > 1200):&#xa;        raise ValueError(""Number must be integer <= 1200."")&#xa;    nt = int(nt)&#xa;    n, m, t, zo = specfun.jdzo(nt)&#xa;    return zo[1:nt+1], n[:nt], m[:nt], t[:nt]&#xa;&#xa;&#xa;def jnyn_zeros(n, nt):&#xa;    """"""Compute nt zeros of Bessel functions Jn(x), Jn'(x), Yn(x), and Yn'(x).&#xa;&#xa;    Returns 4 arrays of length `nt`, corresponding to the first `nt` zeros of&#xa;    Jn(x), Jn'(x), Yn(x), and Yn'(x), respectively.&#xa;&#xa;    Parameters&#xa;    ----------&#xa;    n : int&#xa;        Order of the Bessel functions&#xa;    nt : int&#xa;        Number (<=1200) of zeros to compute&#xa;&#xa;    See jn_zeros, jnp_zeros, yn_zeros, ynp_zeros to get separate arrays.&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996, chapter 5.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;&#xa;    """"""&#xa;    if not (isscalar(nt) and isscalar(n)):&#xa;        raise ValueError(""Arguments must be scalars."")&#xa;    if (floor(n) != n) or (floor(nt) != nt):&#xa;        raise ValueError(""Arguments must be integers."")&#xa;    if (nt <= 0):&#xa;        raise ValueError(""nt > 0"")&#xa;    return specfun.jyzo(abs(n), nt)&#xa;&#xa;&#xa;def jn_zeros(n, nt):&#xa;    """"""Compute zeros of integer-order Bessel function Jn(x).&#xa;&#xa;    Parameters&#xa;    ----------&#xa;    n : int&#xa;        Order of Bessel function&#xa;    nt : int&#xa;        Number of zeros to return&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996, chapter 5.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;&#xa;    """"""&#xa;    return jnyn_zeros(n, nt)[0]&#xa;&#xa;&#xa;def jnp_zeros(n, nt):&#xa;    """"""Compute zeros of integer-order Bessel function derivative Jn'(x).&#xa;&#xa;    Parameters&#xa;    ----------&#xa;    n : int&#xa;        Order of Bessel function&#xa;    nt : int&#xa;        Number of zeros to return&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996, chapter 5.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;&#xa;    """"""&#xa;    return jnyn_zeros(n, nt)[1]&#xa;&#xa;&#xa;def yn_zeros(n, nt):&#xa;    """"""Compute zeros of integer-order Bessel function Yn(x).&#xa;&#xa;    Parameters&#xa;    ----------&#xa;    n : int&#xa;        Order of Bessel function&#xa;    nt : int&#xa;        Number of zeros to return&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996, chapter 5.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;&#xa;    """"""&#xa;    return jnyn_zeros(n, nt)[2]&#xa;&#xa;&#xa;def ynp_zeros(n, nt):&#xa;    """"""Compute zeros of integer-order Bessel function derivative Yn'(x).&#xa;&#xa;    Parameters&#xa;    ----------&#xa;    n : int&#xa;        Order of Bessel function&#xa;    nt : int&#xa;        Number of zeros to return&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996, chapter 5.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;&#xa;    """"""&#xa;    return jnyn_zeros(n, nt)[3]&#xa;&#xa;&#xa;def y0_zeros(nt, complex=False):&#xa;    """"""Compute nt zeros of Bessel function Y0(z), and derivative at each zero.&#xa;&#xa;    The derivatives are given by Y0'(z0) = -Y1(z0) at each zero z0.&#xa;&#xa;    Parameters&#xa;    ----------&#xa;    nt : int&#xa;        Number of zeros to return&#xa;    complex : bool, default False&#xa;        Set to False to return only the real zeros; set to True to return only&#xa;        the complex zeros with negative real part and positive imaginary part.&#xa;        Note that the complex conjugates of the latter are also zeros of the&#xa;        function, but are not returned by this routine.&#xa;&#xa;    Returns&#xa;    -------&#xa;    z0n : ndarray&#xa;        Location of nth zero of Y0(z)&#xa;    y0pz0n : ndarray&#xa;        Value of derivative Y0'(z0) for nth zero&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996, chapter 5.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;&#xa;    """"""&#xa;    if not isscalar(nt) or (floor(nt) != nt) or (nt <= 0):&#xa;        raise ValueError(""Arguments must be scalar positive integer."")&#xa;    kf = 0&#xa;    kc = not complex&#xa;    return specfun.cyzo(nt, kf, kc)&#xa;&#xa;&#xa;def y1_zeros(nt, complex=False):&#xa;    """"""Compute nt zeros of Bessel function Y1(z), and derivative at each zero.&#xa;&#xa;    The derivatives are given by Y1'(z1) = Y0(z1) at each zero z1.&#xa;&#xa;    Parameters&#xa;    ----------&#xa;    nt : int&#xa;        Number of zeros to return&#xa;    complex : bool, default False&#xa;        Set to False to return only the real zeros; set to True to return only&#xa;        the complex zeros with negative real part and positive imaginary part.&#xa;        Note that the complex conjugates of the latter are also zeros of the&#xa;        function, but are not returned by this routine.&#xa;&#xa;    Returns&#xa;    -------&#xa;    z1n : ndarray&#xa;        Location of nth zero of Y1(z)&#xa;    y1pz1n : ndarray&#xa;        Value of derivative Y1'(z1) for nth zero&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996, chapter 5.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;&#xa;    """"""&#xa;    if not isscalar(nt) or (floor(nt) != nt) or (nt <= 0):&#xa;        raise ValueError(""Arguments must be scalar positive integer."")&#xa;    kf = 1&#xa;    kc = not complex&#xa;    return specfun.cyzo(nt, kf, kc)&#xa;&#xa;&#xa;def y1p_zeros(nt, complex=False):&#xa;    """"""Compute nt zeros of Bessel derivative Y1'(z), and value at each zero.&#xa;&#xa;    The values are given by Y1(z1) at each z1 where Y1'(z1)=0.&#xa;&#xa;    Parameters&#xa;    ----------&#xa;    nt : int&#xa;        Number of zeros to return&#xa;    complex : bool, default False&#xa;        Set to False to return only the real zeros; set to True to return only&#xa;        the complex zeros with negative real part and positive imaginary part.&#xa;        Note that the complex conjugates of the latter are also zeros of the&#xa;        function, but are not returned by this routine.&#xa;&#xa;    Returns&#xa;    -------&#xa;    z1pn : ndarray&#xa;        Location of nth zero of Y1'(z)&#xa;    y1z1pn : ndarray&#xa;        Value of derivative Y1(z1) for nth zero&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996, chapter 5.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;&#xa;    """"""&#xa;    if not isscalar(nt) or (floor(nt) != nt) or (nt <= 0):&#xa;        raise ValueError(""Arguments must be scalar positive integer."")&#xa;    kf = 2&#xa;    kc = not complex&#xa;    return specfun.cyzo(nt, kf, kc)&#xa;&#xa;&#xa;def _bessel_diff_formula(v, z, n, L, phase):&#xa;    # from AMS55.&#xa;    # L(v, z) = J(v, z), Y(v, z), H1(v, z), H2(v, z), phase = -1&#xa;    # L(v, z) = I(v, z) or exp(v*pi*i)K(v, z), phase = 1&#xa;    # For K, you can pull out the exp((v-k)*pi*i) into the caller&#xa;    v = asarray(v)&#xa;    p = 1.0&#xa;    s = L(v-n, z)&#xa;    for i in xrange(1, n+1):&#xa;        p = phase * (p * (n-i+1)) / i   # = choose(k, i)&#xa;        s += p*L(v-n + i*2, z)&#xa;    return s / (2.**n)&#xa;&#xa;&#xa;bessel_diff_formula = np.deprecate(_bessel_diff_formula,&#xa;    message=""bessel_diff_formula is a private function, do not use it!"")&#xa;&#xa;&#xa;def jvp(v, z, n=1):&#xa;    """"""Compute nth derivative of Bessel function Jv(z) with respect to `z`.&#xa;&#xa;    Parameters&#xa;    ----------&#xa;    v : float&#xa;        Order of Bessel function&#xa;    z : complex&#xa;        Argument at which to evaluate the derivative&#xa;    n : int, default 1&#xa;        Order of derivative&#xa;&#xa;    Notes&#xa;    -----&#xa;    The derivative is computed using the relation DLFM 10.6.7 [2]_.&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996, chapter 5.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;    .. [2] NIST Digital Library of Mathematical Functions.&#xa;           http://dlmf.nist.gov/10.6.E7&#xa;&#xa;    """"""&#xa;    if not isinstance(n, int) or (n < 0):&#xa;        raise ValueError(""n must be a non-negative integer."")&#xa;    if n == 0:&#xa;        return jv(v, z)&#xa;    else:&#xa;        return _bessel_diff_formula(v, z, n, jv, -1)&#xa;&#xa;&#xa;def yvp(v, z, n=1):&#xa;    """"""Compute nth derivative of Bessel function Yv(z) with respect to `z`.&#xa;&#xa;    Parameters&#xa;    ----------&#xa;    v : float&#xa;        Order of Bessel function&#xa;    z : complex&#xa;        Argument at which to evaluate the derivative&#xa;    n : int, default 1&#xa;        Order of derivative&#xa;&#xa;    Notes&#xa;    -----&#xa;    The derivative is computed using the relation DLFM 10.6.7 [2]_.&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996, chapter 5.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;    .. [2] NIST Digital Library of Mathematical Functions.&#xa;           http://dlmf.nist.gov/10.6.E7&#xa;&#xa;    """"""&#xa;    if not isinstance(n, int) or (n < 0):&#xa;        raise ValueError(""n must be a non-negative integer."")&#xa;    if n == 0:&#xa;        return yv(v, z)&#xa;    else:&#xa;        return _bessel_diff_formula(v, z, n, yv, -1)&#xa;&#xa;&#xa;def kvp(v, z, n=1):&#xa;    """"""Compute nth derivative of real-order modified Bessel function Kv(z)&#xa;&#xa;    Kv(z) is the modified Bessel function of the second kind.&#xa;    Derivative is calculated with respect to `z`.&#xa;&#xa;    Parameters&#xa;    ----------&#xa;    v : array_like of float&#xa;        Order of Bessel function&#xa;    z : array_like of complex&#xa;        Argument at which to evaluate the derivative&#xa;    n : int&#xa;        Order of derivative.  Default is first derivative.&#xa;&#xa;    Returns&#xa;    -------&#xa;    out : ndarray&#xa;        The results&#xa;&#xa;    Examples&#xa;    --------&#xa;    Calculate multiple values at order 5:&#xa;&#xa;    >>> from scipy.special import kvp&#xa;    >>> kvp(5, (1, 2, 3+5j))&#xa;    array([-1849.0354+0.j    ,   -25.7735+0.j    ,    -0.0307+0.0875j])&#xa;&#xa;    Calculate for a single value at multiple orders:&#xa;&#xa;    >>> kvp((4, 4.5, 5), 1)&#xa;    array([ -184.0309,  -568.9585, -1849.0354])&#xa;&#xa;    Notes&#xa;    -----&#xa;    The derivative is computed using the relation DLFM 10.29.5 [2]_.&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996, chapter 6.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;    .. [2] NIST Digital Library of Mathematical Functions.&#xa;           http://dlmf.nist.gov/10.29.E5&#xa;&#xa;    """"""&#xa;    if not isinstance(n, int) or (n < 0):&#xa;        raise ValueError(""n must be a non-negative integer."")&#xa;    if n == 0:&#xa;        return kv(v, z)&#xa;    else:&#xa;        return (-1)**n * _bessel_diff_formula(v, z, n, kv, 1)&#xa;&#xa;&#xa;def ivp(v, z, n=1):&#xa;    """"""Compute nth derivative of modified Bessel function Iv(z) with respect&#xa;    to `z`.&#xa;&#xa;    Parameters&#xa;    ----------&#xa;    v : array_like of float&#xa;        Order of Bessel function&#xa;    z : array_like of complex&#xa;        Argument at which to evaluate the derivative&#xa;    n : int, default 1&#xa;        Order of derivative&#xa;&#xa;    Notes&#xa;    -----&#xa;    The derivative is computed using the relation DLFM 10.29.5 [2]_.&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996, chapter 6.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;    .. [2] NIST Digital Library of Mathematical Functions.&#xa;           http://dlmf.nist.gov/10.29.E5&#xa;&#xa;    """"""&#xa;    if not isinstance(n, int) or (n < 0):&#xa;        raise ValueError(""n must be a non-negative integer."")&#xa;    if n == 0:&#xa;        return iv(v, z)&#xa;    else:&#xa;        return _bessel_diff_formula(v, z, n, iv, 1)&#xa;&#xa;&#xa;def h1vp(v, z, n=1):&#xa;    """"""Compute nth derivative of Hankel function H1v(z) with respect to `z`.&#xa;&#xa;    Parameters&#xa;    ----------&#xa;    v : float&#xa;        Order of Hankel function&#xa;    z : complex&#xa;        Argument at which to evaluate the derivative&#xa;    n : int, default 1&#xa;        Order of derivative&#xa;&#xa;    Notes&#xa;    -----&#xa;    The derivative is computed using the relation DLFM 10.6.7 [2]_.&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996, chapter 5.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;    .. [2] NIST Digital Library of Mathematical Functions.&#xa;           http://dlmf.nist.gov/10.6.E7&#xa;&#xa;    """"""&#xa;    if not isinstance(n, int) or (n < 0):&#xa;        raise ValueError(""n must be a non-negative integer."")&#xa;    if n == 0:&#xa;        return hankel1(v, z)&#xa;    else:&#xa;        return _bessel_diff_formula(v, z, n, hankel1, -1)&#xa;&#xa;&#xa;def h2vp(v, z, n=1):&#xa;    """"""Compute nth derivative of Hankel function H2v(z) with respect to `z`.&#xa;&#xa;    Parameters&#xa;    ----------&#xa;    v : float&#xa;        Order of Hankel function&#xa;    z : complex&#xa;        Argument at which to evaluate the derivative&#xa;    n : int, default 1&#xa;        Order of derivative&#xa;&#xa;    Notes&#xa;    -----&#xa;    The derivative is computed using the relation DLFM 10.6.7 [2]_.&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996, chapter 5.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;    .. [2] NIST Digital Library of Mathematical Functions.&#xa;           http://dlmf.nist.gov/10.6.E7&#xa;&#xa;    """"""&#xa;    if not isinstance(n, int) or (n < 0):&#xa;        raise ValueError(""n must be a non-negative integer."")&#xa;    if n == 0:&#xa;        return hankel2(v, z)&#xa;    else:&#xa;        return _bessel_diff_formula(v, z, n, hankel2, -1)&#xa;&#xa;&#xa;@np.deprecate(message=""scipy.special.sph_jn is deprecated in scipy 0.18.0. ""&#xa;                      ""Use scipy.special.spherical_jn instead. ""&#xa;                      ""Note that the new function has a different signature."")&#xa;def sph_jn(n, z):&#xa;    """"""Compute spherical Bessel function jn(z) and derivative.&#xa;&#xa;    This function computes the value and first derivative of jn(z) for all&#xa;    orders up to and including n.&#xa;&#xa;    Parameters&#xa;    ----------&#xa;    n : int&#xa;        Maximum order of jn to compute&#xa;    z : complex&#xa;        Argument at which to evaluate&#xa;&#xa;    Returns&#xa;    -------&#xa;    jn : ndarray&#xa;        Value of j0(z), ..., jn(z)&#xa;    jnp : ndarray&#xa;        First derivative j0'(z), ..., jn'(z)&#xa;&#xa;    See also&#xa;    --------&#xa;    spherical_jn&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996, chapter 8.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;&#xa;    """"""&#xa;    if not (isscalar(n) and isscalar(z)):&#xa;        raise ValueError(""arguments must be scalars."")&#xa;    if (n != floor(n)) or (n < 0):&#xa;        raise ValueError(""n must be a non-negative integer."")&#xa;    if (n < 1):&#xa;        n1 = 1&#xa;    else:&#xa;        n1 = n&#xa;    if iscomplex(z):&#xa;        nm, jn, jnp, yn, ynp = specfun.csphjy(n1, z)&#xa;    else:&#xa;        nm, jn, jnp = specfun.sphj(n1, z)&#xa;    return jn[:(n+1)], jnp[:(n+1)]&#xa;&#xa;&#xa;@np.deprecate(message=""scipy.special.sph_yn is deprecated in scipy 0.18.0. ""&#xa;                      ""Use scipy.special.spherical_yn instead. ""&#xa;                      ""Note that the new function has a different signature."")&#xa;def sph_yn(n, z):&#xa;    """"""Compute spherical Bessel function yn(z) and derivative.&#xa;&#xa;    This function computes the value and first derivative of yn(z) for all&#xa;    orders up to and including n.&#xa;&#xa;    Parameters&#xa;    ----------&#xa;    n : int&#xa;        Maximum order of yn to compute&#xa;    z : complex&#xa;        Argument at which to evaluate&#xa;&#xa;    Returns&#xa;    -------&#xa;    yn : ndarray&#xa;        Value of y0(z), ..., yn(z)&#xa;    ynp : ndarray&#xa;        First derivative y0'(z), ..., yn'(z)&#xa;&#xa;    See also&#xa;    --------&#xa;    spherical_yn&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996, chapter 8.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;&#xa;    """"""&#xa;    if not (isscalar(n) and isscalar(z)):&#xa;        raise ValueError(""arguments must be scalars."")&#xa;    if (n != floor(n)) or (n < 0):&#xa;        raise ValueError(""n must be a non-negative integer."")&#xa;    if (n < 1):&#xa;        n1 = 1&#xa;    else:&#xa;        n1 = n&#xa;    if iscomplex(z) or less(z, 0):&#xa;        nm, jn, jnp, yn, ynp = specfun.csphjy(n1, z)&#xa;    else:&#xa;        nm, yn, ynp = specfun.sphy(n1, z)&#xa;    return yn[:(n+1)], ynp[:(n+1)]&#xa;&#xa;&#xa;@np.deprecate(message=""scipy.special.sph_jnyn is deprecated in scipy 0.18.0. ""&#xa;                      ""Use scipy.special.spherical_jn and ""&#xa;                      ""scipy.special.spherical_yn instead. ""&#xa;                      ""Note that the new function has a different signature."")&#xa;def sph_jnyn(n, z):&#xa;    """"""Compute spherical Bessel functions jn(z) and yn(z) and derivatives.&#xa;&#xa;    This function computes the value and first derivative of jn(z) and yn(z)&#xa;    for all orders up to and including n.&#xa;&#xa;    Parameters&#xa;    ----------&#xa;    n : int&#xa;        Maximum order of jn and yn to compute&#xa;    z : complex&#xa;        Argument at which to evaluate&#xa;&#xa;    Returns&#xa;    -------&#xa;    jn : ndarray&#xa;        Value of j0(z), ..., jn(z)&#xa;    jnp : ndarray&#xa;        First derivative j0'(z), ..., jn'(z)&#xa;    yn : ndarray&#xa;        Value of y0(z), ..., yn(z)&#xa;    ynp : ndarray&#xa;        First derivative y0'(z), ..., yn'(z)&#xa;&#xa;    See also&#xa;    --------&#xa;    spherical_jn&#xa;    spherical_yn&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996, chapter 8.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;&#xa;    """"""&#xa;    if not (isscalar(n) and isscalar(z)):&#xa;        raise ValueError(""arguments must be scalars."")&#xa;    if (n != floor(n)) or (n < 0):&#xa;        raise ValueError(""n must be a non-negative integer."")&#xa;    if (n < 1):&#xa;        n1 = 1&#xa;    else:&#xa;        n1 = n&#xa;    if iscomplex(z) or less(z, 0):&#xa;        nm, jn, jnp, yn, ynp = specfun.csphjy(n1, z)&#xa;    else:&#xa;        nm, yn, ynp = specfun.sphy(n1, z)&#xa;        nm, jn, jnp = specfun.sphj(n1, z)&#xa;    return jn[:(n+1)], jnp[:(n+1)], yn[:(n+1)], ynp[:(n+1)]&#xa;&#xa;&#xa;@np.deprecate(message=""scipy.special.sph_in is deprecated in scipy 0.18.0. ""&#xa;                      ""Use scipy.special.spherical_in instead. ""&#xa;                      ""Note that the new function has a different signature."")&#xa;def sph_in(n, z):&#xa;    """"""Compute spherical Bessel function in(z) and derivative.&#xa;&#xa;    This function computes the value and first derivative of in(z) for all&#xa;    orders up to and including n.&#xa;&#xa;    Parameters&#xa;    ----------&#xa;    n : int&#xa;        Maximum order of in to compute&#xa;    z : complex&#xa;        Argument at which to evaluate&#xa;&#xa;    Returns&#xa;    -------&#xa;    in : ndarray&#xa;        Value of i0(z), ..., in(z)&#xa;    inp : ndarray&#xa;        First derivative i0'(z), ..., in'(z)&#xa;&#xa;    See also&#xa;    --------&#xa;    spherical_in&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996, chapter 8.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;&#xa;    """"""&#xa;    if not (isscalar(n) and isscalar(z)):&#xa;        raise ValueError(""arguments must be scalars."")&#xa;    if (n != floor(n)) or (n < 0):&#xa;        raise ValueError(""n must be a non-negative integer."")&#xa;    if (n < 1):&#xa;        n1 = 1&#xa;    else:&#xa;        n1 = n&#xa;    if iscomplex(z):&#xa;        nm, In, Inp, kn, knp = specfun.csphik(n1, z)&#xa;    else:&#xa;        nm, In, Inp = specfun.sphi(n1, z)&#xa;    return In[:(n+1)], Inp[:(n+1)]&#xa;&#xa;&#xa;@np.deprecate(message=""scipy.special.sph_kn is deprecated in scipy 0.18.0. ""&#xa;                      ""Use scipy.special.spherical_kn instead. ""&#xa;                      ""Note that the new function has a different signature."")&#xa;def sph_kn(n, z):&#xa;    """"""Compute spherical Bessel function kn(z) and derivative.&#xa;&#xa;    This function computes the value and first derivative of kn(z) for all&#xa;    orders up to and including n.&#xa;&#xa;    Parameters&#xa;    ----------&#xa;    n : int&#xa;        Maximum order of kn to compute&#xa;    z : complex&#xa;        Argument at which to evaluate&#xa;&#xa;    Returns&#xa;    -------&#xa;    kn : ndarray&#xa;        Value of k0(z), ..., kn(z)&#xa;    knp : ndarray&#xa;        First derivative k0'(z), ..., kn'(z)&#xa;&#xa;    See also&#xa;    --------&#xa;    spherical_kn&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996, chapter 8.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;&#xa;    """"""&#xa;    if not (isscalar(n) and isscalar(z)):&#xa;        raise ValueError(""arguments must be scalars."")&#xa;    if (n != floor(n)) or (n < 0):&#xa;        raise ValueError(""n must be a non-negative integer."")&#xa;    if (n < 1):&#xa;        n1 = 1&#xa;    else:&#xa;        n1 = n&#xa;    if iscomplex(z) or less(z, 0):&#xa;        nm, In, Inp, kn, knp = specfun.csphik(n1, z)&#xa;    else:&#xa;        nm, kn, knp = specfun.sphk(n1, z)&#xa;    return kn[:(n+1)], knp[:(n+1)]&#xa;&#xa;&#xa;@np.deprecate(message=""scipy.special.sph_inkn is deprecated in scipy 0.18.0. ""&#xa;                      ""Use scipy.special.spherical_in and ""&#xa;                      ""scipy.special.spherical_kn instead. ""&#xa;                      ""Note that the new function has a different signature."")&#xa;def sph_inkn(n, z):&#xa;    """"""Compute spherical Bessel functions in(z), kn(z), and derivatives.&#xa;&#xa;    This function computes the value and first derivative of in(z) and kn(z)&#xa;    for all orders up to and including n.&#xa;&#xa;    Parameters&#xa;    ----------&#xa;    n : int&#xa;        Maximum order of in and kn to compute&#xa;    z : complex&#xa;        Argument at which to evaluate&#xa;&#xa;    Returns&#xa;    -------&#xa;    in : ndarray&#xa;        Value of i0(z), ..., in(z)&#xa;    inp : ndarray&#xa;        First derivative i0'(z), ..., in'(z)&#xa;    kn : ndarray&#xa;        Value of k0(z), ..., kn(z)&#xa;    knp : ndarray&#xa;        First derivative k0'(z), ..., kn'(z)&#xa;&#xa;    See also&#xa;    --------&#xa;    spherical_in&#xa;    spherical_kn&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996, chapter 8.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;&#xa;    """"""&#xa;    if not (isscalar(n) and isscalar(z)):&#xa;        raise ValueError(""arguments must be scalars."")&#xa;    if (n != floor(n)) or (n < 0):&#xa;        raise ValueError(""n must be a non-negative integer."")&#xa;    if (n < 1):&#xa;        n1 = 1&#xa;    else:&#xa;        n1 = n&#xa;    if iscomplex(z) or less(z, 0):&#xa;        nm, In, Inp, kn, knp = specfun.csphik(n1, z)&#xa;    else:&#xa;        nm, In, Inp = specfun.sphi(n1, z)&#xa;        nm, kn, knp = specfun.sphk(n1, z)&#xa;    return In[:(n+1)], Inp[:(n+1)], kn[:(n+1)], knp[:(n+1)]&#xa;&#xa;&#xa;def riccati_jn(n, x):&#xa;    r""""""Compute Ricatti-Bessel function of the first kind and its derivative.&#xa;&#xa;    The Ricatti-Bessel function of the first kind is defined as :math:`x&#xa;    j_n(x)`, where :math:`j_n` is the spherical Bessel function of the first&#xa;    kind of order :math:`n`.&#xa;&#xa;    This function computes the value and first derivative of the&#xa;    Ricatti-Bessel function for all orders up to and including `n`.&#xa;&#xa;    Parameters&#xa;    ----------&#xa;    n : int&#xa;        Maximum order of function to compute&#xa;    x : float&#xa;        Argument at which to evaluate&#xa;&#xa;    Returns&#xa;    -------&#xa;    jn : ndarray&#xa;        Value of j0(x), ..., jn(x)&#xa;    jnp : ndarray&#xa;        First derivative j0'(x), ..., jn'(x)&#xa;&#xa;    Notes&#xa;    -----&#xa;    The computation is carried out via backward recurrence, using the&#xa;    relation DLMF 10.51.1 [2]_.&#xa;&#xa;    Wrapper for a Fortran routine created by Shanjie Zhang and Jianming&#xa;    Jin [1]_.&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;    .. [2] NIST Digital Library of Mathematical Functions.&#xa;           http://dlmf.nist.gov/10.51.E1&#xa;&#xa;    """"""&#xa;    if not (isscalar(n) and isscalar(x)):&#xa;        raise ValueError(""arguments must be scalars."")&#xa;    if (n != floor(n)) or (n < 0):&#xa;        raise ValueError(""n must be a non-negative integer."")&#xa;    if (n == 0):&#xa;        n1 = 1&#xa;    else:&#xa;        n1 = n&#xa;    nm, jn, jnp = specfun.rctj(n1, x)&#xa;    return jn[:(n+1)], jnp[:(n+1)]&#xa;&#xa;&#xa;def riccati_yn(n, x):&#xa;    """"""Compute Ricatti-Bessel function of the second kind and its derivative.&#xa;&#xa;    The Ricatti-Bessel function of the second kind is defined as :math:`x&#xa;    y_n(x)`, where :math:`y_n` is the spherical Bessel function of the second&#xa;    kind of order :math:`n`.&#xa;&#xa;    This function computes the value and first derivative of the function for&#xa;    all orders up to and including `n`.&#xa;&#xa;    Parameters&#xa;    ----------&#xa;    n : int&#xa;        Maximum order of function to compute&#xa;    x : float&#xa;        Argument at which to evaluate&#xa;&#xa;    Returns&#xa;    -------&#xa;    yn : ndarray&#xa;        Value of y0(x), ..., yn(x)&#xa;    ynp : ndarray&#xa;        First derivative y0'(x), ..., yn'(x)&#xa;&#xa;    Notes&#xa;    -----&#xa;    The computation is carried out via ascending recurrence, using the&#xa;    relation DLMF 10.51.1 [2]_.&#xa;&#xa;    Wrapper for a Fortran routine created by Shanjie Zhang and Jianming&#xa;    Jin [1]_.&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;    .. [2] NIST Digital Library of Mathematical Functions.&#xa;           http://dlmf.nist.gov/10.51.E1&#xa;&#xa;    """"""&#xa;    if not (isscalar(n) and isscalar(x)):&#xa;        raise ValueError(""arguments must be scalars."")&#xa;    if (n != floor(n)) or (n < 0):&#xa;        raise ValueError(""n must be a non-negative integer."")&#xa;    if (n == 0):&#xa;        n1 = 1&#xa;    else:&#xa;        n1 = n&#xa;    nm, jn, jnp = specfun.rcty(n1, x)&#xa;    return jn[:(n+1)], jnp[:(n+1)]&#xa;&#xa;&#xa;def erfinv(y):&#xa;    """"""Inverse function for erf.&#xa;    """"""&#xa;    return ndtri((y+1)/2.0)/sqrt(2)&#xa;&#xa;&#xa;def erfcinv(y):&#xa;    """"""Inverse function for erfc.&#xa;    """"""&#xa;    return -ndtri(0.5*y)/sqrt(2)&#xa;&#xa;&#xa;def erf_zeros(nt):&#xa;    """"""Compute nt complex zeros of error function erf(z).&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;&#xa;    """"""&#xa;    if (floor(nt) != nt) or (nt <= 0) or not isscalar(nt):&#xa;        raise ValueError(""Argument must be positive scalar integer."")&#xa;    return specfun.cerzo(nt)&#xa;&#xa;&#xa;def fresnelc_zeros(nt):&#xa;    """"""Compute nt complex zeros of cosine Fresnel integral C(z).&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;&#xa;    """"""&#xa;    if (floor(nt) != nt) or (nt <= 0) or not isscalar(nt):&#xa;        raise ValueError(""Argument must be positive scalar integer."")&#xa;    return specfun.fcszo(1, nt)&#xa;&#xa;&#xa;def fresnels_zeros(nt):&#xa;    """"""Compute nt complex zeros of sine Fresnel integral S(z).&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;&#xa;    """"""&#xa;    if (floor(nt) != nt) or (nt <= 0) or not isscalar(nt):&#xa;        raise ValueError(""Argument must be positive scalar integer."")&#xa;    return specfun.fcszo(2, nt)&#xa;&#xa;&#xa;def fresnel_zeros(nt):&#xa;    """"""Compute nt complex zeros of sine and cosine Fresnel integrals S(z) and C(z).&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;&#xa;    """"""&#xa;    if (floor(nt) != nt) or (nt <= 0) or not isscalar(nt):&#xa;        raise ValueError(""Argument must be positive scalar integer."")&#xa;    return specfun.fcszo(2, nt), specfun.fcszo(1, nt)&#xa;&#xa;&#xa;def assoc_laguerre(x, n, k=0.0):&#xa;    """"""Compute the generalized (associated) Laguerre polynomial of degree n and order k.&#xa;&#xa;    The polynomial :math:`L^{(k)}_n(x)` is orthogonal over ``[0, inf)``,&#xa;    with weighting function ``exp(-x) * x**k`` with ``k > -1``.&#xa;&#xa;    Notes&#xa;    -----&#xa;    `assoc_laguerre` is a simple wrapper around `eval_genlaguerre`, with&#xa;    reversed argument order ``(x, n, k=0.0) --> (n, k, x)``.&#xa;&#xa;    """"""&#xa;    return orthogonal.eval_genlaguerre(n, k, x)&#xa;&#xa;digamma = psi&#xa;&#xa;&#xa;def polygamma(n, x):&#xa;    """"""Polygamma function n.&#xa;&#xa;    This is the nth derivative of the digamma (psi) function.&#xa;&#xa;    Parameters&#xa;    ----------&#xa;    n : array_like of int&#xa;        The order of the derivative of `psi`.&#xa;    x : array_like&#xa;        Where to evaluate the polygamma function.&#xa;&#xa;    Returns&#xa;    -------&#xa;    polygamma : ndarray&#xa;        The result.&#xa;&#xa;    Examples&#xa;    --------&#xa;    >>> from scipy import special&#xa;    >>> x = [2, 3, 25.5]&#xa;    >>> special.polygamma(1, x)&#xa;    array([ 0.64493407,  0.39493407,  0.03999467])&#xa;    >>> special.polygamma(0, x) == special.psi(x)&#xa;    array([ True,  True,  True], dtype=bool)&#xa;&#xa;    """"""&#xa;    n, x = asarray(n), asarray(x)&#xa;    fac2 = (-1.0)**(n+1) * gamma(n+1.0) * zeta(n+1, x)&#xa;    return where(n == 0, psi(x), fac2)&#xa;&#xa;&#xa;def mathieu_even_coef(m, q):&#xa;    r""""""Fourier coefficients for even Mathieu and modified Mathieu functions.&#xa;&#xa;    The Fourier series of the even solutions of the Mathieu differential&#xa;    equation are of the form&#xa;&#xa;    .. math:: \mathrm{ce}_{2n}(z, q) = \sum_{k=0}^{\infty} A_{(2n)}^{(2k)} \cos 2kz&#xa;&#xa;    .. math:: \mathrm{ce}_{2n+1}(z, q) = \sum_{k=0}^{\infty} A_{(2n+1)}^{(2k+1)} \cos (2k+1)z&#xa;&#xa;    This function returns the coefficients :math:`A_{(2n)}^{(2k)}` for even&#xa;    input m=2n, and the coefficients :math:`A_{(2n+1)}^{(2k+1)}` for odd input&#xa;    m=2n+1.&#xa;&#xa;    Parameters&#xa;    ----------&#xa;    m : int&#xa;        Order of Mathieu functions.  Must be non-negative.&#xa;    q : float (>=0)&#xa;        Parameter of Mathieu functions.  Must be non-negative.&#xa;&#xa;    Returns&#xa;    -------&#xa;    Ak : ndarray&#xa;        Even or odd Fourier coefficients, corresponding to even or odd m.&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;    .. [2] NIST Digital Library of Mathematical Functions&#xa;           http://dlmf.nist.gov/28.4#i&#xa;&#xa;    """"""&#xa;    if not (isscalar(m) and isscalar(q)):&#xa;        raise ValueError(""m and q must be scalars."")&#xa;    if (q < 0):&#xa;        raise ValueError(""q >=0"")&#xa;    if (m != floor(m)) or (m < 0):&#xa;        raise ValueError(""m must be an integer >=0."")&#xa;&#xa;    if (q <= 1):&#xa;        qm = 7.5 + 56.1*sqrt(q) - 134.7*q + 90.7*sqrt(q)*q&#xa;    else:&#xa;        qm = 17.0 + 3.1*sqrt(q) - .126*q + .0037*sqrt(q)*q&#xa;    km = int(qm + 0.5*m)&#xa;    if km > 251:&#xa;        print(""Warning, too many predicted coefficients."")&#xa;    kd = 1&#xa;    m = int(floor(m))&#xa;    if m % 2:&#xa;        kd = 2&#xa;&#xa;    a = mathieu_a(m, q)&#xa;    fc = specfun.fcoef(kd, m, q, a)&#xa;    return fc[:km]&#xa;&#xa;&#xa;def mathieu_odd_coef(m, q):&#xa;    r""""""Fourier coefficients for even Mathieu and modified Mathieu functions.&#xa;&#xa;    The Fourier series of the odd solutions of the Mathieu differential&#xa;    equation are of the form&#xa;&#xa;    .. math:: \mathrm{se}_{2n+1}(z, q) = \sum_{k=0}^{\infty} B_{(2n+1)}^{(2k+1)} \sin (2k+1)z&#xa;&#xa;    .. math:: \mathrm{se}_{2n+2}(z, q) = \sum_{k=0}^{\infty} B_{(2n+2)}^{(2k+2)} \sin (2k+2)z&#xa;&#xa;    This function returns the coefficients :math:`B_{(2n+2)}^{(2k+2)}` for even&#xa;    input m=2n+2, and the coefficients :math:`B_{(2n+1)}^{(2k+1)}` for odd&#xa;    input m=2n+1.&#xa;&#xa;    Parameters&#xa;    ----------&#xa;    m : int&#xa;        Order of Mathieu functions.  Must be non-negative.&#xa;    q : float (>=0)&#xa;        Parameter of Mathieu functions.  Must be non-negative.&#xa;&#xa;    Returns&#xa;    -------&#xa;    Bk : ndarray&#xa;        Even or odd Fourier coefficients, corresponding to even or odd m.&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;&#xa;    """"""&#xa;    if not (isscalar(m) and isscalar(q)):&#xa;        raise ValueError(""m and q must be scalars."")&#xa;    if (q < 0):&#xa;        raise ValueError(""q >=0"")&#xa;    if (m != floor(m)) or (m <= 0):&#xa;        raise ValueError(""m must be an integer > 0"")&#xa;&#xa;    if (q <= 1):&#xa;        qm = 7.5 + 56.1*sqrt(q) - 134.7*q + 90.7*sqrt(q)*q&#xa;    else:&#xa;        qm = 17.0 + 3.1*sqrt(q) - .126*q + .0037*sqrt(q)*q&#xa;    km = int(qm + 0.5*m)&#xa;    if km > 251:&#xa;        print(""Warning, too many predicted coefficients."")&#xa;    kd = 4&#xa;    m = int(floor(m))&#xa;    if m % 2:&#xa;        kd = 3&#xa;&#xa;    b = mathieu_b(m, q)&#xa;    fc = specfun.fcoef(kd, m, q, b)&#xa;    return fc[:km]&#xa;&#xa;&#xa;def lpmn(m, n, z):&#xa;    """"""Associated Legendre function of the first kind, Pmn(z).&#xa;&#xa;    Computes the associated Legendre function of the first kind of order m and&#xa;    degree n, ``Pmn(z)`` = :math:`P_n^m(z)`, and its derivative, ``Pmn'(z)``.&#xa;    Returns two arrays of size ``(m+1, n+1)`` containing ``Pmn(z)`` and&#xa;    ``Pmn'(z)`` for all orders from ``0..m`` and degrees from ``0..n``.&#xa;&#xa;    This function takes a real argument ``z``. For complex arguments ``z``&#xa;    use clpmn instead.&#xa;&#xa;    Parameters&#xa;    ----------&#xa;    m : int&#xa;       ``|m| <= n``; the order of the Legendre function.&#xa;    n : int&#xa;       where ``n >= 0``; the degree of the Legendre function.  Often&#xa;       called ``l`` (lower case L) in descriptions of the associated&#xa;       Legendre function&#xa;    z : float&#xa;        Input value.&#xa;&#xa;    Returns&#xa;    -------&#xa;    Pmn_z : (m+1, n+1) array&#xa;       Values for all orders 0..m and degrees 0..n&#xa;    Pmn_d_z : (m+1, n+1) array&#xa;       Derivatives for all orders 0..m and degrees 0..n&#xa;&#xa;    See Also&#xa;    --------&#xa;    clpmn: associated Legendre functions of the first kind for complex z&#xa;&#xa;    Notes&#xa;    -----&#xa;    In the interval (-1, 1), Ferrer's function of the first kind is&#xa;    returned. The phase convention used for the intervals (1, inf)&#xa;    and (-inf, -1) is such that the result is always real.&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;    .. [2] NIST Digital Library of Mathematical Functions&#xa;           http://dlmf.nist.gov/14.3&#xa;&#xa;    """"""&#xa;    if not isscalar(m) or (abs(m) > n):&#xa;        raise ValueError(""m must be <= n."")&#xa;    if not isscalar(n) or (n < 0):&#xa;        raise ValueError(""n must be a non-negative integer."")&#xa;    if not isscalar(z):&#xa;        raise ValueError(""z must be scalar."")&#xa;    if iscomplex(z):&#xa;        raise ValueError(""Argument must be real. Use clpmn instead."")&#xa;    if (m < 0):&#xa;        mp = -m&#xa;        mf, nf = mgrid[0:mp+1, 0:n+1]&#xa;        sv = errprint(0)&#xa;        if abs(z) < 1:&#xa;            # Ferrer function; DLMF 14.9.3&#xa;            fixarr = where(mf > nf, 0.0,&#xa;                           (-1)**mf * gamma(nf-mf+1) / gamma(nf+mf+1))&#xa;        else:&#xa;            # Match to clpmn; DLMF 14.9.13&#xa;            fixarr = where(mf > nf, 0.0, gamma(nf-mf+1) / gamma(nf+mf+1))&#xa;        sv = errprint(sv)&#xa;    else:&#xa;        mp = m&#xa;    p, pd = specfun.lpmn(mp, n, z)&#xa;    if (m < 0):&#xa;        p = p * fixarr&#xa;        pd = pd * fixarr&#xa;    return p, pd&#xa;&#xa;&#xa;def clpmn(m, n, z, type=3):&#xa;    """"""Associated Legendre function of the first kind, Pmn(z).&#xa;&#xa;    Computes the associated Legendre function of the first kind of order m and&#xa;    degree n, ``Pmn(z)`` = :math:`P_n^m(z)`, and its derivative, ``Pmn'(z)``.&#xa;    Returns two arrays of size ``(m+1, n+1)`` containing ``Pmn(z)`` and&#xa;    ``Pmn'(z)`` for all orders from ``0..m`` and degrees from ``0..n``.&#xa;&#xa;    Parameters&#xa;    ----------&#xa;    m : int&#xa;       ``|m| <= n``; the order of the Legendre function.&#xa;    n : int&#xa;       where ``n >= 0``; the degree of the Legendre function.  Often&#xa;       called ``l`` (lower case L) in descriptions of the associated&#xa;       Legendre function&#xa;    z : float or complex&#xa;        Input value.&#xa;    type : int, optional&#xa;       takes values 2 or 3&#xa;       2: cut on the real axis ``|x| > 1``&#xa;       3: cut on the real axis ``-1 < x < 1`` (default)&#xa;&#xa;    Returns&#xa;    -------&#xa;    Pmn_z : (m+1, n+1) array&#xa;       Values for all orders ``0..m`` and degrees ``0..n``&#xa;    Pmn_d_z : (m+1, n+1) array&#xa;       Derivatives for all orders ``0..m`` and degrees ``0..n``&#xa;&#xa;    See Also&#xa;    --------&#xa;    lpmn: associated Legendre functions of the first kind for real z&#xa;&#xa;    Notes&#xa;    -----&#xa;    By default, i.e. for ``type=3``, phase conventions are chosen according&#xa;    to [1]_ such that the function is analytic. The cut lies on the interval&#xa;    (-1, 1). Approaching the cut from above or below in general yields a phase&#xa;    factor with respect to Ferrer's function of the first kind&#xa;    (cf. `lpmn`).&#xa;&#xa;    For ``type=2`` a cut at ``|x| > 1`` is chosen. Approaching the real values&#xa;    on the interval (-1, 1) in the complex plane yields Ferrer's function&#xa;    of the first kind.&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;    .. [2] NIST Digital Library of Mathematical Functions&#xa;           http://dlmf.nist.gov/14.21&#xa;&#xa;    """"""&#xa;    if not isscalar(m) or (abs(m) > n):&#xa;        raise ValueError(""m must be <= n."")&#xa;    if not isscalar(n) or (n < 0):&#xa;        raise ValueError(""n must be a non-negative integer."")&#xa;    if not isscalar(z):&#xa;        raise ValueError(""z must be scalar."")&#xa;    if not(type == 2 or type == 3):&#xa;        raise ValueError(""type must be either 2 or 3."")&#xa;    if (m < 0):&#xa;        mp = -m&#xa;        mf, nf = mgrid[0:mp+1, 0:n+1]&#xa;        sv = errprint(0)&#xa;        if type == 2:&#xa;            fixarr = where(mf > nf, 0.0,&#xa;                           (-1)**mf * gamma(nf-mf+1) / gamma(nf+mf+1))&#xa;        else:&#xa;            fixarr = where(mf > nf, 0.0, gamma(nf-mf+1) / gamma(nf+mf+1))&#xa;        sv = errprint(sv)&#xa;    else:&#xa;        mp = m&#xa;    p, pd = specfun.clpmn(mp, n, real(z), imag(z), type)&#xa;    if (m < 0):&#xa;        p = p * fixarr&#xa;        pd = pd * fixarr&#xa;    return p, pd&#xa;&#xa;&#xa;def lqmn(m, n, z):&#xa;    """"""Associated Legendre function of the second kind, Qmn(z).&#xa;&#xa;    Computes the associated Legendre function of the second kind of order m and&#xa;    degree n, ``Qmn(z)`` = :math:`Q_n^m(z)`, and its derivative, ``Qmn'(z)``.&#xa;    Returns two arrays of size ``(m+1, n+1)`` containing ``Qmn(z)`` and&#xa;    ``Qmn'(z)`` for all orders from ``0..m`` and degrees from ``0..n``.&#xa;&#xa;    Parameters&#xa;    ----------&#xa;    m : int&#xa;       ``|m| <= n``; the order of the Legendre function.&#xa;    n : int&#xa;       where ``n >= 0``; the degree of the Legendre function.  Often&#xa;       called ``l`` (lower case L) in descriptions of the associated&#xa;       Legendre function&#xa;    z : complex&#xa;        Input value.&#xa;&#xa;    Returns&#xa;    -------&#xa;    Qmn_z : (m+1, n+1) array&#xa;       Values for all orders 0..m and degrees 0..n&#xa;    Qmn_d_z : (m+1, n+1) array&#xa;       Derivatives for all orders 0..m and degrees 0..n&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;&#xa;    """"""&#xa;    if not isscalar(m) or (m < 0):&#xa;        raise ValueError(""m must be a non-negative integer."")&#xa;    if not isscalar(n) or (n < 0):&#xa;        raise ValueError(""n must be a non-negative integer."")&#xa;    if not isscalar(z):&#xa;        raise ValueError(""z must be scalar."")&#xa;    m = int(m)&#xa;    n = int(n)&#xa;&#xa;    # Ensure neither m nor n == 0&#xa;    mm = max(1, m)&#xa;    nn = max(1, n)&#xa;&#xa;    if iscomplex(z):&#xa;        q, qd = specfun.clqmn(mm, nn, z)&#xa;    else:&#xa;        q, qd = specfun.lqmn(mm, nn, z)&#xa;    return q[:(m+1), :(n+1)], qd[:(m+1), :(n+1)]&#xa;&#xa;&#xa;def bernoulli(n):&#xa;    """"""Bernoulli numbers B0..Bn (inclusive).&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;&#xa;    """"""&#xa;    if not isscalar(n) or (n < 0):&#xa;        raise ValueError(""n must be a non-negative integer."")&#xa;    n = int(n)&#xa;    if (n < 2):&#xa;        n1 = 2&#xa;    else:&#xa;        n1 = n&#xa;    return specfun.bernob(int(n1))[:(n+1)]&#xa;&#xa;&#xa;def euler(n):&#xa;    """"""Euler numbers E0..En (inclusive).&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;&#xa;    """"""&#xa;    if not isscalar(n) or (n < 0):&#xa;        raise ValueError(""n must be a non-negative integer."")&#xa;    n = int(n)&#xa;    if (n < 2):&#xa;        n1 = 2&#xa;    else:&#xa;        n1 = n&#xa;    return specfun.eulerb(n1)[:(n+1)]&#xa;&#xa;&#xa;def lpn(n, z):&#xa;    """"""Legendre functions of the first kind, Pn(z).&#xa;&#xa;    Compute sequence of Legendre functions of the first kind (polynomials),&#xa;    Pn(z) and derivatives for all degrees from 0 to n (inclusive).&#xa;&#xa;    See also special.legendre for polynomial class.&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;&#xa;    """"""&#xa;    if not (isscalar(n) and isscalar(z)):&#xa;        raise ValueError(""arguments must be scalars."")&#xa;    if (n != floor(n)) or (n < 0):&#xa;        raise ValueError(""n must be a non-negative integer."")&#xa;    if (n < 1):&#xa;        n1 = 1&#xa;    else:&#xa;        n1 = n&#xa;    if iscomplex(z):&#xa;        pn, pd = specfun.clpn(n1, z)&#xa;    else:&#xa;        pn, pd = specfun.lpn(n1, z)&#xa;    return pn[:(n+1)], pd[:(n+1)]&#xa;&#xa;&#xa;def lqn(n, z):&#xa;    """"""Legendre functions of the second kind, Qn(z).&#xa;&#xa;    Compute sequence of Legendre functions of the second kind, Qn(z) and&#xa;    derivatives for all degrees from 0 to n (inclusive).&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;&#xa;    """"""&#xa;    if not (isscalar(n) and isscalar(z)):&#xa;        raise ValueError(""arguments must be scalars."")&#xa;    if (n != floor(n)) or (n < 0):&#xa;        raise ValueError(""n must be a non-negative integer."")&#xa;    if (n < 1):&#xa;        n1 = 1&#xa;    else:&#xa;        n1 = n&#xa;    if iscomplex(z):&#xa;        qn, qd = specfun.clqn(n1, z)&#xa;    else:&#xa;        qn, qd = specfun.lqnb(n1, z)&#xa;    return qn[:(n+1)], qd[:(n+1)]&#xa;&#xa;&#xa;def ai_zeros(nt):&#xa;    """"""&#xa;    Compute `nt` zeros and values of the Airy function Ai and its derivative.&#xa;&#xa;    Computes the first `nt` zeros, `a`, of the Airy function Ai(x);&#xa;    first `nt` zeros, `ap`, of the derivative of the Airy function Ai'(x);&#xa;    the corresponding values Ai(a');&#xa;    and the corresponding values Ai'(a).&#xa;&#xa;    Parameters&#xa;    ----------&#xa;    nt : int&#xa;        Number of zeros to compute&#xa;&#xa;    Returns&#xa;    -------&#xa;    a : ndarray&#xa;        First `nt` zeros of Ai(x)&#xa;    ap : ndarray&#xa;        First `nt` zeros of Ai'(x)&#xa;    ai : ndarray&#xa;        Values of Ai(x) evaluated at first `nt` zeros of Ai'(x)&#xa;    aip : ndarray&#xa;        Values of Ai'(x) evaluated at first `nt` zeros of Ai(x)&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;&#xa;    """"""&#xa;    kf = 1&#xa;    if not isscalar(nt) or (floor(nt) != nt) or (nt <= 0):&#xa;        raise ValueError(""nt must be a positive integer scalar."")&#xa;    return specfun.airyzo(nt, kf)&#xa;&#xa;&#xa;def bi_zeros(nt):&#xa;    """"""&#xa;    Compute `nt` zeros and values of the Airy function Bi and its derivative.&#xa;&#xa;    Computes the first `nt` zeros, b, of the Airy function Bi(x);&#xa;    first `nt` zeros, b', of the derivative of the Airy function Bi'(x);&#xa;    the corresponding values Bi(b');&#xa;    and the corresponding values Bi'(b).&#xa;&#xa;    Parameters&#xa;    ----------&#xa;    nt : int&#xa;        Number of zeros to compute&#xa;&#xa;    Returns&#xa;    -------&#xa;    b : ndarray&#xa;        First `nt` zeros of Bi(x)&#xa;    bp : ndarray&#xa;        First `nt` zeros of Bi'(x)&#xa;    bi : ndarray&#xa;        Values of Bi(x) evaluated at first `nt` zeros of Bi'(x)&#xa;    bip : ndarray&#xa;        Values of Bi'(x) evaluated at first `nt` zeros of Bi(x)&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;&#xa;    """"""&#xa;    kf = 2&#xa;    if not isscalar(nt) or (floor(nt) != nt) or (nt <= 0):&#xa;        raise ValueError(""nt must be a positive integer scalar."")&#xa;    return specfun.airyzo(nt, kf)&#xa;&#xa;&#xa;def lmbda(v, x):&#xa;    r""""""Jahnke-Emden Lambda function, Lambdav(x).&#xa;&#xa;    This function is defined as [2]_,&#xa;&#xa;    .. math:: \Lambda_v(x) = \Gamma(v+1) \frac{J_v(x)}{(x/2)^v},&#xa;&#xa;    where :math:`\Gamma` is the gamma function and :math:`J_v` is the&#xa;    Bessel function of the first kind.&#xa;&#xa;    Parameters&#xa;    ----------&#xa;    v : float&#xa;        Order of the Lambda function&#xa;    x : float&#xa;        Value at which to evaluate the function and derivatives&#xa;&#xa;    Returns&#xa;    -------&#xa;    vl : ndarray&#xa;        Values of Lambda_vi(x), for vi=v-int(v), vi=1+v-int(v), ..., vi=v.&#xa;    dl : ndarray&#xa;        Derivatives Lambda_vi'(x), for vi=v-int(v), vi=1+v-int(v), ..., vi=v.&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;    .. [2] Jahnke, E. and Emde, F. ""Tables of Functions with Formulae and&#xa;           Curves"" (4th ed.), Dover, 1945&#xa;    """"""&#xa;    if not (isscalar(v) and isscalar(x)):&#xa;        raise ValueError(""arguments must be scalars."")&#xa;    if (v < 0):&#xa;        raise ValueError(""argument must be > 0."")&#xa;    n = int(v)&#xa;    v0 = v - n&#xa;    if (n < 1):&#xa;        n1 = 1&#xa;    else:&#xa;        n1 = n&#xa;    v1 = n1 + v0&#xa;    if (v != floor(v)):&#xa;        vm, vl, dl = specfun.lamv(v1, x)&#xa;    else:&#xa;        vm, vl, dl = specfun.lamn(v1, x)&#xa;    return vl[:(n+1)], dl[:(n+1)]&#xa;&#xa;&#xa;def pbdv_seq(v, x):&#xa;    """"""Parabolic cylinder functions Dv(x) and derivatives.&#xa;&#xa;    Parameters&#xa;    ----------&#xa;    v : float&#xa;        Order of the parabolic cylinder function&#xa;    x : float&#xa;        Value at which to evaluate the function and derivatives&#xa;&#xa;    Returns&#xa;    -------&#xa;    dv : ndarray&#xa;        Values of D_vi(x), for vi=v-int(v), vi=1+v-int(v), ..., vi=v.&#xa;    dp : ndarray&#xa;        Derivatives D_vi'(x), for vi=v-int(v), vi=1+v-int(v), ..., vi=v.&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996, chapter 13.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;&#xa;    """"""&#xa;    if not (isscalar(v) and isscalar(x)):&#xa;        raise ValueError(""arguments must be scalars."")&#xa;    n = int(v)&#xa;    v0 = v-n&#xa;    if (n < 1):&#xa;        n1 = 1&#xa;    else:&#xa;        n1 = n&#xa;    v1 = n1 + v0&#xa;    dv, dp, pdf, pdd = specfun.pbdv(v1, x)&#xa;    return dv[:n1+1], dp[:n1+1]&#xa;&#xa;&#xa;def pbvv_seq(v, x):&#xa;    """"""Parabolic cylinder functions Vv(x) and derivatives.&#xa;&#xa;    Parameters&#xa;    ----------&#xa;    v : float&#xa;        Order of the parabolic cylinder function&#xa;    x : float&#xa;        Value at which to evaluate the function and derivatives&#xa;&#xa;    Returns&#xa;    -------&#xa;    dv : ndarray&#xa;        Values of V_vi(x), for vi=v-int(v), vi=1+v-int(v), ..., vi=v.&#xa;    dp : ndarray&#xa;        Derivatives V_vi'(x), for vi=v-int(v), vi=1+v-int(v), ..., vi=v.&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996, chapter 13.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;&#xa;    """"""&#xa;    if not (isscalar(v) and isscalar(x)):&#xa;        raise ValueError(""arguments must be scalars."")&#xa;    n = int(v)&#xa;    v0 = v-n&#xa;    if (n <= 1):&#xa;        n1 = 1&#xa;    else:&#xa;        n1 = n&#xa;    v1 = n1 + v0&#xa;    dv, dp, pdf, pdd = specfun.pbvv(v1, x)&#xa;    return dv[:n1+1], dp[:n1+1]&#xa;&#xa;&#xa;def pbdn_seq(n, z):&#xa;    """"""Parabolic cylinder functions Dn(z) and derivatives.&#xa;&#xa;    Parameters&#xa;    ----------&#xa;    n : int&#xa;        Order of the parabolic cylinder function&#xa;    z : complex&#xa;        Value at which to evaluate the function and derivatives&#xa;&#xa;    Returns&#xa;    -------&#xa;    dv : ndarray&#xa;        Values of D_i(z), for i=0, ..., i=n.&#xa;    dp : ndarray&#xa;        Derivatives D_i'(z), for i=0, ..., i=n.&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996, chapter 13.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;&#xa;    """"""&#xa;    if not (isscalar(n) and isscalar(z)):&#xa;        raise ValueError(""arguments must be scalars."")&#xa;    if (floor(n) != n):&#xa;        raise ValueError(""n must be an integer."")&#xa;    if (abs(n) <= 1):&#xa;        n1 = 1&#xa;    else:&#xa;        n1 = n&#xa;    cpb, cpd = specfun.cpbdn(n1, z)&#xa;    return cpb[:n1+1], cpd[:n1+1]&#xa;&#xa;&#xa;def ber_zeros(nt):&#xa;    """"""Compute nt zeros of the Kelvin function ber(x).&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;&#xa;    """"""&#xa;    if not isscalar(nt) or (floor(nt) != nt) or (nt <= 0):&#xa;        raise ValueError(""nt must be positive integer scalar."")&#xa;    return specfun.klvnzo(nt, 1)&#xa;&#xa;&#xa;def bei_zeros(nt):&#xa;    """"""Compute nt zeros of the Kelvin function bei(x).&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;&#xa;    """"""&#xa;    if not isscalar(nt) or (floor(nt) != nt) or (nt <= 0):&#xa;        raise ValueError(""nt must be positive integer scalar."")&#xa;    return specfun.klvnzo(nt, 2)&#xa;&#xa;&#xa;def ker_zeros(nt):&#xa;    """"""Compute nt zeros of the Kelvin function ker(x).&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;&#xa;    """"""&#xa;    if not isscalar(nt) or (floor(nt) != nt) or (nt <= 0):&#xa;        raise ValueError(""nt must be positive integer scalar."")&#xa;    return specfun.klvnzo(nt, 3)&#xa;&#xa;&#xa;def kei_zeros(nt):&#xa;    """"""Compute nt zeros of the Kelvin function kei(x).&#xa;    """"""&#xa;    if not isscalar(nt) or (floor(nt) != nt) or (nt <= 0):&#xa;        raise ValueError(""nt must be positive integer scalar."")&#xa;    return specfun.klvnzo(nt, 4)&#xa;&#xa;&#xa;def berp_zeros(nt):&#xa;    """"""Compute nt zeros of the Kelvin function ber'(x).&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;&#xa;    """"""&#xa;    if not isscalar(nt) or (floor(nt) != nt) or (nt <= 0):&#xa;        raise ValueError(""nt must be positive integer scalar."")&#xa;    return specfun.klvnzo(nt, 5)&#xa;&#xa;&#xa;def beip_zeros(nt):&#xa;    """"""Compute nt zeros of the Kelvin function bei'(x).&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;&#xa;    """"""&#xa;    if not isscalar(nt) or (floor(nt) != nt) or (nt <= 0):&#xa;        raise ValueError(""nt must be positive integer scalar."")&#xa;    return specfun.klvnzo(nt, 6)&#xa;&#xa;&#xa;def kerp_zeros(nt):&#xa;    """"""Compute nt zeros of the Kelvin function ker'(x).&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;&#xa;    """"""&#xa;    if not isscalar(nt) or (floor(nt) != nt) or (nt <= 0):&#xa;        raise ValueError(""nt must be positive integer scalar."")&#xa;    return specfun.klvnzo(nt, 7)&#xa;&#xa;&#xa;def keip_zeros(nt):&#xa;    """"""Compute nt zeros of the Kelvin function kei'(x).&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;&#xa;    """"""&#xa;    if not isscalar(nt) or (floor(nt) != nt) or (nt <= 0):&#xa;        raise ValueError(""nt must be positive integer scalar."")&#xa;    return specfun.klvnzo(nt, 8)&#xa;&#xa;&#xa;def kelvin_zeros(nt):&#xa;    """"""Compute nt zeros of all Kelvin functions.&#xa;&#xa;    Returned in a length-8 tuple of arrays of length nt.  The tuple contains&#xa;    the arrays of zeros of (ber, bei, ker, kei, ber', bei', ker', kei').&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;&#xa;    """"""&#xa;    if not isscalar(nt) or (floor(nt) != nt) or (nt <= 0):&#xa;        raise ValueError(""nt must be positive integer scalar."")&#xa;    return (specfun.klvnzo(nt, 1),&#xa;            specfun.klvnzo(nt, 2),&#xa;            specfun.klvnzo(nt, 3),&#xa;            specfun.klvnzo(nt, 4),&#xa;            specfun.klvnzo(nt, 5),&#xa;            specfun.klvnzo(nt, 6),&#xa;            specfun.klvnzo(nt, 7),&#xa;            specfun.klvnzo(nt, 8))&#xa;&#xa;&#xa;def pro_cv_seq(m, n, c):&#xa;    """"""Characteristic values for prolate spheroidal wave functions.&#xa;&#xa;    Compute a sequence of characteristic values for the prolate&#xa;    spheroidal wave functions for mode m and n'=m..n and spheroidal&#xa;    parameter c.&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;&#xa;    """"""&#xa;    if not (isscalar(m) and isscalar(n) and isscalar(c)):&#xa;        raise ValueError(""Arguments must be scalars."")&#xa;    if (n != floor(n)) or (m != floor(m)):&#xa;        raise ValueError(""Modes must be integers."")&#xa;    if (n-m > 199):&#xa;        raise ValueError(""Difference between n and m is too large."")&#xa;    maxL = n-m+1&#xa;    return specfun.segv(m, n, c, 1)[1][:maxL]&#xa;&#xa;&#xa;def obl_cv_seq(m, n, c):&#xa;    """"""Characteristic values for oblate spheroidal wave functions.&#xa;&#xa;    Compute a sequence of characteristic values for the oblate&#xa;    spheroidal wave functions for mode m and n'=m..n and spheroidal&#xa;    parameter c.&#xa;&#xa;    References&#xa;    ----------&#xa;    .. [1] Zhang, Shanjie and Jin, Jianming. ""Computation of Special&#xa;           Functions"", John Wiley and Sons, 1996.&#xa;           http://jin.ece.illinois.edu/specfunc.html&#xa;&#xa;    """"""&#xa;    if not (isscalar(m) and isscalar(n) and isscalar(c)):&#xa;        raise ValueError(""Arguments must be scalars."")&#xa;    if (n != floor(n)) or (m != floor(m)):&#xa;        raise ValueError(""Modes must be integers."")&#xa;    if (n-m > 199):&#xa;        raise ValueError(""Difference between n and m is too large."")&#xa;    maxL = n-m+1&#xa;    return specfun.segv(m, n, c, -1)[1][:maxL]&#xa;&#xa;&#xa;def ellipk(m):&#xa;    """"""Complete elliptic integral of the first kind.&#xa;&#xa;    This function is defined as&#xa;&#xa;    .. math:: K(m) = \\int_0^{\\pi/2} [1 - m \\sin(t)^2]^{-1/2} dt&#xa;&#xa;    Parameters&#xa;    ----------&#xa;    m : array_like&#xa;        The parameter of the elliptic integral.&#xa;&#xa;    Returns&#xa;    -------&#xa;    K : array_like&#xa;        Value of the elliptic integral.&#xa;&#xa;    Notes&#xa;    -----&#xa;    For more precision around point m = 1, use `ellipkm1`, which this&#xa;    function calls.&#xa;&#xa;    See Also&#xa;    --------&#xa;    ellipkm1 : Complete elliptic integral of the first kind around m = 1&#xa;    ellipkinc : Incomplete elliptic integral of the first kind&#xa;    ellipe : Complete elliptic integral of the second kind&#xa;    ellipeinc : Incomplete elliptic integral of the second kind&#xa;&#xa;&#xa;    """"""&#xa;    return ellipkm1(1 - asarray(m))&#xa;&#xa;&#xa;def agm(a, b):&#xa;    """"""Arithmetic, Geometric Mean.&#xa;&#xa;    Start with a_0=a and b_0=b and iteratively compute&#xa;&#xa;    a_{n+1} = (a_n+b_n)/2&#xa;    b_{n+1} = sqrt(a_n*b_n)&#xa;&#xa;    until a_n=b_n.   The result is agm(a, b)&#xa;&#xa;    agm(a, b)=agm(b, a)&#xa;    agm(a, a) = a&#xa;    min(a, b) < agm(a, b) < max(a, b)&#xa;    """"""&#xa;    s = a + b + 0.0&#xa;    return (pi / 4) * s / ellipkm1(4 * a * b / s ** 2)&#xa;&#xa;&#xa;def comb(N, k, exact=False, repetition=False):&#xa;    """"""The number of combinations of N things taken k at a time.&#xa;&#xa;    This is often expressed as ""N choose k"".&#xa;&#xa;    Parameters&#xa;    ----------&#xa;    N : int, ndarray&#xa;        Number of things.&#xa;    k : int, ndarray&#xa;        Number of elements taken.&#xa;    exact : bool, optional&#xa;        If `exact` is False, then floating point precision is used, otherwise&#xa;        exact long integer is computed.&#xa;    repetition : bool, optional&#xa;        If `repetition` is True, then the number of combinations with&#xa;        repetition is computed.&#xa;&#xa;    Returns&#xa;    -------&#xa;    val : int, ndarray&#xa;        The total number of combinations.&#xa;&#xa;    Notes&#xa;    -----&#xa;    - Array arguments accepted only for exact=False case.&#xa;    - If k > N, N < 0, or k < 0, then a 0 is returned.&#xa;&#xa;    Examples&#xa;    --------&#xa;    >>> from scipy.special import comb&#xa;    >>> k = np.array([3, 4])&#xa;    >>> n = np.array([10, 10])&#xa;    >>> comb(n, k, exact=False)&#xa;    array([ 120.,  210.])&#xa;    >>> comb(10, 3, exact=True)&#xa;    120L&#xa;    >>> comb(10, 3, exact=True, repetition=True)&#xa;    220L&#xa;&#xa;    """"""&#xa;    if repetition:&#xa;        return comb(N + k - 1, k, exact)&#xa;    if exact:&#xa;        return _comb_int(N, k)&#xa;    else:&#xa;        k, N = asarray(k), asarray(N)&#xa;        cond = (k <= N) & (N >= 0) & (k >= 0)&#xa;        vals = binom(N, k)&#xa;        if isinstance(vals, np.ndarray):&#xa;            vals[~cond] = 0&#xa;        elif not cond:&#xa;            vals = np.float64(0)&#xa;        return vals&#xa;&#xa;&#xa;def perm(N, k, exact=False):&#xa;    """"""Permutations of N things taken k at a time, i.e., k-permutations of N.&#xa;&#xa;    It's also known as ""partial permutations"".&#xa;&#xa;    Parameters&#xa;    ----------&#xa;    N : int, ndarray&#xa;        Number of things.&#xa;    k : int, ndarray&#xa;        Number of elements taken.&#xa;    exact : bool, optional&#xa;        If `exact` is False, then floating point precision is used, otherwise&#xa;        exact long integer is computed.&#xa;&#xa;    Returns&#xa;    -------&#xa;    val : int, ndarray&#xa;        The number of k-permutations of N.&#xa;&#xa;    Notes&#xa;    -----&#xa;    - Array arguments accepted only for exact=False case.&#xa;    - If k > N, N < 0, or k < 0, then a 0 is returned.&#xa;&#xa;    Examples&#xa;    --------&#xa;    >>> from scipy.special import perm&#xa;    >>> k = np.array([3, 4])&#xa;    >>> n = np.array([10, 10])&#xa;    >>> perm(n, k)&#xa;    array([  720.,  5040.])&#xa;    >>> perm(10, 3, exact=True)&#xa;    720&#xa;&#xa;    """"""&#xa;    if exact:&#xa;        if (k > N) or (N < 0) or (k < 0):&#xa;            return 0&#xa;        val = 1&#xa;        for i in xrange(N - k + 1, N + 1):&#xa;            val *= i&#xa;        return val&#xa;    else:&#xa;        k, N = asarray(k), asarray(N)&#xa;        cond = (k <= N) & (N >= 0) & (k >= 0)&#xa;        vals = poch(N - k + 1, k)&#xa;        if isinstance(vals, np.ndarray):&#xa;            vals[~cond] = 0&#xa;        elif not cond:&#xa;            vals = np.float64(0)&#xa;        return vals&#xa;&#xa;&#xa;# http://stackoverflow.com/a/16327037/125507&#xa;def _range_prod(lo, hi):&#xa;    """"""&#xa;    Product of a range of numbers.&#xa;&#xa;    Returns the product of&#xa;    lo * (lo+1) * (lo+2) * ... * (hi-2) * (hi-1) * hi&#xa;    = hi! / (lo-1)!&#xa;&#xa;    Breaks into smaller products first for speed:&#xa;    _range_prod(2, 9) = ((2*3)*(4*5))*((6*7)*(8*9))&#xa;    """"""&#xa;    if lo + 1 < hi:&#xa;        mid = (hi + lo) // 2&#xa;        return _range_prod(lo, mid) * _range_prod(mid + 1, hi)&#xa;    if lo == hi:&#xa;        return lo&#xa;    return lo * hi&#xa;&#xa;&#xa;def factorial(n, exact=False):&#xa;    """"""&#xa;    The factorial of a number or array of numbers.&#xa;&#xa;    The factorial of non-negative integer `n` is the product of all&#xa;    positive integers less than or equal to `n`::&#xa;&#xa;        n! = n * (n - 1) * (n - 2) * ... * 1&#xa;&#xa;    Parameters&#xa;    ----------&#xa;    n : int or array_like of ints&#xa;        Input values.  If ``n < 0``, the return value is 0.&#xa;    exact : bool, optional&#xa;        If True, calculate the answer exactly using long integer arithmetic.&#xa;        If False, result is approximated in floating point rapidly using the&#xa;        `gamma` function.&#xa;        Default is False.&#xa;&#xa;    Returns&#xa;    -------&#xa;    nf : float or int or ndarray&#xa;        Factorial of `n`, as integer or float depending on `exact`.&#xa;&#xa;    Notes&#xa;    -----&#xa;    For arrays with ``exact=True``, the factorial is computed only once, for&#xa;    the largest input, with each other result computed in the process.&#xa;    The output dtype is increased to ``int64`` or ``object`` if necessary.&#xa;&#xa;    With ``exact=False`` the factorial is approximated using the gamma&#xa;    function:&#xa;&#xa;    .. math:: n! = \Gamma(n+1)&#xa;&#xa;    Examples&#xa;    --------&#xa;    >>> from scipy.special import factorial&#xa;    >>> arr = np.array([3, 4, 5])&#xa;    >>> factorial(arr, exact=False)&#xa;    array([   6.,   24.,  120.])&#xa;    >>> factorial(arr, exact=True)&#xa;    array([  6,  24, 120])&#xa;    >>> factorial(5, exact=True)&#xa;    120L&#xa;&#xa;    """"""&#xa;    if exact:&#xa;        if np.ndim(n) == 0:&#xa;            return 0 if n < 0 else math.factorial(n)&#xa;        else:&#xa;            n = asarray(n)&#xa;            un = np.unique(n).astype(object)&#xa;&#xa;            # Convert to object array of long ints if np.int can't handle size&#xa;            if un[-1] > 20:&#xa;                dt = object&#xa;            elif un[-1] > 12:&#xa;                dt = np.int64&#xa;            else:&#xa;                dt = np.int&#xa;&#xa;            out = np.empty_like(n, dtype=dt)&#xa;&#xa;            # Handle invalid/trivial values&#xa;            un = un[un > 1]&#xa;            out[n < 2] = 1&#xa;            out[n < 0] = 0&#xa;&#xa;            # Calculate products of each range of numbers&#xa;            if un.size:&#xa;                val = math.factorial(un[0])&#xa;                out[n == un[0]] = val&#xa;                for i in xrange(len(un) - 1):&#xa;                    prev = un[i] + 1&#xa;                    current = un[i + 1]&#xa;                    val *= _range_prod(prev, current)&#xa;                    out[n == current] = val&#xa;            return out&#xa;    else:&#xa;        n = asarray(n)&#xa;        vals = gamma(n + 1)&#xa;        return where(n >= 0, vals, 0)&#xa;&#xa;&#xa;def factorial2(n, exact=False):&#xa;    """"""Double factorial.&#xa;&#xa;    This is the factorial with every second value skipped.  E.g., ``7!! = 7 * 5&#xa;    * 3 * 1``.  It can be approximated numerically as::&#xa;&#xa;      n!! = special.gamma(n/2+1)*2**((m+1)/2)/sqrt(pi)  n odd&#xa;          = 2**(n/2) * (n/2)!                           n even&#xa;&#xa;    Parameters&#xa;    ----------&#xa;    n : int or array_like&#xa;        Calculate ``n!!``.  Arrays are only supported with `exact` set&#xa;        to False.  If ``n < 0``, the return value is 0.&#xa;    exact : bool, optional&#xa;        The result can be approximated rapidly using the gamma-formula&#xa;        above (default).  If `exact` is set to True, calculate the&#xa;        answer exactly using integer arithmetic.&#xa;&#xa;    Returns&#xa;    -------&#xa;    nff : float or int&#xa;        Double factorial of `n`, as an int or a float depending on&#xa;        `exact`.&#xa;&#xa;    Examples&#xa;    --------&#xa;    >>> from scipy.special import factorial2&#xa;    >>> factorial2(7, exact=False)&#xa;    array(105.00000000000001)&#xa;    >>> factorial2(7, exact=True)&#xa;    105L&#xa;&#xa;    """"""&#xa;    if exact:&#xa;        if n < -1:&#xa;            return 0&#xa;        if n <= 0:&#xa;            return 1&#xa;        val = 1&#xa;        for k in xrange(n, 0, -2):&#xa;            val *= k&#xa;        return val&#xa;    else:&#xa;        n = asarray(n)&#xa;        vals = zeros(n.shape, 'd')&#xa;        cond1 = (n % 2) & (n >= -1)&#xa;        cond2 = (1-(n % 2)) & (n >= -1)&#xa;        oddn = extract(cond1, n)&#xa;        evenn = extract(cond2, n)&#xa;        nd2o = oddn / 2.0&#xa;        nd2e = evenn / 2.0&#xa;        place(vals, cond1, gamma(nd2o + 1) / sqrt(pi) * pow(2.0, nd2o + 0.5))&#xa;        place(vals, cond2, gamma(nd2e + 1) * pow(2.0, nd2e))&#xa;        return vals&#xa;&#xa;&#xa;def factorialk(n, k, exact=True):&#xa;    """"""Multifactorial of n of order k, n(!!...!).&#xa;&#xa;    This is the multifactorial of n skipping k values.  For example,&#xa;&#xa;      factorialk(17, 4) = 17!!!! = 17 * 13 * 9 * 5 * 1&#xa;&#xa;    In particular, for any integer ``n``, we have&#xa;&#xa;      factorialk(n, 1) = factorial(n)&#xa;&#xa;      factorialk(n, 2) = factorial2(n)&#xa;&#xa;    Parameters&#xa;    ----------&#xa;    n : int&#xa;        Calculate multifactorial. If `n` < 0, the return value is 0.&#xa;    k : int&#xa;        Order of multifactorial.&#xa;    exact : bool, optional&#xa;        If exact is set to True, calculate the answer exactly using&#xa;        integer arithmetic.&#xa;&#xa;    Returns&#xa;    -------&#xa;    val : int&#xa;        Multifactorial of `n`.&#xa;&#xa;    Raises&#xa;    ------&#xa;    NotImplementedError&#xa;        Raises when exact is False&#xa;&#xa;    Examples&#xa;    --------&#xa;    >>> from scipy.special import factorialk&#xa;    >>> factorialk(5, 1, exact=True)&#xa;    120L&#xa;    >>> factorialk(5, 3, exact=True)&#xa;    10L&#xa;&#xa;    """"""&#xa;    if exact:&#xa;        if n < 1-k:&#xa;            return 0&#xa;        if n <= 0:&#xa;            return 1&#xa;        val = 1&#xa;        for j in xrange(n, 0, -k):&#xa;            val = val*j&#xa;        return val&#xa;    else:&#xa;        raise NotImplementedError&#xa;&#xa;&#xa;def zeta(x, q=None, out=None):&#xa;    r""""""&#xa;    Riemann zeta function.&#xa;&#xa;    The two-argument version is the Hurwitz zeta function:&#xa;&#xa;    .. math:: \zeta(x, q) = \sum_{k=0}^{\infty} \frac{1}{(k + q)^x},&#xa;&#xa;    Riemann zeta function corresponds to ``q = 1``.&#xa;&#xa;    See also&#xa;    --------&#xa;    zetac&#xa;&#xa;    """"""&#xa;    if q is None:&#xa;        q = 1&#xa;    return _zeta(x, q, out)&#xa;"
7205107|"#&#xa;# @BEGIN LICENSE&#xa;#&#xa;# Psi4: an open-source quantum chemistry software package&#xa;#&#xa;# Copyright (c) 2007-2018 The Psi4 Developers.&#xa;#&#xa;# The copyrights for code used from other parties are included in&#xa;# the corresponding files.&#xa;#&#xa;# This file is part of Psi4.&#xa;#&#xa;# Psi4 is free software; you can redistribute it and/or modify&#xa;# it under the terms of the GNU Lesser General Public License as published by&#xa;# the Free Software Foundation, version 3.&#xa;#&#xa;# Psi4 is distributed in the hope that it will be useful,&#xa;# but WITHOUT ANY WARRANTY; without even the implied warranty of&#xa;# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&#xa;# GNU Lesser General Public License for more details.&#xa;#&#xa;# You should have received a copy of the GNU Lesser General Public License along&#xa;# with Psi4; if not, write to the Free Software Foundation, Inc.,&#xa;# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.&#xa;#&#xa;# @END LICENSE&#xa;#&#xa;&#xa;import re&#xa;import sys&#xa;import math&#xa;&#xa;import numpy as np&#xa;&#xa;from ..physconst import psi_bohr2angstroms&#xa;&#xa;if sys.version_info >= (3, 0):&#xa;    basestring = str&#xa;&#xa;&#xa;def distance_matrix(a, b):&#xa;    """"""Euclidean distance matrix between rows of arrays `a` and `b`. Equivalent to&#xa;    `scipy.spatial.distance.cdist(a, b, 'euclidean')`. Returns a.shape[0] x b.shape[0] array.&#xa;&#xa;    """"""&#xa;    assert a.shape[1] == b.shape[1], """"""Inner dimensions do not match""""""&#xa;    distm = np.zeros([a.shape[0], b.shape[0]])&#xa;    for i in range(a.shape[0]):&#xa;        distm[i] = np.linalg.norm(a[i] - b, axis=1)&#xa;    return distm&#xa;&#xa;&#xa;def update_with_error(a, b, path=None):&#xa;    """"""Merges `b` into `a` like dict.update; however, raises KeyError if values of a&#xa;    key shared by `a` and `b` conflict.&#xa;&#xa;    Adapted from: https://stackoverflow.com/a/7205107&#xa;&#xa;    """"""&#xa;    if path is None:&#xa;        path = []&#xa;    for key in b:&#xa;        if key in a:&#xa;            if isinstance(a[key], dict) and isinstance(b[key], dict):&#xa;                update_with_error(a[key], b[key], path + [str(key)])&#xa;            elif a[key] == b[key]:&#xa;                pass  # same leaf value&#xa;            elif a[key] is None:&#xa;                a[key] = b[key]&#xa;            elif (isinstance(a[key], (list, tuple)) and&#xa;                  not isinstance(a[key], basestring) and&#xa;                  isinstance(b[key], (list, tuple)) and&#xa;                  not isinstance(b[key], basestring) and&#xa;                  len(a[key]) == len(b[key]) and&#xa;                  all((av is None or av == bv) for av, bv in zip(a[key], b[key]))):  # yapf: disable&#xa;                a[key] = b[key]&#xa;            else:&#xa;                raise KeyError('Conflict at {}: {} vs. {}'.format('.'.join(path + [str(key)]), a[key], b[key]))&#xa;        else:&#xa;            a[key] = b[key]&#xa;    return a&#xa;&#xa;&#xa;def standardize_efp_angles_units(units, geom_hints):&#xa;    """"""Applies to the pre-validated xyzabc or points hints in `geom_hints`&#xa;    the libefp default (1) units of [a0] and (2) radian angle range of&#xa;    (-pi, pi]. The latter is handy since this is how libefp returns hints&#xa;&#xa;    """"""&#xa;&#xa;    def radrge(radang):&#xa;        """"""Adjust `radang` by 2pi into (-pi, pi] range.""""""&#xa;        if radang > math.pi:&#xa;            return radang - 2 * math.pi&#xa;        elif radang <= -math.pi:&#xa;            return radang + 2 * math.pi&#xa;        else:&#xa;            return radang&#xa;&#xa;    if units == 'Angstrom':&#xa;        iutau = 1. / psi_bohr2angstroms&#xa;    else:&#xa;        iutau = 1.&#xa;&#xa;    hints = []&#xa;    for hint in geom_hints:&#xa;        if len(hint) == 6:&#xa;            x, y, z = [i * iutau for i in hint[:3]]&#xa;            a, b, c = [radrge(i) for i in hint[3:]]&#xa;            hints.append([x, y, z, a, b, c])&#xa;        if len(hint) == 9:&#xa;            points = [i * iutau for i in hint]&#xa;            hints.append(points)&#xa;&#xa;    return hints&#xa;&#xa;&#xa;def filter_comments(string):&#xa;    """"""Remove from `string` any Python-style comments ('#' to end of line).""""""&#xa;&#xa;    comment = re.compile(r'(^|[^\\])#.*')&#xa;    string = re.sub(comment, '', string)&#xa;    return string&#xa;&#xa;&#xa;def unnp(dicary):&#xa;    """"""Return `dicary` with any ndarray values replaced by lists.""""""&#xa;&#xa;    ndicary = {}&#xa;    for k, v in dicary.items():&#xa;        try:&#xa;            v.shape&#xa;        except AttributeError:&#xa;            ndicary[k] = v&#xa;        else:&#xa;            ndicary[k] = v.tolist()&#xa;    return ndicary&#xa;"
13564851|"# Windows implementation of PyAutoGUI functions.&#xa;# BSD license&#xa;# Al Sweigart al@inventwithpython.com&#xa;&#xa;import ctypes&#xa;import ctypes.wintypes&#xa;import pyautogui&#xa;&#xa;import sys&#xa;if sys.platform !=  'win32':&#xa;    raise Exception('The pyautogui_win module should only be loaded on a Windows system.')&#xa;&#xa;&#xa;# Fixes the scaling issues where PyAutoGUI was reporting the wrong resolution:&#xa;try:&#xa;   ctypes.windll.user32.SetProcessDPIAware()&#xa;except AttributeError:&#xa;    pass # Windows XP doesn't support this, so just do nothing.&#xa;&#xa;&#xa;""""""&#xa;A lot of this code is probably repeated from win32 extensions module, but I didn't want to have that dependency.&#xa;&#xa;Note: According to http://msdn.microsoft.com/en-us/library/windows/desktop/ms646260(v=vs.85).aspx&#xa;the ctypes.windll.user32.mouse_event() function has been superceded by SendInput.&#xa;&#xa;SendInput() is documented here: http://msdn.microsoft.com/en-us/library/windows/desktop/ms646310(v=vs.85).aspx&#xa;&#xa;UPDATE: SendInput() doesn't seem to be working for me. I've switched back to mouse_event().""""""&#xa;&#xa;&#xa;# Event codes to be passed to the mouse_event() win32 function.&#xa;# Documented here: http://msdn.microsoft.com/en-us/library/windows/desktop/ms646273(v=vs.85).aspx&#xa;MOUSEEVENTF_LEFTDOWN = 0x0002&#xa;MOUSEEVENTF_LEFTUP = 0x0004&#xa;MOUSEEVENTF_LEFTCLICK = MOUSEEVENTF_LEFTDOWN + MOUSEEVENTF_LEFTUP&#xa;MOUSEEVENTF_RIGHTDOWN = 0x0008&#xa;MOUSEEVENTF_RIGHTUP = 0x0010&#xa;MOUSEEVENTF_RIGHTCLICK = MOUSEEVENTF_RIGHTDOWN + MOUSEEVENTF_RIGHTUP&#xa;MOUSEEVENTF_MIDDLEDOWN = 0x0020&#xa;MOUSEEVENTF_MIDDLEUP = 0x0040&#xa;MOUSEEVENTF_MIDDLECLICK = MOUSEEVENTF_MIDDLEDOWN + MOUSEEVENTF_MIDDLEUP&#xa;&#xa;MOUSEEVENTF_WHEEL = 0x0800&#xa;MOUSEEVENTF_HWHEEL = 0x01000&#xa;&#xa;# Documented here: http://msdn.microsoft.com/en-us/library/windows/desktop/ms646304(v=vs.85).aspx&#xa;KEYEVENTF_KEYUP = 0x0002&#xa;&#xa;# Documented here: http://msdn.microsoft.com/en-us/library/windows/desktop/ms646270(v=vs.85).aspx&#xa;INPUT_MOUSE = 0&#xa;INPUT_KEYBOARD = 1&#xa;&#xa;&#xa;# This ctypes structure is for a Win32 POINT structure,&#xa;# which is documented here: http://msdn.microsoft.com/en-us/library/windows/desktop/dd162805(v=vs.85).aspx&#xa;# The POINT structure is used by GetCursorPos().&#xa;class POINT(ctypes.Structure):&#xa;    _fields_ = [(""x"", ctypes.c_ulong),&#xa;                (""y"", ctypes.c_ulong)]&#xa;&#xa;# These ctypes structures are for Win32 INPUT, MOUSEINPUT, KEYBDINPUT, and HARDWAREINPUT structures,&#xa;# used by SendInput and documented here: http://msdn.microsoft.com/en-us/library/windows/desktop/ms646270(v=vs.85).aspx&#xa;# Thanks to BSH for this StackOverflow answer: https://stackoverflow.com/questions/18566289/how-would-you-recreate-this-windows-api-structure-with-ctypes&#xa;class MOUSEINPUT(ctypes.Structure):&#xa;    _fields_ = [&#xa;        ('dx', ctypes.wintypes.LONG),&#xa;        ('dy', ctypes.wintypes.LONG),&#xa;        ('mouseData', ctypes.wintypes.DWORD),&#xa;        ('dwFlags', ctypes.wintypes.DWORD),&#xa;        ('time', ctypes.wintypes.DWORD),&#xa;        ('dwExtraInfo', ctypes.POINTER(ctypes.wintypes.ULONG)),&#xa;    ]&#xa;&#xa;class KEYBDINPUT(ctypes.Structure):&#xa;    _fields_ = [&#xa;        ('wVk', ctypes.wintypes.WORD),&#xa;        ('wScan', ctypes.wintypes.WORD),&#xa;        ('dwFlags', ctypes.wintypes.DWORD),&#xa;        ('time', ctypes.wintypes.DWORD),&#xa;        ('dwExtraInfo', ctypes.POINTER(ctypes.wintypes.ULONG)),&#xa;    ]&#xa;&#xa;class HARDWAREINPUT(ctypes.Structure):&#xa;    _fields_ = [&#xa;        ('uMsg', ctypes.wintypes.DWORD),&#xa;        ('wParamL', ctypes.wintypes.WORD),&#xa;        ('wParamH', ctypes.wintypes.DWORD)&#xa;    ]&#xa;&#xa;class INPUT(ctypes.Structure):&#xa;    class _I(ctypes.Union):&#xa;        _fields_ = [&#xa;            ('mi', MOUSEINPUT),&#xa;            ('ki', KEYBDINPUT),&#xa;            ('hi', HARDWAREINPUT),&#xa;        ]&#xa;&#xa;    _anonymous_ = ('i', )&#xa;    _fields_ = [&#xa;        ('type', ctypes.wintypes.DWORD),&#xa;        ('i', _I),&#xa;    ]&#xa;# End of the SendInput win32 data structures.&#xa;&#xa;&#xa;&#xa;"""""" Keyboard key mapping for pyautogui:&#xa;Documented at http://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx&#xa;&#xa;The *KB dictionaries in pyautogui map a string that can be passed to keyDown(),&#xa;keyUp(), or press() into the code used for the OS-specific keyboard function.&#xa;&#xa;They should always be lowercase, and the same keys should be used across all OSes.""""""&#xa;keyboardMapping = dict([(key, None) for key in pyautogui.KEY_NAMES])&#xa;keyboardMapping.update({&#xa;    'backspace': 0x08, # VK_BACK&#xa;    '\b': 0x08, # VK_BACK&#xa;    'super': 0x5B, #VK_LWIN&#xa;    'tab': 0x09, # VK_TAB&#xa;    '\t': 0x09, # VK_TAB&#xa;    'clear': 0x0c, # VK_CLEAR&#xa;    'enter': 0x0d, # VK_RETURN&#xa;    '\n': 0x0d, # VK_RETURN&#xa;    'return': 0x0d, # VK_RETURN&#xa;    'shift': 0x10, # VK_SHIFT&#xa;    'ctrl': 0x11, # VK_CONTROL&#xa;    'alt': 0x12, # VK_MENU&#xa;    'pause': 0x13, # VK_PAUSE&#xa;    'capslock': 0x14, # VK_CAPITAL&#xa;    'kana': 0x15, # VK_KANA&#xa;    'hanguel': 0x15, # VK_HANGUEL&#xa;    'hangul': 0x15, # VK_HANGUL&#xa;    'junja': 0x17, # VK_JUNJA&#xa;    'final': 0x18, # VK_FINAL&#xa;    'hanja': 0x19, # VK_HANJA&#xa;    'kanji': 0x19, # VK_KANJI&#xa;    'esc': 0x1b, # VK_ESCAPE&#xa;    'escape': 0x1b, # VK_ESCAPE&#xa;    'convert': 0x1c, # VK_CONVERT&#xa;    'nonconvert': 0x1d, # VK_NONCONVERT&#xa;    'accept': 0x1e, # VK_ACCEPT&#xa;    'modechange': 0x1f, # VK_MODECHANGE&#xa;    ' ': 0x20, # VK_SPACE&#xa;    'space': 0x20,&#xa;    'pgup': 0x21, # VK_PRIOR&#xa;    'pgdn': 0x22, # VK_NEXT&#xa;    'pageup': 0x21, # VK_PRIOR&#xa;    'pagedown': 0x22, # VK_NEXT&#xa;    'end': 0x23, # VK_END&#xa;    'home': 0x24, # VK_HOME&#xa;    'left': 0x25, # VK_LEFT&#xa;    'up': 0x26, # VK_UP&#xa;    'right': 0x27, # VK_RIGHT&#xa;    'down': 0x28, # VK_DOWN&#xa;    'select': 0x29, # VK_SELECT&#xa;    'print': 0x2a, # VK_PRINT&#xa;    'execute': 0x2b, # VK_EXECUTE&#xa;    'prtsc': 0x2c, # VK_SNAPSHOT&#xa;    'prtscr': 0x2c, # VK_SNAPSHOT&#xa;    'prntscrn': 0x2c, # VK_SNAPSHOT&#xa;    'printscreen': 0x2c, # VK_SNAPSHOT&#xa;    'insert': 0x2d, # VK_INSERT&#xa;    'del': 0x2e, # VK_DELETE&#xa;    'delete': 0x2e, # VK_DELETE&#xa;    'help': 0x2f, # VK_HELP&#xa;    'win': 0x5b, # VK_LWIN&#xa;    'winleft': 0x5b, # VK_LWIN&#xa;    'winright': 0x5c, # VK_RWIN&#xa;    'apps': 0x5d, # VK_APPS&#xa;    'sleep': 0x5f, # VK_SLEEP&#xa;    'num0': 0x60, # VK_NUMPAD0&#xa;    'num1': 0x61, # VK_NUMPAD1&#xa;    'num2': 0x62, # VK_NUMPAD2&#xa;    'num3': 0x63, # VK_NUMPAD3&#xa;    'num4': 0x64, # VK_NUMPAD4&#xa;    'num5': 0x65, # VK_NUMPAD5&#xa;    'num6': 0x66, # VK_NUMPAD6&#xa;    'num7': 0x67, # VK_NUMPAD7&#xa;    'num8': 0x68, # VK_NUMPAD8&#xa;    'num9': 0x69, # VK_NUMPAD9&#xa;    'multiply': 0x6a, # VK_MULTIPLY  ??? Is this the numpad *?&#xa;    'add': 0x6b, # VK_ADD  ??? Is this the numpad +?&#xa;    'separator': 0x6c, # VK_SEPARATOR  ??? Is this the numpad enter?&#xa;    'subtract': 0x6d, # VK_SUBTRACT  ??? Is this the numpad -?&#xa;    'decimal': 0x6e, # VK_DECIMAL&#xa;    'divide': 0x6f, # VK_DIVIDE&#xa;    'f1': 0x70, # VK_F1&#xa;    'f2': 0x71, # VK_F2&#xa;    'f3': 0x72, # VK_F3&#xa;    'f4': 0x73, # VK_F4&#xa;    'f5': 0x74, # VK_F5&#xa;    'f6': 0x75, # VK_F6&#xa;    'f7': 0x76, # VK_F7&#xa;    'f8': 0x77, # VK_F8&#xa;    'f9': 0x78, # VK_F9&#xa;    'f10': 0x79, # VK_F10&#xa;    'f11': 0x7a, # VK_F11&#xa;    'f12': 0x7b, # VK_F12&#xa;    'f13': 0x7c, # VK_F13&#xa;    'f14': 0x7d, # VK_F14&#xa;    'f15': 0x7e, # VK_F15&#xa;    'f16': 0x7f, # VK_F16&#xa;    'f17': 0x80, # VK_F17&#xa;    'f18': 0x81, # VK_F18&#xa;    'f19': 0x82, # VK_F19&#xa;    'f20': 0x83, # VK_F20&#xa;    'f21': 0x84, # VK_F21&#xa;    'f22': 0x85, # VK_F22&#xa;    'f23': 0x86, # VK_F23&#xa;    'f24': 0x87, # VK_F24&#xa;    'numlock': 0x90, # VK_NUMLOCK&#xa;    'scrolllock': 0x91, # VK_SCROLL&#xa;    'shiftleft': 0xa0, # VK_LSHIFT&#xa;    'shiftright': 0xa1, # VK_RSHIFT&#xa;    'ctrlleft': 0xa2, # VK_LCONTROL&#xa;    'ctrlright': 0xa3, # VK_RCONTROL&#xa;    'altleft': 0xa4, # VK_LMENU&#xa;    'altright': 0xa5, # VK_RMENU&#xa;    'browserback': 0xa6, # VK_BROWSER_BACK&#xa;    'browserforward': 0xa7, # VK_BROWSER_FORWARD&#xa;    'browserrefresh': 0xa8, # VK_BROWSER_REFRESH&#xa;    'browserstop': 0xa9, # VK_BROWSER_STOP&#xa;    'browsersearch': 0xaa, # VK_BROWSER_SEARCH&#xa;    'browserfavorites': 0xab, # VK_BROWSER_FAVORITES&#xa;    'browserhome': 0xac, # VK_BROWSER_HOME&#xa;    'volumemute': 0xad, # VK_VOLUME_MUTE&#xa;    'volumedown': 0xae, # VK_VOLUME_DOWN&#xa;    'volumeup': 0xaf, # VK_VOLUME_UP&#xa;    'nexttrack': 0xb0, # VK_MEDIA_NEXT_TRACK&#xa;    'prevtrack': 0xb1, # VK_MEDIA_PREV_TRACK&#xa;    'stop': 0xb2, # VK_MEDIA_STOP&#xa;    'playpause': 0xb3, # VK_MEDIA_PLAY_PAUSE&#xa;    'launchmail': 0xb4, # VK_LAUNCH_MAIL&#xa;    'launchmediaselect': 0xb5, # VK_LAUNCH_MEDIA_SELECT&#xa;    'launchapp1': 0xb6, # VK_LAUNCH_APP1&#xa;    'launchapp2': 0xb7, # VK_LAUNCH_APP2&#xa;    #';': 0xba, # VK_OEM_1&#xa;    #'+': 0xbb, # VK_OEM_PLUS&#xa;    #',': 0xbc, # VK_OEM_COMMA&#xa;    #'-': 0xbd, # VK_OEM_MINUS&#xa;    #'.': 0xbe, # VK_OEM_PERIOD&#xa;    #'/': 0xbf, # VK_OEM_2&#xa;    #'~': 0xc0, # VK_OEM_3&#xa;    #'[': 0xdb, # VK_OEM_4&#xa;    #'|': 0xdc, # VK_OEM_5&#xa;    #']': 0xdd, # VK_OEM_6&#xa;    #""'"": 0xde, # VK_OEM_7&#xa;    #'': 0xdf, # VK_OEM_8&#xa;    #'': 0xe7, # VK_PACKET&#xa;    #'': 0xf6, # VK_ATTN&#xa;    #'': 0xf7, # VK_CRSEL&#xa;    #'': 0xf8, # VK_EXSEL&#xa;    #'': 0xf9, # VK_EREOF&#xa;    #'': 0xfa, # VK_PLAY&#xa;    #'': 0xfb, # VK_ZOOM&#xa;    #'': 0xfc, # VK_NONAME&#xa;    #'': 0xfd, # VK_PA1&#xa;    #'': 0xfe, # VK_OEM_CLEAR&#xa;})&#xa;&#xa;# Populate the basic printable ascii characters.&#xa;for c in range(32, 128):&#xa;    keyboardMapping[chr(c)] = ctypes.windll.user32.VkKeyScanA(ctypes.wintypes.WCHAR(chr(c)))&#xa;&#xa;&#xa;def _keyDown(key):&#xa;    """"""Performs a keyboard key press without the release. This will put that&#xa;    key in a held down state.&#xa;&#xa;    NOTE: For some reason, this does not seem to cause key repeats like would&#xa;    happen if a keyboard key was held down on a text field.&#xa;&#xa;    Args:&#xa;      key (str): The key to be pressed down. The valid names are listed in&#xa;      pyautogui.KEY_NAMES.&#xa;&#xa;    Returns:&#xa;      None&#xa;    """"""&#xa;    if key not in keyboardMapping or keyboardMapping[key] is None:&#xa;        return&#xa;&#xa;    needsShift = pyautogui.isShiftCharacter(key)&#xa;&#xa;    """"""&#xa;    # OLD CODE: The new code relies on having all keys be loaded in keyboardMapping from the start.&#xa;    if key in keyboardMapping.keys():&#xa;        vkCode = keyboardMapping[key]&#xa;    elif len(key) == 1:&#xa;        # note: I could use this case to update keyboardMapping to cache the VkKeyScan results, but I've decided not to just to make any possible bugs easier to reproduce.&#xa;        vkCode = ctypes.windll.user32.VkKeyScanW(ctypes.wintypes.WCHAR(key))&#xa;        if vkCode == -1:&#xa;            raise ValueError('There is no VK code for key ""%s""' % (key))&#xa;        if vkCode > 0x100: # the vk code will be > 0x100 if it needs shift&#xa;            vkCode -= 0x100&#xa;            needsShift = True&#xa;    """"""&#xa;    mods, vkCode = divmod(keyboardMapping[key], 0x100)&#xa;&#xa;    for apply_mod, vk_mod in [(mods & 4, 0x12), (mods & 2, 0x11),&#xa;        (mods & 1 or needsShift, 0x10)]: #HANKAKU not suported! mods & 8&#xa;        if apply_mod:&#xa;            ctypes.windll.user32.keybd_event(vk_mod, 0, 0, 0) #&#xa;    ctypes.windll.user32.keybd_event(vkCode, 0, 0, 0)&#xa;    for apply_mod, vk_mod in [(mods & 1 or needsShift, 0x10), (mods & 2, 0x11),&#xa;        (mods & 4, 0x12)]: #HANKAKU not suported! mods & 8&#xa;        if apply_mod:&#xa;            ctypes.windll.user32.keybd_event(vk_mod, 0, KEYEVENTF_KEYUP, 0) #&#xa;&#xa;&#xa;def _keyUp(key):&#xa;    """"""Performs a keyboard key release (without the press down beforehand).&#xa;&#xa;    Args:&#xa;      key (str): The key to be released up. The valid names are listed in&#xa;      pyautogui.KEY_NAMES.&#xa;&#xa;    Returns:&#xa;      None&#xa;    """"""&#xa;    if key not in keyboardMapping or keyboardMapping[key] is None:&#xa;        return&#xa;&#xa;    needsShift = pyautogui.isShiftCharacter(key)&#xa;    """"""&#xa;    # OLD CODE: The new code relies on having all keys be loaded in keyboardMapping from the start.&#xa;    if key in keyboardMapping.keys():&#xa;        vkCode = keyboardMapping[key]&#xa;    elif len(key) == 1:&#xa;        # note: I could use this case to update keyboardMapping to cache the VkKeyScan results, but I've decided not to just to make any possible bugs easier to reproduce.&#xa;        vkCode = ctypes.windll.user32.VkKeyScanW(ctypes.wintypes.WCHAR(key))&#xa;        if vkCode == -1:&#xa;            raise ValueError('There is no VK code for key ""%s""' % (key))&#xa;        if vkCode > 0x100: # the vk code will be > 0x100 if it needs shift&#xa;            vkCode -= 0x100&#xa;            needsShift = True&#xa;    """"""&#xa;    mods, vkCode = divmod(keyboardMapping[key], 0x100)&#xa;&#xa;    for apply_mod, vk_mod in [(mods & 4, 0x12), (mods & 2, 0x11),&#xa;        (mods & 1 or needsShift, 0x10)]: #HANKAKU not suported! mods & 8&#xa;        if apply_mod:&#xa;            ctypes.windll.user32.keybd_event(vk_mod, 0, 0, 0) #&#xa;    ctypes.windll.user32.keybd_event(vkCode, 0, KEYEVENTF_KEYUP, 0)&#xa;    for apply_mod, vk_mod in [(mods & 1 or needsShift, 0x10), (mods & 2, 0x11),&#xa;        (mods & 4, 0x12)]: #HANKAKU not suported! mods & 8&#xa;        if apply_mod:&#xa;            ctypes.windll.user32.keybd_event(vk_mod, 0, KEYEVENTF_KEYUP, 0) #&#xa;&#xa;&#xa;def _position():&#xa;    """"""Returns the current xy coordinates of the mouse cursor as a two-integer&#xa;    tuple by calling the GetCursorPos() win32 function.&#xa;&#xa;    Returns:&#xa;      (x, y) tuple of the current xy coordinates of the mouse cursor.&#xa;    """"""&#xa;&#xa;    cursor = POINT()&#xa;    ctypes.windll.user32.GetCursorPos(ctypes.byref(cursor))&#xa;    return (cursor.x, cursor.y)&#xa;&#xa;&#xa;def _size():&#xa;    """"""Returns the width and height of the screen as a two-integer tuple.&#xa;&#xa;    Returns:&#xa;      (width, height) tuple of the screen size, in pixels.&#xa;    """"""&#xa;    return (ctypes.windll.user32.GetSystemMetrics(0), ctypes.windll.user32.GetSystemMetrics(1))&#xa;&#xa;&#xa;def _moveTo(x, y):&#xa;    """"""Send the mouse move event to Windows by calling SetCursorPos() win32&#xa;    function.&#xa;&#xa;    Args:&#xa;      button (str): The mouse button, either 'left', 'middle', or 'right'&#xa;      x (int): The x position of the mouse event.&#xa;      y (int): The y position of the mouse event.&#xa;&#xa;    Returns:&#xa;      None&#xa;    """"""&#xa;    ctypes.windll.user32.SetCursorPos(x, y)&#xa;&#xa;&#xa;def _mouseDown(x, y, button):&#xa;    """"""Send the mouse down event to Windows by calling the mouse_event() win32&#xa;    function.&#xa;&#xa;    Args:&#xa;      x (int): The x position of the mouse event.&#xa;      y (int): The y position of the mouse event.&#xa;      button (str): The mouse button, either 'left', 'middle', or 'right'&#xa;&#xa;    Returns:&#xa;      None&#xa;    """"""&#xa;    if button == 'left':&#xa;        try:&#xa;            _sendMouseEvent(MOUSEEVENTF_LEFTDOWN, x, y)&#xa;        except (PermissionError, OSError): # TODO: We need to figure out how to prevent these errors, see https://github.com/asweigart/pyautogui/issues/60&#xa;            pass&#xa;    elif button == 'middle':&#xa;        try:&#xa;            _sendMouseEvent(MOUSEEVENTF_MIDDLEDOWN, x, y)&#xa;        except (PermissionError, OSError): # TODO: We need to figure out how to prevent these errors, see https://github.com/asweigart/pyautogui/issues/60&#xa;            pass&#xa;    elif button == 'right':&#xa;        try:&#xa;            _sendMouseEvent(MOUSEEVENTF_RIGHTDOWN, x, y)&#xa;        except (PermissionError, OSError): # TODO: We need to figure out how to prevent these errors, see https://github.com/asweigart/pyautogui/issues/60&#xa;            pass&#xa;    else:&#xa;        assert False, ""button argument not in ('left', 'middle', 'right')""&#xa;&#xa;&#xa;def _mouseUp(x, y, button):&#xa;    """"""Send the mouse up event to Windows by calling the mouse_event() win32&#xa;    function.&#xa;&#xa;    Args:&#xa;      x (int): The x position of the mouse event.&#xa;      y (int): The y position of the mouse event.&#xa;      button (str): The mouse button, either 'left', 'middle', or 'right'&#xa;&#xa;    Returns:&#xa;      None&#xa;    """"""&#xa;    if button == 'left':&#xa;        try:&#xa;            _sendMouseEvent(MOUSEEVENTF_LEFTUP, x, y)&#xa;        except (PermissionError, OSError): # TODO: We need to figure out how to prevent these errors, see https://github.com/asweigart/pyautogui/issues/60&#xa;            pass&#xa;    elif button == 'middle':&#xa;        try:&#xa;            _sendMouseEvent(MOUSEEVENTF_MIDDLEUP, x, y)&#xa;        except (PermissionError, OSError): # TODO: We need to figure out how to prevent these errors, see https://github.com/asweigart/pyautogui/issues/60&#xa;            pass&#xa;    elif button == 'right':&#xa;        try:&#xa;            _sendMouseEvent(MOUSEEVENTF_RIGHTUP, x, y)&#xa;        except (PermissionError, OSError): # TODO: We need to figure out how to prevent these errors, see https://github.com/asweigart/pyautogui/issues/60&#xa;            pass&#xa;    else:&#xa;        assert False, ""button argument not in ('left', 'middle', 'right')""&#xa;&#xa;&#xa;def _click(x, y, button):&#xa;    """"""Send the mouse click event to Windows by calling the mouse_event() win32&#xa;    function.&#xa;&#xa;    Args:&#xa;      button (str): The mouse button, either 'left', 'middle', or 'right'&#xa;      x (int): The x position of the mouse event.&#xa;      y (int): The y position of the mouse event.&#xa;&#xa;    Returns:&#xa;      None&#xa;    """"""&#xa;    if button == 'left':&#xa;        try:&#xa;            _sendMouseEvent(MOUSEEVENTF_LEFTCLICK, x, y)&#xa;        except (PermissionError, OSError): # TODO: We need to figure out how to prevent these errors, see https://github.com/asweigart/pyautogui/issues/60&#xa;            pass&#xa;    elif button == 'middle':&#xa;        try:&#xa;            _sendMouseEvent(MOUSEEVENTF_MIDDLECLICK, x, y)&#xa;        except (PermissionError, OSError): # TODO: We need to figure out how to prevent these errors, see https://github.com/asweigart/pyautogui/issues/60&#xa;            pass&#xa;    elif button == 'right':&#xa;        try:&#xa;            _sendMouseEvent(MOUSEEVENTF_RIGHTCLICK, x, y)&#xa;        except (PermissionError, OSError): # TODO: We need to figure out how to prevent these errors, see https://github.com/asweigart/pyautogui/issues/60&#xa;            pass&#xa;    else:&#xa;        assert False, ""button argument not in ('left', 'middle', 'right')""&#xa;&#xa;&#xa;def _sendMouseEvent(ev, x, y, dwData=0):&#xa;    """"""The helper function that actually makes the call to the mouse_event()&#xa;    win32 function.&#xa;&#xa;    Args:&#xa;      ev (int): The win32 code for the mouse event. Use one of the MOUSEEVENTF_*&#xa;      constants for this argument.&#xa;      x (int): The x position of the mouse event.&#xa;      y (int): The y position of the mouse event.&#xa;      dwData (int): The argument for mouse_event()'s dwData parameter. So far&#xa;        this is only used by mouse scrolling.&#xa;&#xa;    Returns:&#xa;      None&#xa;    """"""&#xa;    assert x != None and y != None, 'x and y cannot be set to None'&#xa;    # TODO: ARG! For some reason, SendInput isn't working for mouse events. I'm switching to using the older mouse_event win32 function.&#xa;    #mouseStruct = MOUSEINPUT()&#xa;    #mouseStruct.dx = x&#xa;    #mouseStruct.dy = y&#xa;    #mouseStruct.mouseData = ev&#xa;    #mouseStruct.time = 0&#xa;    #mouseStruct.dwExtraInfo = ctypes.pointer(ctypes.c_ulong(0)) # according to https://stackoverflow.com/questions/13564851/generate-keyboard-events I can just set this. I don't really care about this value.&#xa;    #inputStruct = INPUT()&#xa;    #inputStruct.mi = mouseStruct&#xa;    #inputStruct.type = INPUT_MOUSE&#xa;    #ctypes.windll.user32.SendInput(1, ctypes.pointer(inputStruct), ctypes.sizeof(inputStruct))&#xa;&#xa;    width, height = _size()&#xa;    convertedX = 65536 * x // width + 1&#xa;    convertedY = 65536 * y // height + 1&#xa;    ctypes.windll.user32.mouse_event(ev, ctypes.c_long(convertedX), ctypes.c_long(convertedY), dwData, 0)&#xa;&#xa;    # TODO: Too many false positives with this code: See: https://github.com/asweigart/pyautogui/issues/108&#xa;    #if ctypes.windll.kernel32.GetLastError() != 0:&#xa;    #    raise ctypes.WinError()&#xa;&#xa;&#xa;def _scroll(clicks, x=None, y=None):&#xa;    """"""Send the mouse vertical scroll event to Windows by calling the&#xa;    mouse_event() win32 function.&#xa;&#xa;    Args:&#xa;      clicks (int): The amount of scrolling to do. A positive value is the mouse&#xa;      wheel moving forward (scrolling up), a negative value is backwards (down).&#xa;      x (int): The x position of the mouse event.&#xa;      y (int): The y position of the mouse event.&#xa;&#xa;    Returns:&#xa;      None&#xa;    """"""&#xa;    startx, starty = _position()&#xa;    width, height = _size()&#xa;&#xa;    if x is None:&#xa;        x = startx&#xa;    else:&#xa;        if x < 0:&#xa;            x = 0&#xa;        elif x >= width:&#xa;            x = width - 1&#xa;    if y is None:&#xa;        y = starty&#xa;    else:&#xa;        if y < 0:&#xa;            y = 0&#xa;        elif y >= height:&#xa;            y = height - 1&#xa;&#xa;    try:&#xa;        _sendMouseEvent(MOUSEEVENTF_WHEEL, x, y, dwData=clicks)&#xa;    except (PermissionError, OSError): # TODO: We need to figure out how to prevent these errors, see https://github.com/asweigart/pyautogui/issues/60&#xa;            pass&#xa;&#xa;&#xa;def _hscroll(clicks, x, y):&#xa;    """"""Send the mouse horizontal scroll event to Windows by calling the&#xa;    mouse_event() win32 function.&#xa;&#xa;    Args:&#xa;      clicks (int): The amount of scrolling to do. A positive value is the mouse&#xa;      wheel moving right, a negative value is moving left.&#xa;      x (int): The x position of the mouse event.&#xa;      y (int): The y position of the mouse event.&#xa;&#xa;    Returns:&#xa;      None&#xa;    """"""&#xa;    return _scroll(clicks, x, y)&#xa;&#xa;&#xa;def _vscroll(clicks, x, y):&#xa;    """"""A wrapper for _scroll(), which does vertical scrolling.&#xa;&#xa;    Args:&#xa;      clicks (int): The amount of scrolling to do. A positive value is the mouse&#xa;      wheel moving forward (scrolling up), a negative value is backwards (down).&#xa;      x (int): The x position of the mouse event.&#xa;      y (int): The y position of the mouse event.&#xa;&#xa;    Returns:&#xa;      None&#xa;    """"""&#xa;    return _scroll(clicks, x, y)&#xa;&#xa;"
13436167|#!/usr/bin/env python&#xa;&#xa;import re&#xa;import json&#xa;&#xa;# http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae&#xa;# http://stackoverflow.com/a/13436167/96656&#xa;def unisymbol(codePoint):&#xa;	if codePoint >= 0x0000 and codePoint <= 0xFFFF:&#xa;		return unichr(codePoint)&#xa;	elif codePoint >= 0x010000 and codePoint <= 0x10FFFF:&#xa;		highSurrogate = int((codePoint - 0x10000) / 0x400) + 0xD800&#xa;		lowSurrogate = int((codePoint - 0x10000) % 0x400) + 0xDC00&#xa;		return unichr(highSurrogate) + unichr(lowSurrogate)&#xa;	else:&#xa;		return 'Error'&#xa;&#xa;def hexify(codePoint):&#xa;	return 'U+' + hex(codePoint)[2:].upper().zfill(6)&#xa;&#xa;def writeFile(filename, contents):&#xa;	print filename&#xa;	with open(filename, 'w') as f:&#xa;		f.write(contents.strip() + '\n')&#xa;&#xa;data = []&#xa;for codePoint in range(0x000000, 0x10FFFF + 1):&#xa;	symbol = unisymbol(codePoint)&#xa;	# http://stackoverflow.com/a/17199950/96656&#xa;	bytes = symbol.encode('utf8').decode('latin1')&#xa;	data.append({&#xa;		'codePoint': codePoint,&#xa;		'decoded': symbol,&#xa;		'encoded': bytes&#xa;	});&#xa;&#xa;jsonData = json.dumps(data, sort_keys=False, indent=2, separators=(',', ': '))&#xa;# Use tabs instead of double spaces for indentation&#xa;jsonData = jsonData.replace('  ', '\t')&#xa;# Escape hexadecimal digits in escape sequences&#xa;jsonData = re.sub(&#xa;	r'\\u([a-fA-F0-9]{4})',&#xa;	lambda match: r'\u{}'.format(match.group(1).upper()),&#xa;	jsonData&#xa;)&#xa;&#xa;writeFile('data.json', jsonData)&#xa;
33601043|"from graphics_util import alpha_blend&#xa;&#xa;&#xa;def getANSIcolor_for_rgb(rgb):&#xa;    # Convert to web-safe color since that's what terminals can handle in ""256 color mode"" &#xa;    #   https://en.wikipedia.org/wiki/ANSI_escape_code&#xa;    #   http://misc.flogisoft.com/bash/tip_colors_and_formatting#bash_tipscolors_and_formatting_ansivt100_control_sequences&#xa;    #   http://superuser.com/questions/270214/how-can-i-change-the-colors-of-my-xterm-using-ansi-escape-sequences&#xa;    websafe_r = int(round((rgb[0] / 255.0) * 5) )&#xa;    websafe_g = int(round((rgb[1] / 255.0) * 5) )&#xa;    websafe_b = int(round((rgb[2] / 255.0) * 5) )&#xa;&#xa;    # Return ANSI color - only using 216 colors since those are the only ones we can reliably map to   &#xa;    #   https://en.wikipedia.org/wiki/ANSI_escape_code (see 256 color mode section)    &#xa;    return int(((websafe_r * 36) + (websafe_g * 6) + websafe_b) + 16)   &#xa;&#xa;&#xa;def getANSIfgarray_for_ANSIcolor(ANSIcolor):&#xa;    ""Return array of color codes to be used in composing an SGR escape sequence. Using array form lets us compose multiple color updates without putting out additional escapes""&#xa;    # We are using ""256 color mode"" which is available in xterm but not necessarily all terminals&#xa;    return ['38', '5', str(ANSIcolor)]      # To set FG in 256 color you use a code like ESC[38;5;###m&#xa;&#xa;&#xa;def getANSIbgarray_for_ANSIcolor(ANSIcolor):&#xa;    ""Return array of color codes to be used in composing an SGR escape sequence. Using array form lets us compose multiple color updates without putting out additional escapes""&#xa;    # We are using ""256 color mode"" which is available in xterm but not necessarily all terminals&#xa;    return ['48', '5', str(ANSIcolor)]      # To set BG in 256 color you use a code like ESC[48;5;###m&#xa;    &#xa;&#xa;def getANSIbgstring_for_ANSIcolor(ANSIcolor):&#xa;    # Get the array of color code info, prefix it with ESCAPE code and terminate it with ""m""&#xa;    return ""\x1b["" + "";"".join(getANSIbgarray_for_ANSIcolor(ANSIcolor)) + ""m""&#xa;    &#xa;&#xa;def generate_ANSI_to_set_fg_bg_colors(cur_fg_color, cur_bg_color, new_fg_color, new_bg_color):&#xa;             &#xa;    # This code assumes that ESC[49m and ESC[39m work for resetting bg and fg &#xa;    # This may not work on all terminals in which case we would have to use ESC[0m &#xa;    # to reset both at once, and then put back fg or bg that we actually want&#xa; &#xa;    # We don't change colors that are already the way we want them - saves lots of file size&#xa;&#xa;    color_array = []        # use array mechanism to avoid multiple escape sequences if we need to change fg AND bg&#xa;&#xa;    if new_bg_color != cur_bg_color:&#xa;        if new_bg_color is None:&#xa;            color_array.append('49')        # reset to default&#xa;        else:&#xa;            color_array += getANSIbgarray_for_ANSIcolor(new_bg_color)&#xa;                &#xa;    if new_fg_color != cur_fg_color:&#xa;        if new_fg_color is None:&#xa;            color_array.append('39')        # reset to default&#xa;        else:&#xa;            color_array += getANSIfgarray_for_ANSIcolor(new_fg_color)&#xa;&#xa;    if len(color_array) > 0:&#xa;        return ""\x1b["" + "";"".join(color_array) + ""m""&#xa;    else:&#xa;        return """"&#xa;&#xa;&#xa;def generate_optimized_y_move_down_x_SOL(y_dist):&#xa;    """""" move down y_dist, set x=0 """"""&#xa;&#xa;    # Optimization to move N lines and go to SOL in one command. Note that some terminals &#xa;    # may not support this so we might have to remove this optimization or make it optional &#xa;    # if that winds up mattering for terminals we care about. If we had to remove we'd&#xa;    # want to rework things such that we used ""\x1b[{0}B"" but also we would want to change&#xa;    # our interface to this function so we didn't guarantee x=0 since caller might ultimate &#xa;    # want it in a different place and we don't want to output two x moves. Could pass in &#xa;    # desired x, or return current x from here. &#xa;          &#xa;    string = ""\x1b[{0}E"".format(y_dist)  # ANSI code to move down N lines and move x to SOL&#xa;&#xa;    # Would a sequence of 1 or more \n chars be cheaper? If so we'll output that instead&#xa;    if y_dist < len(string):&#xa;        string = '\n' * y_dist&#xa;        &#xa;    return string&#xa;    &#xa;&#xa;def generate_ANSI_to_move_cursor(cur_x, cur_y, target_x, target_y):&#xa;    """"""&#xa;        Note that x positions are absolute (0=SOL) while y positions are relative. That is,&#xa;        we move the y position the relative distance between cur_y and target_y. It doesn't&#xa;        mean that cur_y=0 means we are on the first line of the screen. We have no way of&#xa;        knowing how tall the screen is, etc. at draw-time so we can't know this. &#xa;    """"""&#xa;&#xa;&#xa;    """"""&#xa;        **SIZE - this code (in concert with its caller) implements what I would call ""local optimizations""&#xa;        to try to minimize the number and size of cursor movements outputted. It does not attempt ""global&#xa;        optimizations"" which I think are rarely going to be worthwhile. See the DESIGN NOTE on global&#xa;        optimizations in this file for more details &#xa;    """"""        &#xa;&#xa;&#xa;    string = """"&#xa;&#xa;    if cur_y < target_y:    # MOVE DOWN&#xa;        y_dist = target_y - cur_y&#xa;&#xa;        # See if we can optimize moving x and y together&#xa;        if cur_x == target_x: &#xa;        &#xa;            # Need to move in y only&#xa;            if target_x != 0: &#xa;                # Already in correct x position which is NOT SOL. Just output code to move cursor &#xa;                # down. No special optimization is possible since \n would take us to SOL and then &#xa;                # we'd also need to output a move for x. &#xa;                return ""\x1b[{0}B"".format(y_dist)  # ANSI code to move down N lines&#xa;            else:&#xa;                # Already in correct x position which is SOL. Output efficient code to move down.&#xa;                return generate_optimized_y_move_down_x_SOL(y_dist)&#xa;        else:&#xa;        &#xa;            # Need to move in x and y&#xa;            if target_x != 0: &#xa;                # x move is going to be required so we'll move y efficiently and as a side&#xa;                # effect, x will become 0. Code below will move x to the right place&#xa;                string += generate_optimized_y_move_down_x_SOL(y_dist)&#xa;                cur_x = 0&#xa;            else:&#xa;                # Output move down that brings x to SOL. Then we're done.&#xa;                return generate_optimized_y_move_down_x_SOL(y_dist)&#xa;                &#xa;    elif cur_y > target_y:  # MOVE UP&#xa;        if target_x == 0:        &#xa;            # We want to move up and be at the SOL. That can be achieved with one command so we're&#xa;            # done and we return it. However note that some terminals may not support this so we&#xa;            # might have to remove this optimization or make it optional if that winds up mattering for terminals we care about.  &#xa;            return ""\x1b[{0}F"".format(cur_y - target_y)     # ANSI code to move up N lines and move x to SOL&#xa;        else:&#xa;            string += ""\x1b[{0}A"".format(cur_y - target_y)  # ANSI code to move up N lines &#xa;&#xa;    if cur_x < target_x:    # MOVE RIGHT&#xa;        # **SIZE - Note that when the bgcolor is specified (not None) and not overdrawing another drawing (as in an animation case)&#xa;        # an optimization could be performed to draw spaces rather than output cursor advances. This would use less&#xa;        # size when advancing less than 3 columns since the min escape sequence here is len 4. Not implementing this now&#xa;        # \t (tab) could also be a cheap way to move forward, but not clear we can determine how far it goes or if that would&#xa;        # be consistent, nor whether it is ever destructive.&#xa;        string += ""\x1b[{0}C"".format(target_x - cur_x)  # ANSI code to move cursor right N columns&#xa;    elif cur_x > target_x:  # MOVE LEFT&#xa;        # **SIZE - potential optimizations: \b (backspace) could be a cheaper way to move backwards when there is only a short&#xa;        # way to go. However, not sure if it is ever destructive so not bothering with it now.    &#xa;        # If we need to move to x=0, \r could be a cheap way to get there. However not entirely clear whether some terminals&#xa;        # will move to next line as well, and might sometimes be destructive. Not going to research this so not doing it now. &#xa;        string += ""\x1b[{0}D"".format(cur_x - target_x)  # ANSI code to move cursor left N columns &#xa;&#xa;    return string&#xa;&#xa;&#xa;def generate_ANSI_from_pixels(pixels, width, height, bgcolor_rgba, current_ansi_colors = None, current_cursor_pos = None, get_pixel_func = None, is_overdraw = False, x_offset = 0):&#xa;    """"""&#xa;    Generate ANSI codes for passed pixels&#xa;       &#xa;    Does not include a final newline or a reset to any particular colors at end of returned output string.&#xa;    Caller should take care of that if desired.&#xa;     &#xa;    :param pixels: if get_pixel_func is None, 2D array of RGBA tuples indexed by [x,y]. &#xa;       Otherwise given to get_pixel_func as param.&#xa;    :param width: number of pixels to output on each row&#xa;    :param height: number of rows to output &#xa;    :param bgcolor_rgba: Optional background color used to fill new lines (produced when is_ovedraw is False)&#xa;       and a net new line to the terminal (as opposed to drawing on a current line - e.g. if the cursor was moved&#xa;       up) is produced. Also used as background color for any characters we output that don't fill the entire &#xa;       character area (e.g. a space fills the entire area, while X does not). Non-space only used if get_pixel_func&#xa;       returns it. If bgcolor_rgba is None, then the background is treated as the terminal's default background color&#xa;       which also means that partially transparent pixels will be treated as non-transparent (since we don't know &#xa;       bg color to blend them with).   &#xa;    :param current_ansi_colors: Optional dict holding ""current"" ANSI colors - allows optimization where &#xa;       we don't switch to these colors if already set. See info on return values for format of dict.&#xa;    :param current_cursor_pos: Optional dict holding current cursor position - allows optimization where &#xa;       we don't output extra moves to get to the right place to draw. Consider the passed position relative&#xa;       to where we want to draw the top/left for the current call. Note that a negative value for &#xa;       current_cursor_pos['y'] can be used to start drawing futher down the screen. Don't use ['x'] similarly &#xa;       since x is reset for each line. Use the x_offset param instead. &#xa;    :param get_pixel_func: Optional function that allows using custom ""pixel"" formats. If not None, function &#xa;       that will be passed pixels and a current x,y value and must return character to draw and RGBA to draw it in. &#xa;    :param is_overdraw: if True, drawing code can assume that all lines are being drawn on lines that were already&#xa;       established in the terminal. This allows for optimizations (e.g. not needing to output \n to fill blank lines).&#xa;    :param x_offset: If not zero, allows drawing each line starting at a particular X offset. Useful if &#xa;       you don't want it drawn at x=0. Must be >=0 &#xa;&#xa;    Returns tuple:&#xa;      string containing ANSI codes&#xa;      dict of form {'fg': (r,g,b,a), 'bg': (r,g,b,a)} holding current fg/bg color - suitable for passing as current_ansi_colors param&#xa;      dict of form {'x': <integer>, 'y': <integer>} holding final x,y cursor positions - x is absolute since \n sends it to 0. y is relative to incoming y (or 0 if none). Suitable for passing as current_cursor_pos param&#xa;    """"""&#xa;&#xa;    if get_pixel_func is None:&#xa;        get_pixel_func = lambda pixels, x, y: ("" "", pixels[x, y])      # just treat pixels as 2D array &#xa;&#xa;    # Compute ANSI bg color and strings we'll use to reset colors when moving to next line   &#xa;    if bgcolor_rgba is not None:&#xa;        bgcolor_ANSI = getANSIcolor_for_rgb(bgcolor_rgba)&#xa;        # Reset cur bg color to bgcolor because \n will fill the new line with this color&#xa;        bgcolor_ANSI_string = getANSIbgstring_for_ANSIcolor(bgcolor_ANSI)&#xa;    else:&#xa;        bgcolor_ANSI = None        &#xa;        # Reset cur bg color default because \n will fill the new line with this color (possibly only if BCE supported by terminal)&#xa;        bgcolor_ANSI_string = ""\x1b[49m""     # reset bg to default (if we want to support terminals that can't handle this will need to instead use 0m which clears fg too and then when using this reset prior_fg_color to None too&#xa;    &#xa;    # Do we know the current ANSI colors that have been set? &#xa;    if current_ansi_colors is not None:    &#xa;        string = """"&#xa;        prior_fg_color = current_ansi_colors['fg']       # Value of None is OK - means default&#xa;        prior_bg_color = current_ansi_colors['bg']       # Value of None is OK - means default&#xa;    else:&#xa;        # We don't know the current colors so output a reset to terminal defaults - we want to be in a known state&#xa;        # **SIZE - could suppress outputting this here, and remember that we have unknown (not same as default)&#xa;        # colors. Then when we need to output we can take this into account. If we wind up setting both fg and bg colors&#xa;        # for output (as for a non-space) then we'd never need to output the reset.  &#xa;        # I'm not going to implement this now since the better thing to do for repeated calls is to pass current_ansi_colors&#xa;        # so we'd never get to this case.&#xa;        string = ""\x1b[0m""          # removes all attributes (formatting and colors) to start in a known state&#xa;        prior_fg_color = None       # this is an ANSI color not rgba. None means default.&#xa;        prior_bg_color = None       # this is an ANSI color not rgba. None means default.&#xa;    &#xa;    # Do we know the cursor pos?&#xa;    if current_cursor_pos is not None:&#xa;        cursor_x = current_cursor_pos['x']&#xa;        cursor_y = current_cursor_pos['y']&#xa;    else:&#xa;        cursor_x = 0&#xa;        cursor_y = 0&#xa;&#xa;    for h in range(height):  &#xa;        for w in range(width):&#xa;&#xa;            draw_char, rgba = get_pixel_func(pixels, w, h)&#xa;&#xa;            # Handle fully or partially transparent pixels - but not if it is the special ""erase"" character (None)&#xa;            skip_pixel = False&#xa;            if draw_char is not None:&#xa;                alpha = rgba[3]&#xa;                if alpha == 0:&#xa;                    skip_pixel = True       # skip any full transparent pixel. Note that we don't output a bgcolor space (in specified or default cases). Why? In overdraw mode, that would be wrong since whatever is already drawn should show through. In non-overdraw, assumption is that any line we're drawing on has already been filled with bgcolor so lets not do extra output. If this was an issue in practice, could make it an option.                        &#xa;                elif alpha != 255 and bgcolor_rgba is not None:&#xa;                    rgba = alpha_blend(rgba, bgcolor_rgba)  # non-opaque so blend with specified bgcolor&#xa;                        &#xa;            if not skip_pixel:&#xa;&#xa;                this_pixel_str = """"&#xa;&#xa;                # Throw away alpha channel - can still have non-fully-opaque alpha value here if&#xa;                # bgcolor was partially transparent or if no bgcolor and not fully transparent&#xa;                # Could make argument to use threshold to decide if throw away (e.g. >50% transparent) &#xa;                # vs. consider opaque (e.g. <50% transparent) but at least for now we just throw it away &#xa;                # which means we treat the pixel as fully opaque.&#xa;                rgb = rgba[:3]   &#xa;                &#xa;                # If we've got the special ""erase"" character turn it into outputting a space using the bgcolor&#xa;                # which if None will just be a reset to default bg which is what we want&#xa;                if draw_char is None:&#xa;                    draw_char = "" ""&#xa;                    color = bgcolor_ANSI&#xa;                else:&#xa;                    # Convert from RGB to ansi color, using closest color. Conceivably we could optionally support&#xa;                    # dithering to spread the color error. Problematic when dealing with transparency (see cmt in dither_image_to_web_palette())&#xa;                    # or unknown/default bgcolor, and currently not worthwhile since either easy (img2txt) or more correct (graphics) to do &#xa;                    # dithering upstream. &#xa;                    color = getANSIcolor_for_rgb(rgb)&#xa;                &#xa;                    # Optimization - if we're drawing a space and the color is the same as a specified bg color&#xa;                    # then just skip this pixel. We need to make this check here because the conversion to ANSI above can &#xa;                    # cause colors that didn't match to now match&#xa;                    # We cannot do this optimization in overdraw mode because we cannot assume that the bg color&#xa;                    # is already drawn at this location. We could presumably pass in the known state of the screen&#xa;                    # and thus have this knoweldge if the optimization was worthwhile. &#xa;                    if not is_overdraw and (draw_char == "" "") and (color == bgcolor_ANSI):&#xa;                        skip_pixel = True&#xa;&#xa;                if not skip_pixel:&#xa;      &#xa;                    if len(draw_char) > 1:&#xa;                        raise ValueError(""Not allowing multicharacter draw strings"")&#xa;&#xa;                    # If we are not at the cursor location where we need to draw (happens if we skip pixels or lines)&#xa;                    # then output ANSI sequence to move cursor there.&#xa;                    # This is how we implement transparency - we don't draw spaces, we skip via cursor moves&#xa;                    # We take the x_offset (if any) into account here&#xa;                    ofsetted_w = x_offset + w&#xa;                    if (cursor_x != ofsetted_w) or (cursor_y != h):&#xa;                        string += generate_ANSI_to_move_cursor(cursor_x, cursor_y, ofsetted_w, h)&#xa;                        cursor_x = ofsetted_w&#xa;                        cursor_y = h&#xa;          &#xa;                    # Generate the ANSI sequences to set the colors the way we want them&#xa;                    if draw_char == "" "":&#xa;                &#xa;                        # **SIZE - If we are willing to assume terminals that support ECH (Erase Character) as specified&#xa;                        #   in here http://vt100.net/docs/vt220-rm/chapter4.html we could replace long runs of same-color&#xa;                        #   spaces with single ECH codes. Seems like it is only correct to do this if BCE is supported&#xa;                        #   though (http://superuser.com/questions/249898/how-can-i-prevent-os-x-terminal-app-from-overriding-vim-colours-on-a-remote-syst)&#xa;                        #   else ""erase"" would draw the _default_ background color not the currently set background color&#xa;                        #   Note that if we implement this by accumulating spaces (as opposed to lookahead), need to output that &#xa;                        #   before any different output be that a color change, or if we need to output a \n (if line ended &#xa;                        #   in same-color spaces in non-overdraw)&#xa;                                        &#xa;                        # We are supposed to output a space, so we're going to need to change the background color.&#xa;                        # No, we can't output an ""upper ascii"" character that fills the entire foreground - all terminals&#xa;                        # don't display such characters the same way, if at all. e.g. Mac terminal outputs ? for ""upper ascii"" chars&#xa;                        # Since we're outputting a space we can leave the prior fg color intact as it won't be used      &#xa;                        string += generate_ANSI_to_set_fg_bg_colors(prior_fg_color, prior_bg_color, prior_fg_color, color)&#xa;                        prior_bg_color = color&#xa;                    &#xa;                    else:&#xa;                        # We're supposed to output a non-space character, so we're going to need to change the foreground color&#xa;                        # and make sure the bg is set appropriately&#xa;                        string += generate_ANSI_to_set_fg_bg_colors(prior_fg_color, prior_bg_color, color, bgcolor_ANSI)&#xa;                        prior_fg_color = color&#xa;                        prior_bg_color = bgcolor_ANSI&#xa;&#xa;                    # Actually output the character&#xa;                    string += draw_char                               &#xa;&#xa;                    cursor_x = cursor_x + 1&#xa; &#xa;        # Handle end of line - unless last line which is NOP because we don't want to do anything to the _line after_ our drawing&#xa;        # and outputting \n would establish it and fill it&#xa;        if (h + 1) != height:&#xa;                      &#xa;            # Move to next line. If this establishes a new line in the terminal then it fills the _newly established line_&#xa;            # up to EOL with current bg color. Filling with the current bg color vs. default might be dependent on terminal's&#xa;            # support for BCE (Background Color Erase) - I'm not sure.&#xa;            # If cursor had been moved up and this just goes back down to an existing line, no filling occurs&#xa;            # In overdraw mode, we are going to assume we don't need to establish/fill a new line (which could be untrue&#xa;            # if we are overdrawing some lines but going further down too - if that becomes important can allow passing&#xa;            # in how many lines we can go down before hitting that). Next time we need to draw in overdraw mode we'll&#xa;            # move the cursor down as needed.&#xa;            if not is_overdraw:&#xa;&#xa;                # If not already desired color, reset bg color so \n fills with it&#xa;                # NOTE: it would be ideal to optionally dither the background color if it is not perfectly resolvable&#xa;                # in the palette we have to work with. However, we can't actually do this in the general case because&#xa;                # we don't know the width of the terminal (which can be different at display-time) and because we&#xa;                # don't always know the bg color (""default"" is not known by us, and not known by anybody until display-time) &#xa;                if prior_bg_color != bgcolor_ANSI:&#xa;                    string += bgcolor_ANSI_string;    &#xa;                    prior_bg_color = bgcolor_ANSI       &#xa;         &#xa;                # If the cursor is not at the correct y, move it there before outputting the newline&#xa;                # In current use this will only occur if current_cursor_pos includes a y offset and&#xa;                # the first line was entirely transparent. We pass 0/0 for cur/target x because no need&#xa;                # to adjust x as it will be changed by the \n &#xa;                if (cursor_y != h):&#xa;                    string += generate_ANSI_to_move_cursor(0, cursor_y, 0, h)&#xa;                    cursor_y = h&#xa;              &#xa;                string += ""\n""      &#xa;                cursor_y += 1&#xa;                cursor_x = 0        # we are assuming UNIX-style \n behavior - if it were windows we'd have to output \r to get cursor_x to 0&#xa;&#xa;    return string, {'fg': prior_fg_color, 'bg': prior_bg_color}, { 'x': cursor_x, 'y': cursor_y }&#xa;&#xa;&#xa;""""""&#xa;DESIGN NOTE (Global Optimization)&#xa;&#xa;The code in this file currently implements ""local optimization"" to minimize the cost of moving&#xa;the cursor around and changing colors. However, it always follows a top-to-bottom left-to-right&#xa;path. There are scenarios where choosing a different path would yield a more optimal result&#xa;(smaller output size). I have not bothered to implement any global optimization because I&#xa;think it will rarely produce a better output.&#xa;&#xa;Here's an example of a scenario where a global optimization of cursor movements that didn't just&#xa; go scanline by scanline top to bottom left to right would be a win:&#xa;&#xa;For example, assume this pattern is to be drawn, beginning at x=0 (SOL)&#xa;XXX      XXX&#xa;   XXX      XXX&#xa;      XXX      XXX              &#xa;Drawing it top down/left to right we must do 13 operations: &#xa;    XXX, move right, XXX, \n, move right, XXX, move right, XXX, \n, move right, XXX, move right, XXX  &#xa;Drawing it in an optimal sequence we can do 11 operations:&#xa;    XXX, move down, XXX, move down, XXX, move up, XXX, move down, XXX, move down, XXX&#xa;However, since \n is cheaper than move down, we actually would need blank lines between the XXX lines&#xa;to really make the second case smaller in terms of bytes (vs operations).&#xa;&#xa;The discussion above covers cursor changes, but of cours color changes play a role as well. If we were&#xa;to assume the XXX on the left were one color while the XXX on the right were another, we'd also save four&#xa;color change operations.&#xa;&#xa;To perfectly implement global optimization, you essentially need to solve a variant of the Traveling &#xa;Salesman Path Problem (TSPP) as I discuss here: http://stackoverflow.com/questions/20032768/graph-traversal-with-shortest-path-with-any-source/33601043#33601043&#xa;We could use the single fixed endpoint variant (P*s) from the Hoogeveen paper. Note that each character&#xa;we want to output is essentially a node in the graph, and the graph is fully connected (can move from&#xa;any character to any other via cursor moves, changing color as needed). Some edges are free (moving right&#xa;while outputting character of same color). It is actually an asymmetric TSP because there are cases&#xa;where e.g. moving right is free and moving left is not, and moving down to SOL via \n costs 1 while moving&#xa;back up to the x pos could be several bytes. Can solve asymmetric TSP via conversion to symmetric.&#xa;Solving a TSPP is generally computationally infeasible, so approximation algorithms such as Hoogeveen's are used.&#xa;Hoogeveen run O(n^3) so it too may be too slow. Can reduce n by combining runs of same color - I haven't bothered&#xa;to prove it but I believe that this does not harm the optimality of the result. Note that this does not reduce&#xa;the worst case n - you can a case where there are no such runs. I believe that there are faster algorithms&#xa;that provide worse (or zero) optimality guarantees - e.g. Lin Kernighan or nearest neighbor. These might be geared&#xa;to solve TSP vs TSPP - though a solution to TSP is also a solution to TSPP, just with the cycle completed and &#xa;no prescribed starting location. We would remove the cycle completing hop, and output a move to the chosen start&#xa;location as needed. The algorithms might also be adaptable to TSPP directly. &#xa;If TSPP solvers can never be made fast enough, heuristics can likely be employed to good effect.&#xa;Solutions from a TSPP solver might be a good way to find such heuristics.&#xa;&#xa;ANSI codes to save/restore cursor pos could open new vistas of global optimization since you can&#xa;restore x/y in only 3 bytes but they are seemingly not supported in Mac xterm so I don't use them.&#xa;""""""&#xa;"
279237|"#!/usr/bin/env python&#xa;&#xa;# Test whether a client produces a correct connect with a will, username and password.&#xa;&#xa;# The client should connect to port 1888 with keepalive=60, clean session set,&#xa;# client id 01-will-unpwd-set , will topic set to ""will-topic"", will payload&#xa;# set to ""will message"", will qos=2, will retain not set, username set to&#xa;# ""oibvvwqw"" and password set to ""#'^2hg9a&nm38*us"".&#xa;&#xa;import inspect&#xa;import os&#xa;import socket&#xa;import sys&#xa;&#xa;# From http://stackoverflow.com/questions/279237/python-import-a-module-from-a-folder&#xa;cmd_subfolder = os.path.realpath(os.path.abspath(os.path.join(os.path.split(inspect.getfile( inspect.currentframe() ))[0],"".."")))&#xa;if cmd_subfolder not in sys.path:&#xa;    sys.path.insert(0, cmd_subfolder)&#xa;&#xa;import mosq_test&#xa;&#xa;rc = 1&#xa;keepalive = 60&#xa;connect_packet = mosq_test.gen_connect(""01-will-unpwd-set"",&#xa;        keepalive=keepalive, username=""oibvvwqw"", password=""#'^2hg9a&nm38*us"",&#xa;        will_topic=""will-topic"", will_qos=2, will_payload=""will message"")&#xa;&#xa;sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)&#xa;sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)&#xa;sock.settimeout(10)&#xa;sock.bind(('', 1888))&#xa;sock.listen(5)&#xa;&#xa;client_args = sys.argv[1:]&#xa;env = dict(os.environ)&#xa;env['LD_LIBRARY_PATH'] = '../../lib:../../lib/cpp'&#xa;try:&#xa;    pp = env['PYTHONPATH']&#xa;except KeyError:&#xa;    pp = ''&#xa;env['PYTHONPATH'] = '../../lib/python:'+pp&#xa;client = mosq_test.start_client(filename=sys.argv[1].replace('/', '-'), cmd=client_args, env=env)&#xa;&#xa;try:&#xa;    (conn, address) = sock.accept()&#xa;    conn.settimeout(10)&#xa;&#xa;    if mosq_test.expect_packet(conn, ""connect"", connect_packet):&#xa;        rc = 0&#xa;&#xa;    conn.close()&#xa;finally:&#xa;    client.terminate()&#xa;    client.wait()&#xa;    sock.close()&#xa;&#xa;exit(rc)&#xa;&#xa;"
264224|"#!/usr/bin/env python&#xa;&#xa;""""""&#xa;Given an input path and an output path, will put&#xa;Gzipped versions of all files from the input path&#xa;to the output path.&#xa;&#xa;If the file is not gzippable it will be copied&#xa;uncompressed.&#xa;""""""&#xa;&#xa;from fnmatch import fnmatch&#xa;import gzip&#xa;import os&#xa;import shutil&#xa;import sys&#xa;&#xa;class FakeTime:&#xa;    def time(self):&#xa;        return 1261130520.0&#xa;&#xa;# Hack to override gzip's time implementation&#xa;# See: http://stackoverflow.com/questions/264224/setting-the-gzip-timestamp-from-python&#xa;gzip.time = FakeTime()&#xa;&#xa;def is_compressable(filename, gzip_globs):&#xa;    """"""&#xa;    Determine if a filename is a gzippable type&#xa;    by comparing to a known list.&#xa;    """"""&#xa;    return any([fnmatch(filename, glob) for glob in gzip_globs])&#xa;&#xa;def compress(file_path):&#xa;    """"""&#xa;    Gzip a single file in place.&#xa;    """"""&#xa;    f_in = open(file_path, 'rb')&#xa;    contents = f_in.readlines()&#xa;    f_in.close()&#xa;    f_out = gzip.open(file_path, 'wb')&#xa;    f_out.writelines(contents)&#xa;    f_out.close()&#xa;&#xa;def main():&#xa;    in_path = sys.argv[1]&#xa;    out_path = sys.argv[2]&#xa;&#xa;    with open('gzip_types.txt') as f:&#xa;        gzip_globs = [glob.strip() for glob in f]&#xa;&#xa;    # Folders&#xa;    if os.path.isdir(in_path):&#xa;        shutil.rmtree(out_path, ignore_errors=True)&#xa;        shutil.copytree(in_path, out_path)&#xa;&#xa;        for path, dirs, files in os.walk(sys.argv[2]):&#xa;            for filename in files:&#xa;                # Is it a gzippable file type?&#xa;                if not is_compressable(filename, gzip_globs):&#xa;                    continue&#xa;&#xa;                file_path = os.path.join(path, filename)&#xa;&#xa;                compress(file_path)&#xa;    # Single files&#xa;    else:&#xa;        filename = os.path.split(in_path)[-1]&#xa;&#xa;        try:&#xa;            os.remove(out_path)&#xa;        except OSError:&#xa;            pass&#xa;&#xa;        shutil.copy(in_path, out_path)&#xa;&#xa;        if not is_compressable(filename, gzip_globs):&#xa;            return &#xa;&#xa;        compress(out_path)&#xa;&#xa;&#xa;if __name__ == '__main__':&#xa;    main()&#xa;"
13436167|#!/usr/bin/env python&#xa;&#xa;import re&#xa;import json&#xa;&#xa;# http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae&#xa;# http://stackoverflow.com/a/13436167/96656&#xa;def unisymbol(codePoint):&#xa;	if codePoint >= 0x0000 and codePoint <= 0xFFFF:&#xa;		return unichr(codePoint)&#xa;	elif codePoint >= 0x010000 and codePoint <= 0x10FFFF:&#xa;		highSurrogate = int((codePoint - 0x10000) / 0x400) + 0xD800&#xa;		lowSurrogate = int((codePoint - 0x10000) % 0x400) + 0xDC00&#xa;		return unichr(highSurrogate) + unichr(lowSurrogate)&#xa;	else:&#xa;		return 'Error'&#xa;&#xa;def hexify(codePoint):&#xa;	return 'U+' + hex(codePoint)[2:].upper().zfill(6)&#xa;&#xa;def writeFile(filename, contents):&#xa;	print filename&#xa;	with open(filename, 'w') as f:&#xa;		f.write(contents.strip() + '\n')&#xa;&#xa;data = []&#xa;for codePoint in range(0x000000, 0x10FFFF + 1):&#xa;	symbol = unisymbol(codePoint)&#xa;	# http://stackoverflow.com/a/17199950/96656&#xa;	bytes = symbol.encode('utf8').decode('latin1')&#xa;	data.append({&#xa;		'codePoint': codePoint,&#xa;		'decoded': symbol,&#xa;		'encoded': bytes&#xa;	});&#xa;&#xa;jsonData = json.dumps(data, sort_keys=False, indent=2, separators=(',', ': '))&#xa;# Use tabs instead of double spaces for indentation&#xa;jsonData = jsonData.replace('  ', '\t')&#xa;# Escape hexadecimal digits in escape sequences&#xa;jsonData = re.sub(&#xa;	r'\\u([a-fA-F0-9]{4})',&#xa;	lambda match: r'\u{}'.format(match.group(1).upper()),&#xa;	jsonData&#xa;)&#xa;&#xa;writeFile('data.json', jsonData)&#xa;
3828723|"""""""&#xa;Python part of radio playout (pypo)&#xa;""""""&#xa;&#xa;from optparse import OptionParser&#xa;from datetime import datetime&#xa;&#xa;import telnetlib&#xa;&#xa;import time&#xa;import sys&#xa;import signal&#xa;import logging&#xa;import locale&#xa;import os&#xa;import re&#xa;&#xa;from Queue import Queue&#xa;from threading import Lock&#xa;&#xa;from pypopush import PypoPush&#xa;from pypofetch import PypoFetch&#xa;from pypofile import PypoFile&#xa;from recorder import Recorder&#xa;from listenerstat import ListenerStat&#xa;from pypomessagehandler import PypoMessageHandler&#xa;from pypoliquidsoap import PypoLiquidsoap&#xa;from timeout import ls_timeout&#xa;&#xa;from pypo.media.update.replaygainupdater import ReplayGainUpdater&#xa;from pypo.media.update.silananalyzer import SilanAnalyzer&#xa;&#xa;from configobj import ConfigObj&#xa;&#xa;# custom imports&#xa;from api_clients import api_client&#xa;#from std_err_override import LogWriter&#xa;import pure&#xa;&#xa;LOG_PATH = '/var/log/airtime/pypo/pypo.log'&#xa;LOG_LEVEL = logging.INFO&#xa;&#xa;# Set up command-line options&#xa;parser = OptionParser()&#xa;&#xa;# help screen / info&#xa;usage = ""%prog [options]"" + "" - python playout system""&#xa;parser = OptionParser(usage=usage)&#xa;&#xa;# Options&#xa;parser.add_option(""-v"", ""--compat"",&#xa;        help=""Check compatibility with server API version"",&#xa;        default=False,&#xa;        action=""store_true"",&#xa;        dest=""check_compat"")&#xa;&#xa;parser.add_option(""-t"", ""--test"",&#xa;        help=""Do a test to make sure everything is working properly."",&#xa;        default=False,&#xa;        action=""store_true"",&#xa;        dest=""test"")&#xa;&#xa;parser.add_option(""-b"",&#xa;        ""--cleanup"",&#xa;        help=""Cleanup"",&#xa;        default=False,&#xa;        action=""store_true"",&#xa;        dest=""cleanup"")&#xa;&#xa;parser.add_option(""-c"",&#xa;        ""--check"",&#xa;        help=""Check the cached schedule and exit"",&#xa;        default=False,&#xa;        action=""store_true"",&#xa;        dest=""check"")&#xa;&#xa;# parse options&#xa;(options, args) = parser.parse_args()&#xa;&#xa;LIQUIDSOAP_MIN_VERSION = ""1.1.1""&#xa;&#xa;PYPO_HOME='/var/tmp/airtime/pypo/'&#xa;&#xa;def configure_environment():&#xa;    os.environ[""HOME""] = PYPO_HOME&#xa;    os.environ[""TERM""] = 'xterm'&#xa;&#xa;configure_environment()&#xa;&#xa;# need to wait for Python 2.7 for this..&#xa;logging.captureWarnings(True)&#xa;&#xa;# configure logging&#xa;try:&#xa;    # Set up logging&#xa;    logFormatter = logging.Formatter(""%(asctime)s [%(module)s] [%(levelname)-5.5s]  %(message)s"")&#xa;    rootLogger = logging.getLogger()&#xa;    rootLogger.setLevel(LOG_LEVEL)&#xa;    logger = rootLogger&#xa;&#xa;    consoleHandler = logging.StreamHandler()&#xa;    consoleHandler.setFormatter(logFormatter)&#xa;    rootLogger.addHandler(consoleHandler)&#xa;except Exception, e:&#xa;    print ""Couldn't configure logging"", e&#xa;    sys.exit(1)&#xa;&#xa;def configure_locale():&#xa;    """"""&#xa;    Silly hacks to force Python 2.x to run in UTF-8 mode. Not portable at all,&#xa;    however serves our purpose at the moment.&#xa;&#xa;    More information available here:&#xa;    http://stackoverflow.com/questions/3828723/why-we-need-sys-setdefaultencodingutf-8-in-a-py-script&#xa;    """"""&#xa;    logger.debug(""Before %s"", locale.nl_langinfo(locale.CODESET))&#xa;    current_locale = locale.getlocale()&#xa;&#xa;    if current_locale[1] is None:&#xa;        logger.debug(""No locale currently set. Attempting to get default locale."")&#xa;        default_locale = locale.getdefaultlocale()&#xa;&#xa;        if default_locale[1] is None:&#xa;            logger.debug(""No default locale exists. Let's try loading from \&#xa;                    /etc/default/locale"")&#xa;            if os.path.exists(""/etc/default/locale""):&#xa;                locale_config = ConfigObj('/etc/default/locale')&#xa;                lang = locale_config.get('LANG')&#xa;                new_locale = lang&#xa;            else:&#xa;                logger.error(""/etc/default/locale could not be found! Please \&#xa;                        run 'sudo update-locale' from command-line."")&#xa;                sys.exit(1)&#xa;        else:&#xa;            new_locale = default_locale&#xa;&#xa;        logger.info(""New locale set to: %s"", \&#xa;                locale.setlocale(locale.LC_ALL, new_locale))&#xa;&#xa;    reload(sys)&#xa;    sys.setdefaultencoding(""UTF-8"")&#xa;    current_locale_encoding = locale.getlocale()[1].lower()&#xa;    logger.debug(""sys default encoding %s"", sys.getdefaultencoding())&#xa;    logger.debug(""After %s"", locale.nl_langinfo(locale.CODESET))&#xa;&#xa;    if current_locale_encoding not in ['utf-8', 'utf8']:&#xa;        logger.error(""Need a UTF-8 locale. Currently '%s'. Exiting..."" % \&#xa;                current_locale_encoding)&#xa;        sys.exit(1)&#xa;&#xa;&#xa;configure_locale()&#xa;&#xa;# loading config file&#xa;try:&#xa;    config = ConfigObj('/etc/airtime/airtime.conf')&#xa;except Exception, e:&#xa;    logger.error('Error loading config file: %s', e)&#xa;    sys.exit(1)&#xa;&#xa;class Global:&#xa;    def __init__(self, api_client):&#xa;        self.api_client = api_client&#xa;&#xa;    def selfcheck(self):&#xa;        return self.api_client.is_server_compatible()&#xa;&#xa;    def test_api(self):&#xa;        self.api_client.test()&#xa;&#xa;def keyboardInterruptHandler(signum, frame):&#xa;    logger = logging.getLogger()&#xa;    logger.info('\nKeyboard Interrupt\n')&#xa;    sys.exit(0)&#xa;&#xa;@ls_timeout&#xa;def liquidsoap_get_info(telnet_lock, host, port, logger):&#xa;    logger.debug(""Checking to see if Liquidsoap is running"")&#xa;    try:&#xa;        telnet_lock.acquire()&#xa;        tn = telnetlib.Telnet(host, port)&#xa;        msg = ""version\n""&#xa;        tn.write(msg)&#xa;        tn.write(""exit\n"")&#xa;        response = tn.read_all()&#xa;    except Exception, e:&#xa;        logger.error(str(e))&#xa;        return None&#xa;    finally:&#xa;        telnet_lock.release()&#xa;&#xa;    return get_liquidsoap_version(response)&#xa;&#xa;def get_liquidsoap_version(version_string):&#xa;    m = re.match(r""Liquidsoap (\d+.\d+.\d+)"", version_string)&#xa;&#xa;    if m:&#xa;        return m.group(1)&#xa;    else:&#xa;        return None&#xa;&#xa;&#xa;    if m:&#xa;        current_version = m.group(1)&#xa;        return pure.version_cmp(current_version, LIQUIDSOAP_MIN_VERSION) >= 0&#xa;    return False&#xa;&#xa;def liquidsoap_startup_test():&#xa;&#xa;    liquidsoap_version_string = \&#xa;            liquidsoap_get_info(telnet_lock, ls_host, ls_port, logger)&#xa;    while not liquidsoap_version_string:&#xa;        logger.warning(""Liquidsoap doesn't appear to be running!, "" + \&#xa;               ""Sleeping and trying again"")&#xa;        time.sleep(1)&#xa;        liquidsoap_version_string = \&#xa;                liquidsoap_get_info(telnet_lock, ls_host, ls_port, logger)&#xa;&#xa;    while pure.version_cmp(liquidsoap_version_string, LIQUIDSOAP_MIN_VERSION) < 0:&#xa;        logger.warning(""Liquidsoap is running but in incorrect version! "" + \&#xa;                ""Make sure you have at least Liquidsoap %s installed"" % LIQUIDSOAP_MIN_VERSION)&#xa;        time.sleep(1)&#xa;        liquidsoap_version_string = \&#xa;                liquidsoap_get_info(telnet_lock, ls_host, ls_port, logger)&#xa;&#xa;    logger.info(""Liquidsoap version string found %s"" % liquidsoap_version_string)&#xa;&#xa;&#xa;if __name__ == '__main__':&#xa;    logger.info('###########################################')&#xa;    logger.info('#             *** pypo  ***               #')&#xa;    logger.info('#   Liquidsoap Scheduled Playout System   #')&#xa;    logger.info('###########################################')&#xa;&#xa;    #Although all of our calculations are in UTC, it is useful to know what timezone&#xa;    #the local machine is, so that we have a reference for what time the actual&#xa;    #log entries were made&#xa;    logger.info(""Timezone: %s"" % str(time.tzname))&#xa;    logger.info(""UTC time: %s"" % str(datetime.utcnow()))&#xa;&#xa;    signal.signal(signal.SIGINT, keyboardInterruptHandler)&#xa;&#xa;    api_client = api_client.AirtimeApiClient()&#xa;    g = Global(api_client)&#xa;&#xa;    while not g.selfcheck():&#xa;        time.sleep(5)&#xa;&#xa;    success = False&#xa;    while not success:&#xa;        try:&#xa;            api_client.register_component('pypo')&#xa;            success = True&#xa;        except Exception, e:&#xa;            logger.error(str(e))&#xa;            time.sleep(10)&#xa;&#xa;    telnet_lock = Lock()&#xa;&#xa;    ls_host = config['pypo']['ls_host']&#xa;    ls_port = config['pypo']['ls_port']&#xa;&#xa;    liquidsoap_startup_test()&#xa;&#xa;    if options.test:&#xa;        g.test_api()&#xa;        sys.exit(0)&#xa;&#xa;&#xa;    ReplayGainUpdater.start_reply_gain(api_client)&#xa;    SilanAnalyzer.start_silan(api_client, logger)&#xa;&#xa;    pypoFetch_q = Queue()&#xa;    recorder_q = Queue()&#xa;    pypoPush_q = Queue()&#xa;&#xa;    pypo_liquidsoap = PypoLiquidsoap(logger, telnet_lock,\&#xa;            ls_host, ls_port)&#xa;&#xa;    """"""&#xa;    This queue is shared between pypo-fetch and pypo-file, where pypo-file&#xa;    is the consumer. Pypo-fetch will send every schedule it gets to pypo-file&#xa;    and pypo will parse this schedule to determine which file has the highest&#xa;    priority, and retrieve it.&#xa;    """"""&#xa;    media_q = Queue()&#xa;&#xa;    # Pass only the configuration sections needed; PypoMessageHandler only needs rabbitmq settings&#xa;    pmh = PypoMessageHandler(pypoFetch_q, recorder_q, config['rabbitmq'])&#xa;    pmh.daemon = True&#xa;    pmh.start()&#xa;&#xa;    pfile = PypoFile(media_q, config['pypo'])&#xa;    pfile.daemon = True&#xa;    pfile.start()&#xa;&#xa;    pf = PypoFetch(pypoFetch_q, pypoPush_q, media_q, telnet_lock, pypo_liquidsoap, config['pypo'])&#xa;    pf.daemon = True&#xa;    pf.start()&#xa;&#xa;    pp = PypoPush(pypoPush_q, telnet_lock, pypo_liquidsoap, config['pypo'])&#xa;    pp.daemon = True&#xa;    pp.start()&#xa;&#xa;    recorder = Recorder(recorder_q)&#xa;    recorder.daemon = True&#xa;    recorder.start()&#xa;&#xa;    stat = ListenerStat()&#xa;    stat.daemon = True&#xa;    stat.start()&#xa;&#xa;    # Just sleep the main thread, instead of blocking on pf.join().&#xa;    # This allows CTRL-C to work!&#xa;    while True:&#xa;        time.sleep(1)&#xa;&#xa;    logger.info(""System exit"")&#xa;"
1160227|import os&#xa;&#xa;&#xa;# from https://stackoverflow.com/a/1160227&#xa;def touch(fname, times=None):&#xa;    with open(fname, 'a'):&#xa;        os.utime(fname, times)&#xa;
